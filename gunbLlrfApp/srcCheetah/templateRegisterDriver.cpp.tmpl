/**
 *-----------------------------------------------------------------------------
 * Title      : low level RF register EPICS interface
 * ----------------------------------------------------------------------------
 * File       : ${name}Drv.h
 * Author     : Garth Brown, gwbrown@slac.stanford.edu
 * Created    : June 17, 2016
 * Last update: September 6, 2016
 * ----------------------------------------------------------------------------
 * Description:
 * Header defining register interface to ${name}, autogenerated from a python
 * dictionary.
 *
 * ----------------------------------------------------------------------------
 * This file is part of LCLS II. It is subject to
 * the license terms in the LICENSE.txt file found in the top-level directory
 * of this distribution and at:
	* https://confluence.slac.stanford.edu/display/ppareg/LICENSE.html.
 * No part of LCLS II, including this file, may be
 * copied, modified, propagated, or distributed except according to the terms
 * contained in the LICENSE.txt file.
 * ----------------------------------------------------------------------------
**/

\#include "${name}Drv.h"
\#include <asynOctetSyncIO.h>
\#include <asynCommonSyncIO.h>
\#include <limits>
\#include <netinet/in.h>
\#include <iostream>
using namespace std;
\#include <math.h>

/* SHA1 hash of register map */
const char *${name}Drv::regMapSha1String = "${sha1}";
/* Register names */
#set $polledRegCount = 0
#set $writeRegCount = 0
#set $prevWAdrs = []
#set $prevRAdrs =[]
#for $p in sorted($registers, key=lambda k: k['name'])
#if $p.has_key('desc')
// ${p.desc}
#end if
#if (not $p.has_key('access')) or ('r' in $p.access)
const char *${name}Drv::${p.name.title().replace("_", "")}RString = "${p.name.upper()}_R";
	#if $p.address not in $prevRAdrs
	#if ($p.has_key('nelm') and $p.nelm>32)
		## exclude arrays with > 32 elements from polling
		#set $count_inc = 0
const char *${name}Drv::${p.name.title().replace("_", "")}WavString = "${p.name.upper()}_WAV";
//const unsigned int ${p.name.title().replace("_", "")}BufRegCount = $p.nelm;
//const unsigned int ${p.name.title().replace("_", "")}ReqSegmentCount = (${p.name.title().replace("_", "")}BufRegCount + maxRegPerMsg -1)/maxRegPerMsg; // # of UDP requests, divide and round up;
//const unsigned int ${p.name.title().replace("_", "")}ReqMsgSize = ${p.name.title().replace("_", "")}BufRegCount + ${p.name.title().replace("_", "")}ReqSegmentCount; // All register addresses plus nonce space
	#else if bool(re.search(r'U\d|lspi', $p.name))
		## exclude registers with side effectes from polling
		#set $count_inc = 0
	#else if $p.has_key('nelm') and $p.nelm<=32
		#set $count_inc = $p.nelm
		#if $p.nelm>1
const char *${name}Drv::${p.name.title().replace("_", "")}WavString = "${p.name.upper()}_WAV";
		#end if
	#else if not $p.has_key('nelm')
		#set $count_inc = 1
	#end if
	#set $polledRegCount += $count_inc
	#silent $prevRAdrs.append($p.address)
	#else
// shared address $p.address for $p.name
	#end if
#end if
#if $p.has_key('access') and ('w' in $p.access)
const char *${name}Drv::${p.name.title().replace("_", "")}WString = "${p.name.upper()}_W";
	#if $p.address not in $prevWAdrs
	#if $p.has_key('nelm') and $p.nelm<=32
		#if ($p.nelm>1) and ($p.address not in $prevRAdrs)
const char *${name}Drv::${p.name.title().replace("_", "")}WavString = "${p.name.upper()}_WAV";
		#end if
		#set $count_inc = $p.nelm
	#else if $p.has_key('nelm') and $p.nelm>32
		#set $count_inc = 0
		## WAV doesn't have R and W variations, skip if this was done in the R section above
		#if $p.address not in $prevRAdrs
const char *${name}Drv::${p.name.title().replace("_", "")}WavString = "${p.name.upper()}_WAV";
		#end if
	#else
		#set $count_inc = 1
	#end if
	#set $writeRegCount += $count_inc
	#silent $prevWAdrs.append($p.address)
	#end if
#end if
#end for

const unsigned int ${name}Drv::${name}PolledRegCount = $polledRegCount;

/** Constructor for the ${name} class.
 * Calls constructor for the asynPortDriver base class.
 * \param[in] drvPortName The name of the asyn port driver to be created.
 * \param[in] netPortName The name of the asyn port driver to use for the network connection
 * \param[in] maxAddr The number of channels for the paramater with the most channels
 * \paarm[in] paramTableSize The number of asyn params to be created for each device
 *
 * */
//${name}Drv::${name}Drv(const char *drvPortName, const char *netPortName)
//: leepDrv(drvPortName, netPortName,
//		8, /* maxAddr, i.e. number of channels */
//		NUM_${name.upper()}_PARAMS)
//{
//	// NUM_SCLLRFPRC_PARAMS is a macro using protected member variables,
//	// which the compiler has problems with..
//	${name}Drv(drvPortName, netPortName, 8, NUM_${name.upper()}_PARAMS);
//};

${name}Drv::${name}Drv(const char *drvPortName, const char *netPortName, int maxAddr, int paramTableAdds)
: leepDrv(drvPortName, netPortName,
		maxAddr, /* maxAddr, i.e. number of channels */
		paramTableAdds + NUM_${name.upper()}_PARAMS)
#for $p in sorted($registers, key=lambda k: k['name'])
	#if $p.has_key('nelm') and $p.nelm>1
		#if (not $p.has_key('access')) or ('r' in $p.access)
	, ${p.name.title().replace("_", "")}Buf ( ${p.name.title().replace("_", "")}RegCount, ${p.name.title().replace("_", "")}RAdr )
		#else
	, ${p.name.title().replace("_", "")}Buf ( ${p.name.title().replace("_", "")}RegCount, ${p.name.title().replace("_", "")}WAdr )
		#end if
	#end if
#end for
{
	epicsThreadSleep(defaultPollPeriod);
	regInterface tmpRegIf;
#import re
#for $p in sorted($registers, key=lambda k: k['name'])
#if $p.has_key('nelm') and $p.nelm>1
	#if ($p.has_key('bit_width') and ($p.bit_width <= 8)) or ($p.has_key('data_width') and ($p.data_width <= 8))
	createParam(${p.name.title().replace("_", "")}WavString, asynParamInt8Array, &p_${p.name.title().replace("_", "")}Wav);
	#else if ($p.has_key('bit_width') and ($p.bit_width <= 16)) or ($p.has_key('data_width') and ($p.data_width <= 16))
	createParam(${p.name.title().replace("_", "")}WavString, asynParamInt16Array, &p_${p.name.title().replace("_", "")}Wav);
	#else
	createParam(${p.name.title().replace("_", "")}WavString, asynParamInt32Array, &p_${p.name.title().replace("_", "")}Wav);
	#end if
	#if (not $p.has_key('access')) or ('r' in $p.access)
	createParam(${p.name.title().replace("_", "")}RString, asynParamInt32, &p_${p.name.title().replace("_", "")}R);
	#end if
	#if $p.has_key('access') and ('w' in $p.access)
		#if $p.has_key('nelm') and $p.nelm>512
	createParam(${p.name.title().replace("_", "")}WString, asynParamInt32, &p_${p.name.title().replace("_", "")}W);
		#else
	createParam(${p.name.title().replace("_", "")}WString, asynParamInt32, &p_${p.name.title().replace("_", "")}W);
		#end if
	#end if
#else
	#if (not $p.has_key('access')) or ('r' in $p.access)
		#if ($p.has_key('bits'))
	createParam(${p.name.title().replace("_", "")}RString, asynParamUInt32Digital, &p_${p.name.title().replace("_", "")}R);
	tmpRegIf.paramType = asynParamUInt32Digital;
		#else
	createParam(${p.name.title().replace("_", "")}RString, asynParamInt32, &p_${p.name.title().replace("_", "")}R);
	tmpRegIf.paramType = asynParamInt32;
		#end if
	tmpRegIf.paramNum = p_${p.name.title().replace("_", "")}R;
	tmpRegIf.isReadable = true;
	tmpRegIf.readAddr = ${p.name.title().replace("_", "")}RAdr;
	#else
	tmpRegIf.isReadable = false;
	tmpRegIf.readAddr = 0;
	#end if
	#if $p.has_key('access') and ('w' in $p.access)
		#if ($p.has_key('bits'))
	createParam(${p.name.title().replace("_", "")}WString, asynParamUInt32Digital, &p_${p.name.title().replace("_", "")}W);
	tmpRegIf.paramType = asynParamUInt32Digital;
		#else
	createParam(${p.name.title().replace("_", "")}WString, asynParamInt32, &p_${p.name.title().replace("_", "")}W);
	tmpRegIf.paramType = asynParamInt32;
		#end if
	tmpRegIf.paramNum = p_${p.name.title().replace("_", "")}W;
	tmpRegIf.isWritable = true;
	tmpRegIf.writeAddr = ${p.name.title().replace("_", "")}WAdr;
	#else
	tmpRegIf.isWritable = false;
	tmpRegIf.writeAddr = 0;
	#end if
	#if $p.has_key('access') and ('w' in $p.access)
	paramToReg[p_${p.name.title().replace("_", "")}W] = tmpRegIf;
	addrToReg[${p.name.title().replace("_", "")}WAdr] = tmpRegIf;
	#else
	paramToReg[p_${p.name.title().replace("_", "")}R] = tmpRegIf;
	addrToReg[${p.name.title().replace("_", "")}RAdr] = tmpRegIf;
	#end if
#end if
#end for

	// Message size is the number of read registers, plus 1 nonce for every 175 read registers
	PolledRegMsgSize_ = ${name}PolledRegCount + (${name}PolledRegCount / 175) + 1;
	// A canned request to read all registers
	pPolledRegMsg_ = new FpgaReg[PolledRegMsgSize_]
	{
#set $msgRegCount = 0
#set $prevAdr=-1
#for $p in sorted($registers, key=lambda k: k['address'])
#if $p.has_key('nelm') and $p.nelm<=32
	#set $chan_count = $p.nelm
#else
	#set $chan_count = 1
#end if
#unless ($p.has_key('access') and $p.access == 'w') or ($prevAdr == $p.address) or ($p.has_key('nelm') and $p.nelm>32) or bool(re.search(r'U\d|lspi', $p.name))
	#for $chan_num in range(0, $chan_count )
	#if msgRegCount % 174 == 0
		{ 0, 0 },
	#end if
		#if $chan_num == 0
		{ (flagReadMask | ${p.name.title().replace("_", "")}RAdr), blankData },
		#else
		{ (flagReadMask | ${p.name.title().replace("_", "")}RAdr) + $chan_num, blankData },
		#end if
	#set $prevAdr = $p.address
	#set $msgRegCount += 1
	#end for
#end unless
#end for
	};

	htonFpgaRegArray(pPolledRegMsg_, PolledRegMsgSize_);

	epicsThreadSleep(defaultPollPeriod);
	printf("%s created %ld of %ld parameters.\n",__PRETTY_FUNCTION__,NUM_${name.upper()}_PARAMS, paramTableAdds+NUM_${name.upper()}_PARAMS);

	setStringParam(p_JsonSha1Des, regMapSha1String);
	wakeupPoller();
	wakeupReader();
}

${name}Drv::~${name}Drv()
{
	isShuttingDown_ = true;
	epicsThreadSleep(0.1); // Allow threads to run and exit
	wakeupPoller();
	wakeupReader();
	epicsThreadSleep(0.1); // Allow threads to run and exit
	wakeupPoller(); // call this twice in case the poller was never set to run
	wakeupReader();
	epicsThreadSleep(0.1); // Allow threads to run and exit
	wakeupReader();
	pasynOctetSyncIO->disconnect(pOctetAsynUser_);
	pasynCommonSyncIO->disconnectDevice(pCommonAsynUser_);
	pasynCommonSyncIO->disconnect(pCommonAsynUser_);
}

/** Called when you have the asyn parameter name and want the corresponding
 * register address.
  * \param[in] function From pAsynUser->reason, corresponding to a registered parameter.
  * \param[in] pToFpga Pointer to the {Address, Data} structure where the register address will be written
  * \param[in] nElements Number of elements to read. */
asynStatus ${name}Drv::functionToRegister(const int function, FpgaReg *pToFpga)
{
	asynStatus status = asynSuccess;

#for $p in sorted($registers, key=lambda k: k['name'])
#if (not $p.has_key('access')) or ('r' in $p.access)
	#if ( $p.has_key('nelm') and $p.nelm > 1 )
	if( (function == p_${p.name.title().replace("_", "")}R ) or (function == p_${p.name.title().replace("_", "")}Wav ))
	#else
	if( function == p_${p.name.title().replace("_", "")}R )
	#end if
	{
		pToFpga->addr = ${p.name.title().replace("_", "")}RAdr|flagReadMask;
	}
	else
#end if
#if $p.has_key('access') and ('w' in $p.access)
	#if ( $p.has_key('nelm') and $p.nelm > 1 )
	if( (function == p_${p.name.title().replace("_", "")}W ) or (function == p_${p.name.title().replace("_", "")}Wav ))
	#else
		if( function == p_${p.name.title().replace("_", "")}W )
	#end if
	{
		pToFpga->addr = ${p.name.title().replace("_", "")}WAdr;
	}
	else
#end if
#end for
		status = asynError;

	return status;
}

/**  Extract register address and data from the received message and set the appropriate
 * asyn parameter.
 * Some registers have a "new waveform data ready" flag. If they have this and it is set,
 * set weveIsReady to true.
* \param[in] pFromFpga Data returned from the FPGA for a single register
*/
asynStatus ${name}Drv::processRegReadback(const FpgaReg *pFromFpga)
{
	asynStatus status = asynSuccess;
	assert(pFromFpga->addr&flagReadMask); // This function is only for read registers
#for $p in sorted($registers, key=lambda k: k['name'])
#if (($p.has_key('access') and $p.access != "w") or (not $p.has_key('access'))) and ($p.has_key("signed") and $p.signed == "signed") and  ($p.has_key("bit_width") or $p.has_key("data_width"))
	int32_t signExtBits = 0;
	#break
#end if
#end for
#for $p in sorted($registers, key=lambda k: k['name'])
#if ((($p.has_key('access') and $p.access != "w") or (not $p.has_key('access'))) and ($p.has_key('nelm') and $p.nelm > 1))
	unsigned int index;
	#break
#end if
#end for

	/* Map address to parameter, set the parameter in the parameter library. */
	switch (pFromFpga->addr)
	{
#set $prevAdr=-1
#for $p in sorted($registers, key=lambda k: k['address'])
#if (($p.has_key('access') and $p.access != "w") or (not $p.has_key('access'))) and not ($p.has_key('nelm') and $p.nelm > 1)
#unless ($prevAdr == $p.address)
	break;

	case ${p.name.title().replace("_", "")}RAdr|flagReadMask:
#else
	// shared address with ${p.name.title().replace("_", "")}RAdr  $prevAdr == $p.address
#end unless
#set $prevAdr = $p.address

#if ($p.has_key('bits'))
	#set $paramType = 'UIntDigital'
	#set $maskParam =  ", " + $p.name.title().replace("_", "") + "Mask"
#else
	#set $paramType = 'Integer'
	#set $maskParam = ''
#end if
#if $p.has_key("bit_width") or $p.has_key("data_width")
	#if $p.has_key("signed") and $p.signed == "signed"
		signExtBits = (pFromFpga->data & ((${p.name.title().replace("_", "")}Mask + 1 ) >> 1))? ~${p.name.title().replace("_", "")}Mask : 0;
		status = (asynStatus) set${paramType}Param(p_${p.name.title().replace("_", "")}R,
				(pFromFpga->data & ${p.name.title().replace("_", "")}Mask) | signExtBits $maskParam);
	#else
		status = (asynStatus) set${paramType}Param(p_${p.name.title().replace("_", "")}R,
				(pFromFpga->data & ${p.name.title().replace("_", "")}Mask) $maskParam);
	#end if
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s %s: readback for address=%s, value=0x%x\n", portName, __PRETTY_FUNCTION__,
				${p.name.title().replace("_", "")}RString,
				(unsigned int) (pFromFpga->data & ${p.name.title().replace("_", "")}Mask));
#else
		status = (asynStatus) set${paramType}Param(p_${p.name.title().replace("_", "")}R,
				pFromFpga->data $maskParam);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s %s: readback for address=%s, value=0x%x\n", portName, __PRETTY_FUNCTION__,
				${p.name.title().replace("_", "")}RString, (unsigned ) pFromFpga->data);
#end if
#else if $p.has_key('access') and ( $p.access == "w" ) and (($p.has_key('nelm') and $p.nelm == 1) or not($p.has_key('nelm')))
	break;

	case ${p.name.title().replace("_", "")}WAdr|flagReadMask:
	// Ignore read from write-only address ${p.name.title().replace("_", "")}WAdr
#set $prevAdr = $p.address
#end if
#end for
		break;

	default:
		// Arrays larger than 32 elements should be handled in a subclass, generally more complicated
#for $p in sorted($registers, key=lambda k: k['address'])
#if (($p.has_key('access') and $p.access != "w") or (not $p.has_key('access'))) and $p.has_key('nelm') and $p.nelm > 1 and $p.nelm <= 32
		if ((pFromFpga->addr >= (${p.name.title().replace("_", "")}RAdr|flagReadMask)) &&
				(pFromFpga->addr < ((${p.name.title().replace("_", "")}RAdr|flagReadMask) + ${p.name.title().replace("_", "")}Buf.RegCount)))
		{
			index = (pFromFpga->addr - (${p.name.title().replace("_", "")}RAdr|flagReadMask));
	#if $p.has_key("bit_width") or $p.has_key("data_width")
	#if $p.has_key("signed") and $p.signed == "signed"
			signExtBits = (pFromFpga->data & ((${p.name.title().replace("_", "")}Mask + 1 ) >> 1))? ~${p.name.title().replace("_", "")}Mask : 0;
			status = (asynStatus) setIntegerParam(index,
				p_${p.name.title().replace("_", "")}R,
				(pFromFpga->data & ${p.name.title().replace("_", "")}Mask) | signExtBits);
			${p.name.title().replace("_", "")}Buf.data[index] = (pFromFpga->data & ${p.name.title().replace("_", "")}Mask) | signExtBits;
	#else
			status = (asynStatus) setIntegerParam(index,
				p_${p.name.title().replace("_", "")}R,
				(pFromFpga->data & ${p.name.title().replace("_", "")}Mask));
			${p.name.title().replace("_", "")}Buf.data[index] = (pFromFpga->data & ${p.name.title().replace("_", "")}Mask);
	#end if
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s %s: readback for address=%s, channel %u, value=0x%x\n", portName, __PRETTY_FUNCTION__,
				${p.name.title().replace("_", "")}RString,index,
				(unsigned int) (pFromFpga->data & ${p.name.title().replace("_", "")}Mask));
	#else
			status = (asynStatus) setIntegerParam(index,
				p_${p.name.title().replace("_", "")}R, pFromFpga->data);
			${p.name.title().replace("_", "")}Buf.data[index] = pFromFpga->data;
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s %s: readback for address=%s, channel %u, value=0x%x\n", portName, __PRETTY_FUNCTION__,
				${p.name.title().replace("_", "")}RString, index, (unsigned ) pFromFpga->data);
	#end if
			if (index > 0)
			{
				callParamCallbacks(index, index);
			}

			if(index == ${p.name.title().replace("_", "")}Buf.RegCount - 1)
			{
	#if ($p.has_key('bit_width') and ($p.bit_width <= 8)) or ($p.has_key('data_width') and ($p.data_width <= 8))
				doCallbacksInt8Array( ${p.name.title().replace("_", "")}Buf.data.data(), ${p.name.title().replace("_", "")}Buf.RegCount, p_${p.name.title().replace("_", "")}Wav, 0);
	#else if ($p.has_key('bit_width') and ($p.bit_width <= 16)) or ($p.has_key('data_width') and ($p.data_width <= 16))
				doCallbacksInt16Array( ${p.name.title().replace("_", "")}Buf.data.data(), ${p.name.title().replace("_", "")}Buf.RegCount, p_${p.name.title().replace("_", "")}Wav, 0);
	#else
				doCallbacksInt32Array( ${p.name.title().replace("_", "")}Buf.data.data(), ${p.name.title().replace("_", "")}Buf.RegCount, p_${p.name.title().replace("_", "")}Wav, 0);
	#end if
			}
		}
		else
#else if (($p.has_key('access') and $p.access != "w") or (not $p.has_key('access'))) and $p.has_key('nelm') and $p.nelm > 32
			if ((pFromFpga->addr >= (${p.name.title().replace("_", "")}RAdr|flagReadMask)) &&
					(pFromFpga->addr < ((${p.name.title().replace("_", "")}RAdr|flagReadMask) + ${p.name.title().replace("_", "")}Buf.RegCount)))
			{
				index = (pFromFpga->addr - (${p.name.title().replace("_", "")}RAdr|flagReadMask));
		#if $p.has_key("bit_width") or $p.has_key("data_width")
		#if $p.has_key("signed") and $p.signed == "signed"
				signExtBits = (pFromFpga->data & ((${p.name.title().replace("_", "")}Mask + 1 ) >> 1))? ~${p.name.title().replace("_", "")}Mask : 0;
				${p.name.title().replace("_", "")}Buf.data[index] = (pFromFpga->data & ${p.name.title().replace("_", "")}Mask) | signExtBits;
		#else
				${p.name.title().replace("_", "")}Buf.data[index] = (pFromFpga->data & ${p.name.title().replace("_", "")}Mask);
		#end if
				asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
					"%s %s: readback for address=%s, channel %u, value=0x%x\n", portName, __PRETTY_FUNCTION__,
					${p.name.title().replace("_", "")}RString,index,
					(unsigned int) (pFromFpga->data & ${p.name.title().replace("_", "")}Mask));
		#else
				${p.name.title().replace("_", "")}Buf.data[index] = pFromFpga->data;
				asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
					"%s %s: readback for address=%s, channel %u, value=0x%x\n", portName, __PRETTY_FUNCTION__,
					${p.name.title().replace("_", "")}RString, index, (unsigned ) pFromFpga->data);
		#end if
				if(index == ${p.name.title().replace("_", "")}Buf.RegCount - 1)
				{
		#if ($p.has_key('bit_width') and ($p.bit_width <= 8)) or ($p.has_key('data_width') and ($p.data_width <= 8))
					doCallbacksInt8Array( ${p.name.title().replace("_", "")}Buf.data.data(), ${p.name.title().replace("_", "")}Buf.RegCount, p_${p.name.title().replace("_", "")}Wav, 0);
		#else if ($p.has_key('bit_width') and ($p.bit_width <= 16)) or ($p.has_key('data_width') and ($p.data_width <= 16))
					doCallbacksInt16Array( ${p.name.title().replace("_", "")}Buf.data.data(), ${p.name.title().replace("_", "")}Buf.RegCount, p_${p.name.title().replace("_", "")}Wav, 0);
		#else
					doCallbacksInt32Array( ${p.name.title().replace("_", "")}Buf.data.data(), ${p.name.title().replace("_", "")}Buf.RegCount, p_${p.name.title().replace("_", "")}Wav, 0);
		#end if
				}
			}
			else
#end if
#end for
		{
			status = leepDrv::processRegReadback(pFromFpga);
		}

		break;
	}

	return status;
}


/**  Extract register address and data from the received message and set the appropriate
 * asyn parameter.
 * Some registers have a "new waveform data ready" flag. If they have this and it is set,
 * set weveIsReady to true.
* \param[in] pFromFpga Data returned from the FPGA for a single register
*/
asynStatus ${name}Drv::processRegWriteResponse(const FpgaReg *pFromFpga)
{
	asynStatus status = asynSuccess;
###for $p in sorted($registers, key=lambda k: k['name'])
##  #if $p.has_key('access') and ( "w" in $p.access ) and (not $p.has_key("bits"))
##	epicsInt32 valueSet; // Put the value sent to the FPGA here for comparison
##    #break
##  #end if
###end for
###for $p in sorted($registers, key=lambda k: k['name'])
##  #if $p.has_key('access') and ( "w" in $p.access ) and $p.has_key("bits")
##	epicsUInt32 uValueSet;
##    #break
##  #end if
###end for
#for $p in sorted($registers, key=lambda k: k['name'])
#if $p.has_key('access') and ( "w" in $p.access ) and $p.has_key('nelm') and ($p.nelm > 1)
	unsigned int index;
	#break
#end if
#end for

	/* Map address to parameter, set the parameter in the parameter library. */
	switch (pFromFpga->addr)
	{
#set $prevAdr=-1
#for $p in sorted($registers, key=lambda k: k['address'])
#if $p.has_key("bit_width") or $p.has_key("data_width")
	#set $maskStr = "& " + $p.name.title().replace("_", "") + "Mask"
#else
	#set $maskStr = ""
#end if
#if $p.has_key('access') and ( "w" in $p.access ) and (($p.has_key('nelm') and $p.nelm == 1) or not($p.has_key('nelm')))
	#unless ($prevAdr == $p.address)
	case ${p.name.title().replace("_", "")}WAdr:
	#else
	// shared address with ${p.name.title().replace("_", "")}WAdr
	#end unless
	#set $prevAdr = $p.address
	#if ($p.has_key('bits'))
	#set $paramType = 'UIntDigital'
	#set $maskParam = ", " + $p.name.title().replace("_", "") + "Mask"
	#set $retVal = 'uValueSet'
	#else
	#set $paramType = 'Integer'
	#set $maskParam = ''
	#set $retVal = 'valueSet'
	#end if
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
			"%s %s: echo for address=%s, value=0x%x\n", portName, __PRETTY_FUNCTION__,
			${p.name.title().replace("_", "")}WString, (unsigned int) (pFromFpga->data $maskStr));

		break;
#end if
#end for
	default:
		// Arrays larger than 32 elements should be handled in a subclass, generally more complicated
#for $p in sorted($registers, key=lambda k: k['address'])
#if $p.has_key('access') and ( "w" in $p.access ) and $p.has_key('nelm') and $p.nelm > 1
		if ((pFromFpga->addr >= ${p.name.title().replace("_", "")}WAdr) &&
				(pFromFpga->addr < (${p.name.title().replace("_", "")}WAdr + $p.nelm)))
		{
			index = pFromFpga->addr - ${p.name.title().replace("_", "")}WAdr;
			${p.name.title().replace("_", "")}Buf.data[index] = pFromFpga->data;
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s %s: echo for address=%s, channel %u, value=0x%x\n", portName, __PRETTY_FUNCTION__,
				${p.name.title().replace("_", "")}WString, (pFromFpga->addr - ${p.name.title().replace("_", "")}WAdr), (unsigned int) (pFromFpga->data $maskStr));

		}
		else
#end if
#end for
		{
			leepDrv::processRegWriteResponse(pFromFpga);
		}

		break;
	}

	// TODO: handle arrays

	return status;
}



extern "C" {

/* Configuration routine.  Called directly, or from the iocsh function below */

/** EPICS iocsh callable function to call constructor for the ${name}Drv class.
 * \param[in] portName The name of the asyn port driver to be created.
 * \param[in] netPortName The name of the asynIPport this will use to communicate */
int ${name}DrvConfigure(const char *drvPortName, const char *netPortName)
{
	//new ${name}Drv(drvPortName, netPortName);
	new ${name}Drv(drvPortName, netPortName, 8, 0);
	return asynSuccess;
}


/* EPICS iocsh shell commands */

static const iocshArg initArg0 = { "drvPortName",iocshArgString};
static const iocshArg initArg1 = { "IP port name",iocshArgString};
static const iocshArg * const initArgs[] = {&initArg0,
		&initArg1};
static const iocshFuncDef initFuncDef = {"${name}DrvConfigure",2,initArgs};
static void initCallFunc(const iocshArgBuf *args)
{
	${name}DrvConfigure(args[0].sval, args[1].sval);
}

void ${name}DrvRegister(void)
{
	iocshRegister(&initFuncDef,initCallFunc);
}

epicsExportRegistrar(${name}DrvRegister);

}



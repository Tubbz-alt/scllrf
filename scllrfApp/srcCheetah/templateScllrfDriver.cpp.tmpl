/**
 *-----------------------------------------------------------------------------
 * Title      : superconducting low level RF EPICS interface
 * ----------------------------------------------------------------------------
 * File       : ${name}Driver.h
 * Author     : Garth Brown, gwbrown@slac.stanford.edu
 * Created    : June 17, 2016
 * Last update: September 6, 2016
 * ----------------------------------------------------------------------------
 * Description:
 * Header defining register interface to ${name}, autogenerated from a python
 * dictionary.
 *
 * ----------------------------------------------------------------------------
 * This file is part of LCLS II. It is subject to
 * the license terms in the LICENSE.txt file found in the top-level directory
 * of this distribution and at:
    * https://confluence.slac.stanford.edu/display/ppareg/LICENSE.html.
 * No part of LCLS II, including this file, may be
 * copied, modified, propagated, or distributed except according to the terms
 * contained in the LICENSE.txt file.
 * ----------------------------------------------------------------------------
**/

\#include "${name}.h"
\#include <asynOctetSyncIO.h>
\#include <asynCommonSyncIO.h>
\#include <limits>
\#include <netinet/in.h>
\#include <iostream>
using namespace std;
\#include <math.h>

/* SHA1 hash of register map */
const char *${name}Driver::regMapSha1String = "${sha1}";
/* Register names */
#set $polledRegCount = 0
#set $writeRegCount = 0
#set $prevWAdrs = []
#set $prevRAdrs =[]
#for $p in sorted($registers, key=lambda k: k['name'])
  #if $p.has_key('desc')
// ${p.desc}
  #end if
  #if (not $p.has_key('access')) or ('r' in $p.access)
const char *${name}Driver::${p.name.title().replace("_", "")}RString = "${p.name.upper()}_R";
    #if $p.address not in $prevRAdrs
      #if ($p.has_key('nelm') and $p.nelm>32)
        ## exclude arrays with > 32 elements from polling
        #set $count_inc = 0 
const char *${name}Driver::${p.name.title().replace("_", "")}WavString = "${p.name.upper()}_WAV";
//const unsigned int ${p.name.title().replace("_", "")}BufRegCount = $p.nelm;
//const unsigned int ${p.name.title().replace("_", "")}ReqSegmentCount = (${p.name.title().replace("_", "")}BufRegCount + maxRegPerMsg -1)/maxRegPerMsg; // # of UDP requests, divide and round up;
//const unsigned int ${p.name.title().replace("_", "")}ReqMsgSize = ${p.name.title().replace("_", "")}BufRegCount + ${p.name.title().replace("_", "")}ReqSegmentCount; // All register addresses plus nonce space
      #else if bool(re.search(r'U\d|lspi', $p.name))
        ## exclude registers with side effectes from polling
        #set $count_inc = 0
      #else if $p.has_key('nelm') and $p.nelm<=32
        #set $count_inc = $p.nelm
      #else if not $p.has_key('nelm')
        #set $count_inc = 1
      #end if
      #set $polledRegCount += $count_inc
      #silent $prevRAdrs.append($p.address)
    #else
// shared address $p.address for $p.name
    #end if
  #end if
  #if $p.has_key('access') and ('w' in $p.access)
const char *${name}Driver::${p.name.title().replace("_", "")}WString = "${p.name.upper()}_W";
    #if $p.address not in $prevWAdrs
      #if $p.has_key('nelm') and $p.nelm<=32
        #set $count_inc = $p.nelm
      #else if $p.has_key('nelm') and $p.nelm>32
        #set $count_inc = 0
        ## WAV doesn't have R and W variations, skip if this was done in the R section above
        #if $p.address not in $prevRAdrs
const char *${name}Driver::${p.name.title().replace("_", "")}WavString = "${p.name.upper()}_WAV";
        #end if
      #else
        #set $count_inc = 1
      #end if
      #set $writeRegCount += $count_inc
      #silent $prevWAdrs.append($p.address)
    #end if
  #end if
#end for

const unsigned int ${name}Driver::${name}PolledRegCount = $polledRegCount;

/** Constructor for the ${name} class.
 * Calls constructor for the asynPortDriver base class.
 * \param[in] drvPortName The name of the asyn port driver to be created.
 * \param[in] netPortName The name of the asyn port driver to use for the network connection
 * \param[in] maxAddr The number of channels for the paramater with the most channels
 * \paarm[in] paramTableSize The number of asyn params to be created for each device
 *
 * */
//${name}Driver::${name}Driver(const char *drvPortName, const char *netPortName)
//: scllrfAsynPortDriver(drvPortName, netPortName,
//		8, /* maxAddr, i.e. number of channels */
//		NUM_${name.upper()}_PARAMS)
//{
//	// NUM_SCLLRFPRC_PARAMS is a macro using protected member variables,
//	// which the compiler has problems with..
//	${name}Driver(drvPortName, netPortName, 8, NUM_${name.upper()}_PARAMS);
//};

${name}Driver::${name}Driver(const char *drvPortName, const char *netPortName, int maxAddr, int paramTableAdds)
: scllrfAsynPortDriver(drvPortName, netPortName,
		maxAddr, /* maxAddr, i.e. number of channels */
		paramTableAdds + NUM_${name.upper()}_PARAMS)
{
    epicsThreadSleep(defaultPollPeriod);
#import re
#for $p in sorted($registers, key=lambda k: k['name'])
#if $p.has_key('nelm') and $p.nelm>32
  #if ($p.has_key('bit_width') and ($p.bit_width <= 8)) or ($p.has_key('data_width') and ($p.data_width <= 8))
    createParam(${p.name.title().replace("_", "")}WavString, asynParamInt8Array, &p_${p.name.title().replace("_", "")}Wav);
  #else if ($p.has_key('bit_width') and ($p.bit_width <= 16)) or ($p.has_key('data_width') and ($p.data_width <= 16))
    createParam(${p.name.title().replace("_", "")}WavString, asynParamInt16Array, &p_${p.name.title().replace("_", "")}Wav);
  #else
    createParam(${p.name.title().replace("_", "")}WavString, asynParamInt32Array, &p_${p.name.title().replace("_", "")}Wav);
  #end if
  #if (not $p.has_key('access')) or ('r' in $p.access)
    createParam(${p.name.title().replace("_", "")}RString, asynParamInt32, &p_${p.name.title().replace("_", "")}R);
  #end if
  #if $p.has_key('access') and ('w' in $p.access)
    #if $p.has_key('nelm') and $p.nelm>512
    createParam(${p.name.title().replace("_", "")}WString, asynParamInt32, &p_${p.name.title().replace("_", "")}W);
    #else
    createParam(${p.name.title().replace("_", "")}WString, asynParamInt32, &p_${p.name.title().replace("_", "")}W);
    #end if
  #end if
#else
  #if (not $p.has_key('access')) or ('r' in $p.access)
    #if ($p.has_key('bits'))
    createParam(${p.name.title().replace("_", "")}RString, asynParamUInt32Digital, &p_${p.name.title().replace("_", "")}R);
    #else
    createParam(${p.name.title().replace("_", "")}RString, asynParamInt32, &p_${p.name.title().replace("_", "")}R);
    #end if
  #end if
  #if $p.has_key('access') and ('w' in $p.access)
    #if ($p.has_key('bits'))
    createParam(${p.name.title().replace("_", "")}WString, asynParamUInt32Digital, &p_${p.name.title().replace("_", "")}W);
    #else
    createParam(${p.name.title().replace("_", "")}WString, asynParamInt32, &p_${p.name.title().replace("_", "")}W);
    #end if
  #end if
#end if
#end for

    // Message size is the number of read registers, plus 1 nonce for every 175 read registers
    PolledRegMsgSize_ = ${name}PolledRegCount + (${name}PolledRegCount / 175) + 1;
	// A canned request to read all registers
    pPolledRegMsg_ = new FpgaReg[PolledRegMsgSize_]
	{
#set $msgRegCount = 0
#set $prevAdr=-1
#for $p in sorted($registers, key=lambda k: k['address'])
  #if $p.has_key('nelm') and $p.nelm<=32
    #set $chan_count = $p.nelm
  #else
    #set $chan_count = 1
  #end if
  #unless ($p.has_key('access') and $p.access == 'w') or ($prevAdr == $p.address) or ($p.has_key('nelm') and $p.nelm>32) or bool(re.search(r'U\d|lspi', $p.name))
    #for $chan_num in range(0, $chan_count )
      #if msgRegCount % 174 == 0
		{ 0, 0 },
      #end if
        #if $chan_num == 0
		{ (flagReadMask | ${p.name.title().replace("_", "")}RAdr), blankData },
        #else
		{ (flagReadMask | ${p.name.title().replace("_", "")}RAdr) + $chan_num, blankData },
        #end if
      #set $prevAdr = $p.address
      #set $msgRegCount += 1
    #end for
  #end unless
#end for
	};

	htonFpgaRegArray(pPolledRegMsg_, PolledRegMsgSize_);

    epicsThreadSleep(defaultPollPeriod);
    printf("%s created %ld of %ld parameters.\n",__PRETTY_FUNCTION__,NUM_${name.upper()}_PARAMS, paramTableAdds+NUM_${name.upper()}_PARAMS);

    wakeupPoller();
    wakeupReader();
}

${name}Driver::~${name}Driver()
{
	isShuttingDown_ = true;
	epicsThreadSleep(0.1); // Allow threads to run and exit
	wakeupPoller();
	wakeupReader();
	epicsThreadSleep(0.1); // Allow threads to run and exit
	wakeupPoller(); // call this twice in case the poller was never set to run
	wakeupReader();
	epicsThreadSleep(0.1); // Allow threads to run and exit
	wakeupReader();
	pasynOctetSyncIO->disconnect(pOctetAsynUser_);
	pasynCommonSyncIO->disconnectDevice(pCommonAsynUser_);
	pasynCommonSyncIO->disconnect(pCommonAsynUser_);
}

/** Called when you have the asyn parameter name and want the corresponding
 * register address.
  * \param[in] function From pAsynUser->reason, corresponding to a registered parameter.
  * \param[in] pToFpga Pointer to the {Address, Data} structure where the register address will be written
  * \param[in] nElements Number of elements to read. */
asynStatus ${name}Driver::functionToRegister(const int function, FpgaReg *pToFpga)
{
	asynStatus status = asynSuccess;

#for $p in sorted($registers, key=lambda k: k['name'])
  #if (not $p.has_key('access')) or ('r' in $p.access)
    if( function == p_${p.name.title().replace("_", "")}R )
    {
		pToFpga->addr = ${p.name.title().replace("_", "")}RAdr|flagReadMask;
    }
    else
  #end if
  #if $p.has_key('access') and ('w' in $p.access)
    #if ( $p.has_key('nelm') and $p.nelm > 1 )
    if( (function == p_${p.name.title().replace("_", "")}W ) or (function == p_${p.name.title().replace("_", "")}Wav ))
    #else
        if( function == p_${p.name.title().replace("_", "")}W )
    #end if
    {
		pToFpga->addr = ${p.name.title().replace("_", "")}WAdr;
    }
    else
  #end if
#end for
    	status = asynError;

    return status;
}

/**  Extract register address and data from the received message and set the appropriate
 * asyn parameter.
 * Some registers have a "new waveform data ready" flag. If they have this and it is set,
 * set weveIsReady to true.
 * Note: This function should not set waveIsReady to false. That is done by a loop in the
 * calling function.
* \param[in] pFromFpga Data returned from the FPGA for a single register
* \param[in] waveIsReady A flag that gets set to true if the appropriate bit was set by the FPGA
*/
asynStatus ${name}Driver::processRegReadback(const FpgaReg *pFromFpga, bool &waveIsReady)
{
	asynStatus status = asynSuccess;
	assert(pFromFpga->addr&flagReadMask); // This function is only for read registers
	epicsInt32 errorCount;
	int32_t signExtBits = 0;
	int chan;

	/* Map address to parameter, set the parameter in the parameter library. */
	switch (pFromFpga->addr)
    {
#set $prevAdr=-1
#for $p in sorted($registers, key=lambda k: k['address'])
#if (($p.has_key('access') and $p.access != "w") or (not $p.has_key('access'))) and not ($p.has_key('nelm') and $p.nelm > 1)
  #unless ($prevAdr == $p.address)
	break;

    case ${p.name.title().replace("_", "")}RAdr|flagReadMask:
  #else
	// shared address with ${p.name.title().replace("_", "")}RAdr  $prevAdr == $p.address
  #end unless
  #set $prevAdr = $p.address

  #if ($p.has_key('bits'))
    #set $paramType = 'UIntDigital'
    #set $maskParam =  ", " + $p.name.title().replace("_", "") + "Mask"
  #else
    #set $paramType = 'Integer'
    #set $maskParam = ''
  #end if
  #if $p.has_key("bit_width") or $p.has_key("data_width")
    #if $p.has_key("signed") and $p.signed == "signed"
		signExtBits = (pFromFpga->data & ((${p.name.title().replace("_", "")}Mask + 1 ) >> 1))? ~${p.name.title().replace("_", "")}Mask : 0;
		status = (asynStatus) set${paramType}Param(p_${p.name.title().replace("_", "")}R,
				(pFromFpga->data & ${p.name.title().replace("_", "")}Mask) | signExtBits $maskParam);
    #else
		status = (asynStatus) set${paramType}Param(p_${p.name.title().replace("_", "")}R,
				(pFromFpga->data & ${p.name.title().replace("_", "")}Mask) $maskParam);
    #end if
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				${p.name.title().replace("_", "")}RString,
				(unsigned ) pFromFpga->data & ${p.name.title().replace("_", "")}Mask);
  #else
		status = (asynStatus) set${paramType}Param(p_${p.name.title().replace("_", "")}R,
				pFromFpga->data $maskParam);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				${p.name.title().replace("_", "")}RString, (unsigned ) pFromFpga->data);
  #end if
#end if
#end for
		break;

	default:
		// Arrays larger than 32 elements should be handled in a subclass, generally more complicated
#for $p in sorted($registers, key=lambda k: k['address'])
  #if (($p.has_key('access') and $p.access != "w") or (not $p.has_key('access'))) and $p.has_key('nelm') and $p.nelm > 1 and $p.nelm <= 32
		if ((pFromFpga->addr >= (${p.name.title().replace("_", "")}RAdr|flagReadMask)) &&
				(pFromFpga->addr < ((${p.name.title().replace("_", "")}RAdr|flagReadMask) + $p.nelm)))
		{
			chan = (pFromFpga->addr - (${p.name.title().replace("_", "")}RAdr|flagReadMask));
    #if $p.has_key("bit_width") or $p.has_key("data_width")
      #if $p.has_key("signed") and $p.signed == "signed"
			signExtBits = (pFromFpga->data & ((${p.name.title().replace("_", "")}Mask + 1 ) >> 1))? ~${p.name.title().replace("_", "")}Mask : 0;
			status = (asynStatus) setIntegerParam(chan,
				p_${p.name.title().replace("_", "")}R,
				(pFromFpga->data & ${p.name.title().replace("_", "")}Mask) | signExtBits);
      #else
			status = (asynStatus) setIntegerParam(chan,
				p_${p.name.title().replace("_", "")}R,
				(pFromFpga->data & ${p.name.title().replace("_", "")}Mask));
      #end if
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
				${p.name.title().replace("_", "")}RString,chan,
				(unsigned ) pFromFpga->data & ${p.name.title().replace("_", "")}Mask);
    #else
			status = (asynStatus) setIntegerParam(chan,
				p_${p.name.title().replace("_", "")}R, pFromFpga->data);
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
				${p.name.title().replace("_", "")}RString, chan, (unsigned ) pFromFpga->data);
    #end if
			callParamCallbacks(chan, chan);
		}
		else
  #end if
#end for
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value read from unmapped address 0x%X, value=0x%X\n", __PRETTY_FUNCTION__,
				pFromFpga->addr, (unsigned ) pFromFpga->data);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
			status = asynError;
		}

		break;
    }

    return status;
}


/**  Extract register address and data from the received message and set the appropriate
 * asyn parameter.
 * Some registers have a "new waveform data ready" flag. If they have this and it is set,
 * set weveIsReady to true.
 * Note: This function should not set waveIsReady to false. That is done by a loop in the
 * calling function.
* \param[in] pFromFpga Data returned from the FPGA for a single register
* \param[in] waveIsReady A flag that gets set to true if the appropriate bit was set by the FPGA
*/
asynStatus ${name}Driver::processRegWriteResponse(const FpgaReg *pFromFpga)
{
	asynStatus status = asynSuccess;
	epicsInt32 valueSet; // Put the value sent to the FPGA here for comparison
	epicsUInt32 uValueSet;
	epicsInt32 errorCount;
	unsigned int index;
//  variables that may be useful for checking array data
//	asynUser *pAsynArrayUser;
//	unsigned int i;

	/* Map address to parameter, set the parameter in the parameter library. */
	switch (pFromFpga->addr)
    {
#set $prevAdr=-1
#for $p in sorted($registers, key=lambda k: k['address'])
  #if $p.has_key("bit_width") or $p.has_key("data_width")
    #set $maskStr = "& " + $p.name.title().replace("_", "") + "Mask"
  #else
    #set $maskStr = ""
  #end if
  #if $p.has_key('access') and ( "w" in $p.access ) and (($p.has_key('nelm') and $p.nelm == 1) or not($p.has_key('nelm')))
    #unless ($prevAdr == $p.address)
    case ${p.name.title().replace("_", "")}WAdr:
    #else
	// shared address with ${p.name.title().replace("_", "")}WAdr
    #end unless
    #set $prevAdr = $p.address
    #if ($p.has_key('bits'))
      #set $paramType = 'UIntDigital'
      #set $maskParam = ", " + $p.name.title().replace("_", "") + "Mask"
      #set $retVal = 'uValueSet'
    #else
      #set $paramType = 'Integer'
      #set $maskParam = ''
      #set $retVal = 'valueSet'
    #end if
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
			"%s: echo for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
			${p.name.title().replace("_", "")}WString, (unsigned ) pFromFpga->data $maskStr);

		break;
  #end if
#end for
	default:
		// Arrays larger than 32 elements should be handled in a subclass, generally more complicated
#for $p in sorted($registers, key=lambda k: k['address'])
  #if $p.has_key('access') and ( "w" in $p.access ) and $p.has_key('nelm') and $p.nelm > 32
		if ((pFromFpga->addr >= ${p.name.title().replace("_", "")}WAdr) &&
				(pFromFpga->addr < (${p.name.title().replace("_", "")}WAdr + $p.nelm)))
		{
			index = pFromFpga->addr - ${p.name.title().replace("_", "")}WAdr;
			buf${p.name.title().replace("_", "")}[index] = pFromFpga->data;
#if ($p.has_key('bit_width') and ($p.bit_width <= 8)) or ($p.has_key('data_width') and ($p.data_width <= 8))
			doCallbacksInt8Array(buf${p.name.title().replace("_", "")}, $p.nelm, p_${p.name.title().replace("_", "")}Wav, 0);
#else if ($p.has_key('bit_width') and ($p.bit_width <= 16)) or ($p.has_key('data_width') and ($p.data_width <= 16))
			doCallbacksInt16Array(buf${p.name.title().replace("_", "")}, $p.nelm, p_${p.name.title().replace("_", "")}Wav, 0);
#else
			doCallbacksInt32Array(buf${p.name.title().replace("_", "")}, $p.nelm, p_${p.name.title().replace("_", "")}Wav, 0);
#end if
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: echo for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
				${p.name.title().replace("_", "")}WString, (pFromFpga->addr - ${p.name.title().replace("_", "")}WAdr), (unsigned ) pFromFpga->data $maskStr);

		}
		else
  #end if
#end for
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: write response from FPGA for unmapped address 0x%X, value=0x%X\n", __PRETTY_FUNCTION__,
				pFromFpga->addr, (unsigned ) pFromFpga->data);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
			status = asynError;
		}

		break;
    }

	// TODO: handle arrays

    return status;
}



extern "C" {

/* Configuration routine.  Called directly, or from the iocsh function below */

/** EPICS iocsh callable function to call constructor for the ${name} class.
 * \param[in] portName The name of the asyn port driver to be created.
 * \param[in] netPortName The name of the asynIPport this will use to communicate */
int ${name}Configure(const char *drvPortName, const char *netPortName)
{
	//new ${name}Driver(drvPortName, netPortName);
	new ${name}Driver(drvPortName, netPortName, 8, 0);
	return asynSuccess;
}


/* EPICS iocsh shell commands */

static const iocshArg initArg0 = { "drvPortName",iocshArgString};
static const iocshArg initArg1 = { "IP port name",iocshArgString};
static const iocshArg * const initArgs[] = {&initArg0,
		&initArg1};
static const iocshFuncDef initFuncDef = {"${name}Configure",2,initArgs};
static void initCallFunc(const iocshArgBuf *args)
{
	${name}Configure(args[0].sval, args[1].sval);
}

void ${name}Register(void)
{
	iocshRegister(&initFuncDef,initCallFunc);
}

epicsExportRegistrar(${name}Register);

}



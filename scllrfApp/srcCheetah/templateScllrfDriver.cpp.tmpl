/**
 *-----------------------------------------------------------------------------
 * Title      : superconducting low level RF EPICS interface
 * ----------------------------------------------------------------------------
 * File       : templateScllrfDriver.h
 * Author     : Garth Brown, gwbrown@slac.stanford.edu
 * Created    : June 17, 2016
 * Last update: September 6, 2016
 * ----------------------------------------------------------------------------
 * Description:
 * Header defining register interface to ${name}, autogenerated from a python
 * dictionary.
 *
 * ----------------------------------------------------------------------------
 * This file is part of LCLS II. It is subject to
 * the license terms in the LICENSE.txt file found in the top-level directory
 * of this distribution and at:
    * https://confluence.slac.stanford.edu/display/ppareg/LICENSE.html.
 * No part of LCLS II, including this file, may be
 * copied, modified, propagated, or distributed except according to the terms
 * contained in the LICENSE.txt file.
 * ----------------------------------------------------------------------------
**/

\#include "${name}.h"
\#include <asynOctetSyncIO.h>
\#include <asynCommonSyncIO.h>
\#include <limits>
\#include <netinet/in.h>
\#include <iostream>
using namespace std;
\#include <math.h>

/** Constructor for the ${name} class.
 * Calls constructor for the asynPortDriver base class.
 * \param[in] portName The name of the asyn port driver to be created.
 * \param[in] path The path to the peripherial as built by the builder api
 * \param[in] nelms The number of elements of this device (max addr)
 * \paarm[in] nEntries The number of asyn params to be created for each device
 *
 * */
${name}Driver::${name}Driver(const char *drvPortName, const char *netPortName)
: scllrfAsynPortDriver(drvPortName, netPortName,
		1, /* maxAddr, i.e. number of channels */
		NUM_${name.upper()}_PARAMS)
{
	asynStatus status = asynSuccess;

    epicsThreadSleep(defaultPollPeriod);

#for $p in sorted($registers, key=lambda k: k['name'])
#if $p.has_key('nelms')
    createParam(${p.name.title().replace("_", "")}String, asynParamInt32Array, &p_${p.name.title().replace("_", "")});
#else
  #if (not $p.has_key('access')) or ('r' in $p.access)
    createParam(${p.name.title().replace("_", "")}RString, asynParamInt32, &p_${p.name.title().replace("_", "")}R);
    #if $p.has_key("bits")
      #for $field in sorted($p.bits, key=lambda k: k.__getitem__)
	createParam(${p.name.title().replace("_", "")}${field.title().replace("_", "")}RString, asynParamUInt32Digital, &p_${p.name.title().replace("_", "")}${field.title().replace("_", "")}R);
      #end for
    #end if
  #end if
  #if $p.has_key('access') and ('w' in $p.access)
    createParam(${p.name.title().replace("_", "")}WString, asynParamInt32, &p_${p.name.title().replace("_", "")}W);
    #if $p.has_key("bits")
      #for $field in sorted($p.bits, key=lambda k: k.__getitem__)
    createParam(${p.name.title().replace("_", "")}${field.title().replace("_", "")}WString, asynParamUInt32Digital, &p_${p.name.title().replace("_", "")}${field.title().replace("_", "")}W);
      #end for
    #end if
  #end if
#end if
#end for

	// A canned request to read all registers
    pPolledRegMsg_ = new FpgaReg[readRegCount + 1]
	{
			{ 0, 0 },
#set $prevAdr=-1
#for $p in sorted($registers, key=lambda k: k['address'])
#unless ($p.has_key('access') and $p.access == 'w') or ($prevAdr == $p.address)
			{ flagReadMask | ${p.name.title().replace("_", "")}RAdr, blankData },
#end unless
#set $prevAdr = $p.address
#end for
	};

	htonFpgaRegArray(pPolledRegMsg_, readRegCount + 1);
    PolledRegMsgSize_ = readRegCount + 1;

    epicsThreadSleep(defaultPollPeriod);
    printf("%s created %ld parameters.\n",__PRETTY_FUNCTION__,NUM_${name.upper()}_PARAMS);

    wakeupPoller();
    wakeupReader();
}

${name}Driver::~${name}Driver()
{
	isShuttingDown_ = true;
	epicsThreadSleep(0.1); // Allow threads to run and exit
	wakeupPoller();
	wakeupReader();
	epicsThreadSleep(0.1); // Allow threads to run and exit
	wakeupPoller(); // call this twice in case the poller was never set to run
	wakeupReader();
	epicsThreadSleep(0.1); // Allow threads to run and exit
	wakeupReader();
	pasynOctetSyncIO->disconnect(pOctetAsynUser_);
	pasynCommonSyncIO->disconnectDevice(pCommonAsynUser_);
	pasynCommonSyncIO->disconnect(pCommonAsynUser_);
}

/** Called when you have the asyn parameter name and want the corresponding
 * register address.
  * \param[in] function From pAsynUser->reason, corresponding to a registered parameter.
  * \param[in] pToFpga Pointer to the {Address, Data} structure where the register address will be written
  * \param[in] nElements Number of elements to read. */
asynStatus ${name}Driver::functionToRegister(const int function, FpgaReg *pToFpga)
{
	asynStatus status = asynSuccess;

#for $p in sorted($registers, key=lambda k: k['name'])
  #if (not $p.has_key('access')) or ('r' in $p.access)
    if( function == p_${p.name.title().replace("_", "")}R )
    {
		pToFpga->addr = ${p.name.title().replace("_", "")}RAdr|flagReadMask;
    }
    else
  #end if
  #if $p.has_key('access') and ('w' in $p.access)
    if( function == p_${p.name.title().replace("_", "")}W )
    {
		pToFpga->addr = ${p.name.title().replace("_", "")}WAdr;
    }
    else
  #end if
#end for
    	status = asynError;

    return status;
}

/**  Extract register address and data from the received message and set the appropriate
 * asyn parameter.
 * Some registers have a "new waveform data ready" flag. If they have this and it is set,
 * set weveIsReady to true.
 * Note: This function should not set waveIsReady to false. That is done by a loop in the
 * calling function.
* \param[in] pFromFpga Data returned from the FPGA for a single register
* \param[in] waveIsReady A flag that gets set to true if the appropriate bit was set by the FPGA
*/
asynStatus ${name}Driver::processRegReadback(const FpgaReg *pFromFpga, bool &waveIsReady)
{
	unsigned int i;
	asynStatus status = asynSuccess;
	assert(pFromFpga->addr&flagReadMask); // This function is only for read registers
	epicsInt32 errorCount;
	int32_t signExtBits = 0;

	/* Map address to parameter, set the parameter in the parameter library. */
	switch (pFromFpga->addr)
    {
#set $prevAdr=-1
#for $p in sorted($registers, key=lambda k: k['address'])
#if ($p.has_key('access') and $p.access != "w") or (not $p.has_key('access'))
  #unless ($prevAdr == $p.address)
    case ${p.name.title().replace("_", "")}RAdr|flagReadMask:
  #else
	// shared address with ${p.name.title().replace("_", "")}RAdr
  #end unless
  #if $p.has_key("bit_width")
    #if $p.has_key("signed") and $p.signed == "signed"
		signExtBits = pFromFpga->data & ((${p.name.title().replace("_", "")}Mask + 1 ) >> 1)? ~${p.name.title().replace("_", "")}Mask : 0;
	#end if
		status = (asynStatus) setIntegerParam(p_${p.name.title().replace("_", "")}R,
				(pFromFpga->data & ${p.name.title().replace("_", "")}Mask) | signExtBits);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				${p.name.title().replace("_", "")}RString,
				(unsigned ) pFromFpga->data & ${p.name.title().replace("_", "")}Mask);
  #else
		status = (asynStatus) setIntegerParam(p_${p.name.title().replace("_", "")}R,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				${p.name.title().replace("_", "")}RString, (unsigned ) pFromFpga->data);
  #end if
#if $p.has_key("bits")
  #for $field in sorted($p.bits, key=lambda k: k.__getitem__)

		status = (asynStatus) setUIntDigitalParam(p_${p.name.title().replace("_", "")}${field.title().replace("_", "")}R,
				pFromFpga->data, ${p.name.title().replace("_", "")}${field.title().replace("_", "")}Mask);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				${p.name.title().replace("_", "")}${field.title().replace("_", "")}RString,
				(unsigned ) pFromFpga->data & ${p.name.title().replace("_", "")}${field.title().replace("_", "")}Mask);
  #end for
#end if
	break;

#end if
#set $prevAdr = $p.address
#end for
	default:
		getIntegerParam(p_CommErrorCount, &errorCount);
		setIntegerParam(p_CommErrorCount, ++errorCount);

		status = asynError;
		break;
    }

    return status;
}


/**  Extract register address and data from the received message and set the appropriate
 * asyn parameter.
 * Some registers have a "new waveform data ready" flag. If they have this and it is set,
 * set weveIsReady to true.
 * Note: This function should not set waveIsReady to false. That is done by a loop in the
 * calling function.
* \param[in] pFromFpga Data returned from the FPGA for a single register
* \param[in] waveIsReady A flag that gets set to true if the appropriate bit was set by the FPGA
*/
asynStatus ${name}Driver::processRegWriteResponse(const FpgaReg *pFromFpga)
{
	asynStatus status = asynSuccess;
	epicsInt32 valueSet[maxMsgSize/sizeof(FpgaReg)]; // Put the value sent to the FPGA here for comparison
	epicsInt32 errorCount;
//  variables that may be useful for checking array data
//	asynUser *pAsynArrayUser;
//	unsigned int i;

	/* Map address to parameter, set the parameter in the parameter library. */
	switch (pFromFpga->addr)
    {
#set $prevAdr=-1
#for $p in sorted($registers, key=lambda k: k['address'])
  #if $p.has_key("bit_width")
  #set $maskStr = "& " + $p.name.title().replace("_", "") + "Mask"
  #else
  #set $maskStr = ""
  #end if
  #if $p.has_key('access')
    #if ( "w" in $p.access ) and (($p.has_key('nelms') and $p.nelms == 1) or not($p.has_key('nelms')))
      #unless ($prevAdr == $p.address)
    case ${p.name.title().replace("_", "")}WAdr:
      #else
	// shared address with ${p.name.title().replace("_", "")}WAdr
      #end unless
		status = (asynStatus) getIntegerParam(p_${p.name.title().replace("_", "")}W, valueSet);
		if( (valueSet[0] $maskStr) == (pFromFpga->data $maskStr))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				${p.name.title().replace("_", "")}WString, (unsigned ) pFromFpga->data $maskStr);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				${p.name.title().replace("_", "")}WString, valueSet[0] $maskStr, (unsigned ) pFromFpga->data $maskStr);
			status = asynError;
			setParamStatus(p_${p.name.title().replace("_", "")}W, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    #end if
  #end if
  #set $prevAdr = $p.address
#end for
	default:
		getIntegerParam(p_CommErrorCount, &errorCount);
		setIntegerParam(p_CommErrorCount, ++errorCount);

		status = asynError;
		break;
    }

	// TODO: handle arrays

    return status;
}



extern "C" {

/* Configuration routine.  Called directly, or from the iocsh function below */

/** EPICS iocsh callable function to call constructor for the ${name} class.
 * \param[in] portName The name of the asyn port driver to be created.
 * \param[in] netPortName The name of the asynIPport this will use to communicate */
int ${name}Configure(const char *drvPortName, const char *netPortName)
{
	new ${name}Driver(drvPortName, netPortName);
	return asynSuccess;
}


/* EPICS iocsh shell commands */

static const iocshArg initArg0 = { "drvPortName",iocshArgString};
static const iocshArg initArg1 = { "IP port name",iocshArgString};
static const iocshArg * const initArgs[] = {&initArg0,
		&initArg1};
static const iocshFuncDef initFuncDef = {"${name}Configure",2,initArgs};
static void initCallFunc(const iocshArgBuf *args)
{
	${name}Configure(args[0].sval, args[1].sval);
}

void ${name}Register(void)
{
	iocshRegister(&initFuncDef,initCallFunc);
}

epicsExportRegistrar(${name}Register);

}



\#ifndef ${name.upper()}_DRIVER_H
\#define ${name.upper()}_DRIVER_H

/**
 *-----------------------------------------------------------------------------
 * Title      : superconducting low level RF EPICS interface
 * ----------------------------------------------------------------------------
 * File       : templateScllrfDriver.h
 * Author     : Garth Brown, gwbrown@slac.stanford.edu
 * Created    : June 17, 2016
 * Last update: September 6, 2016
 * ----------------------------------------------------------------------------
 * Description:
 * Header defining register interface to ${name}, autogenerated from a python
 * dictionary.
 *
 * ----------------------------------------------------------------------------
 * This file is part of LCLS II. It is subject to
 * the license terms in the LICENSE.txt file found in the top-level directory
 * of this distribution and at:
    * https://confluence.slac.stanford.edu/display/ppareg/LICENSE.html.
 * No part of LCLS II, including this file, may be
 * copied, modified, propagated, or distributed except according to the terms
 * contained in the LICENSE.txt file.
 * ----------------------------------------------------------------------------
**/
\#include <stdlib.h>
\#include <string.h>
\#include <stdio.h>
\#include <stdint.h>
\#include <sys/types.h>
\#include <sys/stat.h>
\#include <iostream>
\#include <vector>

\#include <epicsTypes.h>
\#include <epicsThread.h>
\#include <epicsEvent.h>
\#include <iocsh.h>

\#include <asynPortDriver.h>

\#include <epicsExport.h>

/* Registers */
#set $readRegCount = 0
#set $writeRegCount = 0
#for $p in sorted($registers, key=lambda k: k['name'])
#if $p.has_key('desc')
// ${p.desc}
#end if
const char *${p.name.title().replace("_", "")}String = "${p.name.upper()}";
#if $p.has_key('access') and $p.access == 'w'
#set $writeRegCount +=1
#else
#set $readRegCount +=1
#end if
#end for

const unsigned int readRegCount = $readRegCount;
const unsigned int writeRegCount = $writeRegCount;

/* Commands */
#if $varExists('commands')
#for $c in $commands
#define C${c.name}String "C_${c.name}"
#end for
#end if


 /* This class implements the AxiVersion driver. */
class ${name}Driver : public scllrfAsynPortDriver {
public:
    ${name}Driver(const char *portName, Path p, int nelms);

#if $varExists('commands')
    virtual asynStatus writeInt32(asynUser *pasynUser, epicsInt32 value);
#end if


protected:
    ${name} p${name};

#set $first = True
/* Registers */
#for $p in sorted($registers, key=lambda k: k['name'])
    int p_${p.name.title().replace("_", "")};
    #if $first == True
    #define FIRST_${name.upper()}_PARAM p_${p.name.title().replace("_", "")}
    #set $first = False
    #end if
#end for
#if $varExists('commands')
/* Commands */
#for $c in $commands
    int p_C_${c.name.title().replace("_", "")};
#end for
    \#define LAST_${name.upper()}_PARAM p_C_${commands[-1].name.title().replace("_", "")}
#else
  #set $sortedRegisters = sorted($registers, key=lambda k: k['name'])
    \#define LAST_${name.upper()}_PARAM p_${$sortedRegisters[-1].name.title().replace("_", "")}
#end if


\#define NUM_${name.upper()}_PARAMS (&LAST_${name.upper()}_PARAM - &FIRST_${name.upper()}_PARAM + 1)

private:
#if $varExists('commands')
#for $c in $commands
    asynStatus ${c.name}();
#end for
#end if

    // mapping of register names to addresses
    enum ReadRegAddrs
    {
#for $p in sorted($registers, key=lambda k: k['address'])
#unless $p.has_key('access') and $p.access == 'w'
    	${p.name.title().replace("_", "")}Adr = 0x${format($p.address, '08X')},
#end unless
#end for
    };

    // mapping of register names to addresses
    enum RegWriteAddrs
    {
#for $p in sorted($registers, key=lambda k: k['address'])
#if $p.has_key('access') and $p.access == 'w'
    	${p.name.title().replace("_", "")}Adr = 0x${format($p.address, '08X')},
#end if
#end for
    };

    // masks applied to returned register data
    enum RegMasks
    {
#for $p in sorted($registers, key=lambda k: k['address'])
#unless $p.has_key('access') and $p.access == 'w'
#if $p.has_key('bit_width')
    	${p.name.title().replace("_", "")}Mask =  0x${format(2**$p.bit_width - 1, '08X')},
#end if
#end unless
#end for

#for $p in sorted($registers, key=lambda k: k['address'])
#if $p.has_key('access') and $p.access == 'w'
#if $p.has_key('bit_width')
    	${p.name.title().replace("_", "")}Mask =  0x${format(2**$p.bit_width - 1, '08X')},
#end if
#end if
#end for
    };
};

\#endif

/**
 *-----------------------------------------------------------------------------
 * Title      : superconducting low level RF EPICS interface
 * ----------------------------------------------------------------------------
 * File       : scllrfAsynPortDriver.cpp
 * Author     : Garth Brown, gwbrown@slac.stanford.edu
 * Created    : June 17, 2016
 * Last update: September 6, 2016
 * ----------------------------------------------------------------------------
 * Description:
 * Prototype for FPGA register access to FPGAs using protocol defined in papers
 * given to SLAC by LBNL (Larry Doolittle). Uses asynPortDriver interface. Some of this
 * should eventually be autogenerated from json files or some such, and templates.
 *
 * ----------------------------------------------------------------------------
 * This file is part of LCLS II. It is subject to
 * the license terms in the LICENSE.txt file found in the top-level directory
 * of this distribution and at:
    * https://confluence.slac.stanford.edu/display/ppareg/LICENSE.html.
 * No part of LCLS II, including this file, may be
 * copied, modified, propagated, or distributed except according to the terms
 * contained in the LICENSE.txt file.
 * ----------------------------------------------------------------------------
**/

#include "scllrfPRC.h"
#include <asynOctetSyncIO.h>
#include <asynCommonSyncIO.h>
#include <limits>
#include <netinet/in.h>
#include <iostream>
using namespace std;
#include <math.h>

/** Constructor for the scllrfPRC class.
 * Calls constructor for the asynPortDriver base class.
 * \param[in] portName The name of the asyn port driver to be created.
 * \param[in] path The path to the peripherial as built by the builder api
 * \param[in] nelms The number of elements of this device (max addr)
 * \paarm[in] nEntries The number of asyn params to be created for each device
 *
 * */
scllrfPRC::scllrfPRC(const char *drvPortName, const char *netPortName)
: scllrfAsynPortDriver(drvPortName, netPortName,
		maxWavesCount, /* maxAddr, i.e. number of channels */
		NUM_SCLLRFPRC_PARAMS)
{
	unsigned int i;

    epicsThreadSleep(defaultPollPeriod);

    createParam(HellRString, asynParamInt32, &p_HellR);
    createParam(U15SdioAsSdoRString, asynParamInt32, &p_U15SdioAsSdoR);
    createParam(U15SdoAddrRString, asynParamInt32, &p_U15SdoAddrR);
    createParam(U15SpiReadyRString, asynParamInt32, &p_U15SpiReadyR);
    createParam(U18SdioAsSdoRString, asynParamInt32, &p_U18SdioAsSdoR);
    createParam(U18SdoAddrRString, asynParamInt32, &p_U18SdoAddrR);
    createParam(U18SpiReadyRString, asynParamInt32, &p_U18SpiReadyR);
    createParam(U2Doutbits31To0RString, asynParamInt32, &p_U2Doutbits31To0R);
    createParam(U2Doutbits63To32RString, asynParamInt32, &p_U2Doutbits63To32R);
    createParam(U3Doutbits31To0RString, asynParamInt32, &p_U3Doutbits31To0R);
    createParam(U3Doutbits63To32RString, asynParamInt32, &p_U3Doutbits63To32R);
    createParam(U15SpiRdbkRString, asynParamInt32, &p_U15SpiRdbkR);
    createParam(U18SpiRdbkRString, asynParamInt32, &p_U18SpiRdbkR);
    createParam(AdcMmcmRString, asynParamInt32, &p_AdcMmcmR);
    createParam(AdcMmcmWString, asynParamInt32, &p_AdcMmcmW);
    createParam(AdcTestTrigCntRString, asynParamInt32, &p_AdcTestTrigCntR);
    createParam(AdcTestWave1OutRString, asynParamInt32, &p_AdcTestWave1OutR);
    createParam(AdcTestWave2OutRString, asynParamInt32, &p_AdcTestWave2OutR);
    createParam(AdcTestWave3OutRString, asynParamInt32, &p_AdcTestWave3OutR);
    createParam(AdcTestWave4OutRString, asynParamInt32, &p_AdcTestWave4OutR);
    createParam(BanyanBufRString, asynParamInt32, &p_BanyanBufR);
    createParam(BanyanStatusRString, asynParamInt32, &p_BanyanStatusR);
    createParam(ClkPhaseDiffOutU2RString, asynParamInt32, &p_ClkPhaseDiffOutU2R);
    createParam(ClkPhaseDiffOutU3RString, asynParamInt32, &p_ClkPhaseDiffOutU3R);
    createParam(CtraceRunningRString, asynParamInt32, &p_CtraceRunningR);
    createParam(DigCfgU15SpiDataAddrRRString, asynParamInt32, &p_DigCfgU15SpiDataAddrRR);
    createParam(DigCfgU15SpiDataAddrRWString, asynParamInt32, &p_DigCfgU15SpiDataAddrRW);
    createParam(DigCfgU15SpiReadAndStartRRString, asynParamInt32, &p_DigCfgU15SpiReadAndStartRR);
    createParam(DigCfgU15SpiReadAndStartRWString, asynParamInt32, &p_DigCfgU15SpiReadAndStartRW);
    createParam(DigCfgU18SpiDataAddrRRString, asynParamInt32, &p_DigCfgU18SpiDataAddrRR);
    createParam(DigCfgU18SpiDataAddrRWString, asynParamInt32, &p_DigCfgU18SpiDataAddrRW);
    createParam(DigCfgU18SpiReadAndStartRRString, asynParamInt32, &p_DigCfgU18SpiReadAndStartRR);
    createParam(DigCfgU18SpiReadAndStartRWString, asynParamInt32, &p_DigCfgU18SpiReadAndStartRW);
    createParam(DigCfgU2ClkResetRRString, asynParamInt32, &p_DigCfgU2ClkResetRR);
    createParam(DigCfgU2ClkResetRWString, asynParamInt32, &p_DigCfgU2ClkResetRW);
    createParam(DigCfgU2IserdesResetRRString, asynParamInt32, &p_DigCfgU2IserdesResetRR);
    createParam(DigCfgU2IserdesResetRWString, asynParamInt32, &p_DigCfgU2IserdesResetRW);
    createParam(DigCfgU3ClkResetRRString, asynParamInt32, &p_DigCfgU3ClkResetRR);
    createParam(DigCfgU3ClkResetRWString, asynParamInt32, &p_DigCfgU3ClkResetRW);
    createParam(DigCfgU3IserdesResetRRString, asynParamInt32, &p_DigCfgU3IserdesResetRR);
    createParam(DigCfgU3IserdesResetRWString, asynParamInt32, &p_DigCfgU3IserdesResetRW);
    createParam(DigCfgU4ResetRRString, asynParamInt32, &p_DigCfgU4ResetRR);
    createParam(DigCfgU4ResetRWString, asynParamInt32, &p_DigCfgU4ResetRW);
    createParam(DigCfgBanyanMaskRString, asynParamInt32, &p_DigCfgBanyanMaskR);
    createParam(DigCfgBanyanMaskWString, asynParamInt32, &p_DigCfgBanyanMaskW);
    createParam(DigCfgBitslipRString, asynParamInt32, &p_DigCfgBitslipR);
    createParam(DigCfgBitslipWString, asynParamInt32, &p_DigCfgBitslipW);
    createParam(DigCfgIdelayctrlResetRRString, asynParamInt32, &p_DigCfgIdelayctrlResetRR);
    createParam(DigCfgIdelayctrlResetRWString, asynParamInt32, &p_DigCfgIdelayctrlResetRW);
    createParam(DigCfgLlspiWeRString, asynParamInt32, &p_DigCfgLlspiWeR);
    createParam(DigCfgLlspiWeWString, asynParamInt32, &p_DigCfgLlspiWeW);
    createParam(DigCfgMmcmResetRRString, asynParamInt32, &p_DigCfgMmcmResetRR);
    createParam(DigCfgMmcmResetRWString, asynParamInt32, &p_DigCfgMmcmResetRW);
    createParam(DigCfgPeriphConfigRString, asynParamInt32, &p_DigCfgPeriphConfigR);
    createParam(DigCfgPeriphConfigWString, asynParamInt32, &p_DigCfgPeriphConfigW);
    createParam(DigCfgPhasexTrigRString, asynParamInt32, &p_DigCfgPhasexTrigR);
    createParam(DigCfgPhasexTrigWString, asynParamInt32, &p_DigCfgPhasexTrigW);
    createParam(DigCfgRawadcTrigRString, asynParamInt32, &p_DigCfgRawadcTrigR);
    createParam(DigCfgRawadcTrigWString, asynParamInt32, &p_DigCfgRawadcTrigW);
    createParam(DigCfgScanTriggerWeRString, asynParamInt32, &p_DigCfgScanTriggerWeR);
    createParam(DigCfgScanTriggerWeWString, asynParamInt32, &p_DigCfgScanTriggerWeW);
    createParam(DigCfgScannerDebugRString, asynParamInt32, &p_DigCfgScannerDebugR);
    createParam(DigCfgScannerDebugWString, asynParamInt32, &p_DigCfgScannerDebugW);
    createParam(DigCfgSyncAd7794CsetRString, asynParamInt32, &p_DigCfgSyncAd7794CsetR);
    createParam(DigCfgSyncAd7794CsetWString, asynParamInt32, &p_DigCfgSyncAd7794CsetW);
    createParam(DigCfgSyncTps62210CsetRString, asynParamInt32, &p_DigCfgSyncTps62210CsetR);
    createParam(DigCfgSyncTps62210CsetWString, asynParamInt32, &p_DigCfgSyncTps62210CsetW);
    createParam(DigDspAdcTestModeRString, asynParamInt32, &p_DigDspAdcTestModeR);
    createParam(DigDspAdcTestModeWString, asynParamInt32, &p_DigDspAdcTestModeW);
    createParam(DigDspAdcTestResetRString, asynParamInt32, &p_DigDspAdcTestResetR);
    createParam(DigDspAdcTestResetWString, asynParamInt32, &p_DigDspAdcTestResetW);
    createParam(DigDspAmplitudeRString, asynParamInt32, &p_DigDspAmplitudeR);
    createParam(DigDspAmplitudeWString, asynParamInt32, &p_DigDspAmplitudeW);
    createParam(DigDspAverageLenRString, asynParamInt32, &p_DigDspAverageLenR);
    createParam(DigDspAverageLenWString, asynParamInt32, &p_DigDspAverageLenW);
    createParam(DigDspBufTrigRString, asynParamInt32, &p_DigDspBufTrigR);
    createParam(DigDspBufTrigWString, asynParamInt32, &p_DigDspBufTrigW);
    createParam(DigDspCicPeriodRString, asynParamInt32, &p_DigDspCicPeriodR);
    createParam(DigDspCicPeriodWString, asynParamInt32, &p_DigDspCicPeriodW);
    createParam(DigDspCicShiftRString, asynParamInt32, &p_DigDspCicShiftR);
    createParam(DigDspCicShiftWString, asynParamInt32, &p_DigDspCicShiftW);
    createParam(DigDspDacDdsResetRString, asynParamInt32, &p_DigDspDacDdsResetR);
    createParam(DigDspDacDdsResetWString, asynParamInt32, &p_DigDspDacDdsResetW);
    createParam(DigDspDacModeRString, asynParamInt32, &p_DigDspDacModeR);
    createParam(DigDspDacModeWString, asynParamInt32, &p_DigDspDacModeW);
    createParam(DigDspDdsaModuloRString, asynParamInt32, &p_DigDspDdsaModuloR);
    createParam(DigDspDdsaModuloWString, asynParamInt32, &p_DigDspDdsaModuloW);
    createParam(DigDspDdsaPhstepHRString, asynParamInt32, &p_DigDspDdsaPhstepHR);
    createParam(DigDspDdsaPhstepHWString, asynParamInt32, &p_DigDspDdsaPhstepHW);
    createParam(DigDspDdsaPhstepLRString, asynParamInt32, &p_DigDspDdsaPhstepLR);
    createParam(DigDspDdsaPhstepLWString, asynParamInt32, &p_DigDspDdsaPhstepLW);
    createParam(DigDspHistCountWStrobeRString, asynParamInt32, &p_DigDspHistCountWStrobeR);
    createParam(DigDspHistCountWStrobeWString, asynParamInt32, &p_DigDspHistCountWStrobeW);
    createParam(DigDspLoAmpRString, asynParamInt32, &p_DigDspLoAmpR);
    createParam(DigDspLoAmpWString, asynParamInt32, &p_DigDspLoAmpW);
    createParam(DigDspModuloRString, asynParamInt32, &p_DigDspModuloR);
    createParam(DigDspModuloWString, asynParamInt32, &p_DigDspModuloW);
    createParam(DigDspPhaseStepHRString, asynParamInt32, &p_DigDspPhaseStepHR);
    createParam(DigDspPhaseStepHWString, asynParamInt32, &p_DigDspPhaseStepHW);
    createParam(DigDspPhaseStepLRString, asynParamInt32, &p_DigDspPhaseStepLR);
    createParam(DigDspPhaseStepLWString, asynParamInt32, &p_DigDspPhaseStepLW);
    createParam(DigDspRewindRString, asynParamInt32, &p_DigDspRewindR);
    createParam(DigDspRewindWString, asynParamInt32, &p_DigDspRewindW);
    createParam(DigDspSsaStimAmpstepRString, asynParamInt32, &p_DigDspSsaStimAmpstepR);
    createParam(DigDspSsaStimAmpstepWString, asynParamInt32, &p_DigDspSsaStimAmpstepW);
    createParam(DigDspSsaStimEnRString, asynParamInt32, &p_DigDspSsaStimEnR);
    createParam(DigDspSsaStimEnWString, asynParamInt32, &p_DigDspSsaStimEnW);
    createParam(DigDspSsaStimGPeriodRString, asynParamInt32, &p_DigDspSsaStimGPeriodR);
    createParam(DigDspSsaStimGPeriodWString, asynParamInt32, &p_DigDspSsaStimGPeriodW);
    createParam(DigDspSsaStimPertstepRString, asynParamInt32, &p_DigDspSsaStimPertstepR);
    createParam(DigDspSsaStimPertstepWString, asynParamInt32, &p_DigDspSsaStimPertstepW);
    createParam(DigDspTraceKeepRString, asynParamInt32, &p_DigDspTraceKeepR);
    createParam(DigDspTraceKeepWString, asynParamInt32, &p_DigDspTraceKeepW);
    createParam(DigDspTraceResetWeRString, asynParamInt32, &p_DigDspTraceResetWeR);
    createParam(DigDspTraceResetWeWString, asynParamInt32, &p_DigDspTraceResetWeW);
    createParam(DigDspTrigInternalRString, asynParamInt32, &p_DigDspTrigInternalR);
    createParam(DigDspTrigInternalWString, asynParamInt32, &p_DigDspTrigInternalW);
    createParam(DigDspTrigModeRString, asynParamInt32, &p_DigDspTrigModeR);
    createParam(DigDspTrigModeWString, asynParamInt32, &p_DigDspTrigModeW);
    createParam(DigDspWave0SrcRString, asynParamInt32, &p_DigDspWave0SrcR);
    createParam(DigDspWave0SrcWString, asynParamInt32, &p_DigDspWave0SrcW);
    createParam(DigDspWave1SrcRString, asynParamInt32, &p_DigDspWave1SrcR);
    createParam(DigDspWave1SrcWString, asynParamInt32, &p_DigDspWave1SrcW);
    createParam(DigSlowreadTagNowRString, asynParamInt32, &p_DigSlowreadTagNowR);
    createParam(DigSlowreadTagNowWString, asynParamInt32, &p_DigSlowreadTagNowW);
    createParam(FfffffffRString, asynParamInt32, &p_FfffffffR);
    createParam(Frequency4XoutRString, asynParamInt32, &p_Frequency4XoutR);
    createParam(FrequencyAdcRString, asynParamInt32, &p_FrequencyAdcR);
    createParam(FrequencyClkout3RString, asynParamInt32, &p_FrequencyClkout3R);
    createParam(FrequencyDcoRString, asynParamInt32, &p_FrequencyDcoR);
    createParam(FrequencyGtxRxRString, asynParamInt32, &p_FrequencyGtxRxR);
    createParam(FrequencyGtxTxRString, asynParamInt32, &p_FrequencyGtxTxR);
    createParam(H0D0A0D0ARString, asynParamInt32, &p_H0D0A0D0AR);
    createParam(HistDoutRString, asynParamInt32, &p_HistDoutR);
    createParam(HistStatusRString, asynParamInt32, &p_HistStatusR);
    createParam(IccCfgRString, asynParamInt32, &p_IccCfgR);
    createParam(IccCfgWString, asynParamInt32, &p_IccCfgW);
    createParam(Idelay0WString, asynParamInt32, &p_Idelay0W);
    createParam(Idelay0RString, asynParamInt32, &p_Idelay0R);
    createParam(Idelay1WString, asynParamInt32, &p_Idelay1W);
    createParam(Idelay1RString, asynParamInt32, &p_Idelay1R);
    createParam(Idelay10WString, asynParamInt32, &p_Idelay10W);
    createParam(Idelay10RString, asynParamInt32, &p_Idelay10R);
    createParam(Idelay11WString, asynParamInt32, &p_Idelay11W);
    createParam(Idelay11RString, asynParamInt32, &p_Idelay11R);
    createParam(Idelay12WString, asynParamInt32, &p_Idelay12W);
    createParam(Idelay12RString, asynParamInt32, &p_Idelay12R);
    createParam(Idelay13WString, asynParamInt32, &p_Idelay13W);
    createParam(Idelay13RString, asynParamInt32, &p_Idelay13R);
    createParam(Idelay14WString, asynParamInt32, &p_Idelay14W);
    createParam(Idelay14RString, asynParamInt32, &p_Idelay14R);
    createParam(Idelay15WString, asynParamInt32, &p_Idelay15W);
    createParam(Idelay15RString, asynParamInt32, &p_Idelay15R);
    createParam(Idelay2WString, asynParamInt32, &p_Idelay2W);
    createParam(Idelay2RString, asynParamInt32, &p_Idelay2R);
    createParam(Idelay3WString, asynParamInt32, &p_Idelay3W);
    createParam(Idelay3RString, asynParamInt32, &p_Idelay3R);
    createParam(Idelay4WString, asynParamInt32, &p_Idelay4W);
    createParam(Idelay4RString, asynParamInt32, &p_Idelay4R);
    createParam(Idelay5WString, asynParamInt32, &p_Idelay5W);
    createParam(Idelay5RString, asynParamInt32, &p_Idelay5R);
    createParam(Idelay6WString, asynParamInt32, &p_Idelay6W);
    createParam(Idelay6RString, asynParamInt32, &p_Idelay6R);
    createParam(Idelay7WString, asynParamInt32, &p_Idelay7W);
    createParam(Idelay7RString, asynParamInt32, &p_Idelay7R);
    createParam(Idelay8WString, asynParamInt32, &p_Idelay8W);
    createParam(Idelay8RString, asynParamInt32, &p_Idelay8R);
    createParam(Idelay9WString, asynParamInt32, &p_Idelay9W);
    createParam(Idelay9RString, asynParamInt32, &p_Idelay9R);
    createParam(IdelayValueOutU2Bits19To0RString, asynParamInt32, &p_IdelayValueOutU2Bits19To0R);
    createParam(IdelayValueOutU2Bits39To20RString, asynParamInt32, &p_IdelayValueOutU2Bits39To20R);
    createParam(IdelayValueOutU3Bits19To0RString, asynParamInt32, &p_IdelayValueOutU3Bits19To0R);
    createParam(IdelayValueOutU3Bits39To20RString, asynParamInt32, &p_IdelayValueOutU3Bits39To20R);
    createParam(LlspiResultRString, asynParamInt32, &p_LlspiResultR);
    createParam(LlspiStatusRString, asynParamInt32, &p_LlspiStatusR);
    createParam(LlspiWeWString, asynParamInt32, &p_LlspiWeW);
    createParam(OWoRString, asynParamInt32, &p_OWoR);
    createParam(PhasexDoutRString, asynParamInt32, &p_PhasexDoutR);
    createParam(PhasexStatusRString, asynParamInt32, &p_PhasexStatusR);
    createParam(QsfpI2CRegRString, asynParamInt32, &p_QsfpI2CRegR);
    createParam(QsfpI2CRegWString, asynParamInt32, &p_QsfpI2CRegW);
    createParam(RldRString, asynParamInt32, &p_RldR);
    createParam(ScannerResultRString, asynParamInt32, &p_ScannerResultR);
    createParam(SfpAddressSetRString, asynParamInt32, &p_SfpAddressSetR);
    createParam(SfpAddressSetWString, asynParamInt32, &p_SfpAddressSetW);
    createParam(SlowChainOutRString, asynParamInt32, &p_SlowChainOutR);
    createParam(TraceStatusRString, asynParamInt32, &p_TraceStatusR);
    createParam(TraceStatus2RString, asynParamInt32, &p_TraceStatus2R);
    createParam(Wave0OutRString, asynParamInt32, &p_Wave0OutR);
    createParam(Wave1OutRString, asynParamInt32, &p_Wave1OutR);
    createParam(WaveformsAvailableRString, asynParamInt32, &p_WaveformsAvailableR);

    createParam(WaveformI16BitString, asynParamInt16Array, &p_WaveformI16Bit);
    createParam(WaveformQ16BitString, asynParamInt16Array, &p_WaveformQ16Bit);
    createParam(WaveformI22BitString, asynParamInt32Array, &p_WaveformI22Bit);
    createParam(WaveformQ22BitString, asynParamInt32Array, &p_WaveformQ22Bit);
    createParam(IQNActiveString, asynParamInt32, &p_IQNActive);
    createParam(IQBitWidthString, asynParamInt32, &p_IQBitWidth);
    createParam(IQ16BitNELMString, asynParamInt32, &p_IQ16BitNELM);
    createParam(IQ22BitNELMString, asynParamInt32, &p_IQ22BitNELM);

	// A canned request to read all registers
    pPolledRegMsg_ = new FpgaReg[readRegCount + 1]
	{
			{ 0, 0 },
			{ flagReadMask | HellRAdr, blankData },
			{ flagReadMask | OWoRAdr, blankData },
			{ flagReadMask | RldRAdr, blankData },
			{ flagReadMask | H0D0A0D0ARAdr, blankData },
			{ flagReadMask | LlspiStatusRAdr, blankData },
			{ flagReadMask | LlspiResultRAdr, blankData },
			{ flagReadMask | FfffffffRAdr, blankData },
			{ flagReadMask | FrequencyAdcRAdr, blankData },
			{ flagReadMask | Frequency4XoutRAdr, blankData },
			{ flagReadMask | FrequencyClkout3RAdr, blankData },
			{ flagReadMask | FrequencyDcoRAdr, blankData },
			{ flagReadMask | U2Doutbits31To0RAdr, blankData },
			{ flagReadMask | U2Doutbits63To32RAdr, blankData },
			{ flagReadMask | IdelayValueOutU2Bits19To0RAdr, blankData },
			{ flagReadMask | IdelayValueOutU2Bits39To20RAdr, blankData },
			{ flagReadMask | U3Doutbits31To0RAdr, blankData },
			{ flagReadMask | U3Doutbits63To32RAdr, blankData },
			{ flagReadMask | IdelayValueOutU3Bits19To0RAdr, blankData },
			{ flagReadMask | IdelayValueOutU3Bits39To20RAdr, blankData },
			{ flagReadMask | Wave0OutRAdr, blankData },
			{ flagReadMask | Wave1OutRAdr, blankData },
			{ flagReadMask | AdcTestWave1OutRAdr, blankData },
			{ flagReadMask | AdcTestWave2OutRAdr, blankData },
			{ flagReadMask | AdcTestWave3OutRAdr, blankData },
			{ flagReadMask | AdcTestWave4OutRAdr, blankData },
			{ flagReadMask | CtraceRunningRAdr, blankData },
			{ flagReadMask | FrequencyGtxTxRAdr, blankData },
			{ flagReadMask | FrequencyGtxRxRAdr, blankData },
			{ flagReadMask | HistStatusRAdr, blankData },
			{ flagReadMask | PhasexStatusRAdr, blankData },
			{ flagReadMask | ClkPhaseDiffOutU2RAdr, blankData },
			{ flagReadMask | ClkPhaseDiffOutU3RAdr, blankData },
			{ flagReadMask | U15SdoAddrRAdr, blankData },
			{ flagReadMask | U15SdioAsSdoRAdr, blankData },
			{ flagReadMask | U18SdoAddrRAdr, blankData },
			{ flagReadMask | U18SdioAsSdoRAdr, blankData },
			{ flagReadMask | AdcTestTrigCntRAdr, blankData },
			{ flagReadMask | WaveformsAvailableRAdr, blankData },
			{ flagReadMask | BanyanStatusRAdr, blankData },
			{ flagReadMask | SlowChainOutRAdr, blankData },
			{ flagReadMask | TraceStatusRAdr, blankData },
			{ flagReadMask | TraceStatus2RAdr, blankData },
			{ flagReadMask | Idelay0RAdr, blankData },
			{ flagReadMask | Idelay1RAdr, blankData },
			{ flagReadMask | Idelay2RAdr, blankData },
			{ flagReadMask | Idelay3RAdr, blankData },
			{ flagReadMask | Idelay4RAdr, blankData },
			{ flagReadMask | Idelay5RAdr, blankData },
			{ flagReadMask | Idelay6RAdr, blankData },
			{ flagReadMask | Idelay7RAdr, blankData },
			{ flagReadMask | Idelay8RAdr, blankData },
			{ flagReadMask | Idelay9RAdr, blankData },
			{ flagReadMask | Idelay10RAdr, blankData },
			{ flagReadMask | Idelay11RAdr, blankData },
			{ flagReadMask | Idelay12RAdr, blankData },
			{ flagReadMask | Idelay13RAdr, blankData },
			{ flagReadMask | Idelay14RAdr, blankData },
			{ flagReadMask | Idelay15RAdr, blankData },
			{ flagReadMask | HistDoutRAdr, blankData },
			{ flagReadMask | PhasexDoutRAdr, blankData },
			{ flagReadMask | BanyanBufRAdr, blankData },
			{ flagReadMask | ScannerResultRAdr, blankData },
			{ flagReadMask | AdcMmcmRAdr, blankData },
			{ flagReadMask | DigCfgU15SpiDataAddrRRAdr, blankData },
			{ flagReadMask | DigCfgU15SpiReadAndStartRRAdr, blankData },
			{ flagReadMask | DigCfgU18SpiDataAddrRRAdr, blankData },
			{ flagReadMask | DigCfgU18SpiReadAndStartRRAdr, blankData },
			{ flagReadMask | DigCfgU2ClkResetRRAdr, blankData },
			{ flagReadMask | DigCfgU2IserdesResetRRAdr, blankData },
			{ flagReadMask | DigCfgU3ClkResetRRAdr, blankData },
			{ flagReadMask | DigCfgU3IserdesResetRRAdr, blankData },
			{ flagReadMask | DigCfgU4ResetRRAdr, blankData },
			{ flagReadMask | DigCfgBanyanMaskRAdr, blankData },
			{ flagReadMask | DigCfgBitslipRAdr, blankData },
			{ flagReadMask | DigCfgIdelayctrlResetRRAdr, blankData },
			{ flagReadMask | DigCfgLlspiWeRAdr, blankData },
			{ flagReadMask | DigCfgMmcmResetRRAdr, blankData },
			{ flagReadMask | DigCfgPeriphConfigRAdr, blankData },
			{ flagReadMask | DigCfgPhasexTrigRAdr, blankData },
			{ flagReadMask | DigCfgRawadcTrigRAdr, blankData },
			{ flagReadMask | DigCfgScanTriggerWeRAdr, blankData },
			{ flagReadMask | DigCfgScannerDebugRAdr, blankData },
			{ flagReadMask | DigCfgSyncAd7794CsetRAdr, blankData },
			{ flagReadMask | DigCfgSyncTps62210CsetRAdr, blankData },
			{ flagReadMask | DigDspAdcTestModeRAdr, blankData },
			{ flagReadMask | DigDspAdcTestResetRAdr, blankData },
			{ flagReadMask | DigDspAmplitudeRAdr, blankData },
			{ flagReadMask | DigDspAverageLenRAdr, blankData },
			{ flagReadMask | DigDspBufTrigRAdr, blankData },
			{ flagReadMask | DigDspCicPeriodRAdr, blankData },
			{ flagReadMask | DigDspCicShiftRAdr, blankData },
			{ flagReadMask | DigDspDacDdsResetRAdr, blankData },
			{ flagReadMask | DigDspDacModeRAdr, blankData },
			{ flagReadMask | DigDspDdsaModuloRAdr, blankData },
			{ flagReadMask | DigDspDdsaPhstepHRAdr, blankData },
			{ flagReadMask | DigDspDdsaPhstepLRAdr, blankData },
			{ flagReadMask | DigDspHistCountWStrobeRAdr, blankData },
			{ flagReadMask | DigDspLoAmpRAdr, blankData },
			{ flagReadMask | DigDspModuloRAdr, blankData },
			{ flagReadMask | DigDspPhaseStepHRAdr, blankData },
			{ flagReadMask | DigDspPhaseStepLRAdr, blankData },
			{ flagReadMask | DigDspRewindRAdr, blankData },
			{ flagReadMask | DigDspSsaStimAmpstepRAdr, blankData },
			{ flagReadMask | DigDspSsaStimEnRAdr, blankData },
			{ flagReadMask | DigDspSsaStimGPeriodRAdr, blankData },
			{ flagReadMask | DigDspSsaStimPertstepRAdr, blankData },
			{ flagReadMask | DigDspTraceKeepRAdr, blankData },
			{ flagReadMask | DigDspTraceResetWeRAdr, blankData },
			{ flagReadMask | DigDspTrigInternalRAdr, blankData },
			{ flagReadMask | DigDspTrigModeRAdr, blankData },
			{ flagReadMask | DigDspWave0SrcRAdr, blankData },
			{ flagReadMask | DigDspWave1SrcRAdr, blankData },
			{ flagReadMask | DigSlowreadTagNowRAdr, blankData },
			{ flagReadMask | IccCfgRAdr, blankData },
			{ flagReadMask | QsfpI2CRegRAdr, blankData },
			{ flagReadMask | SfpAddressSetRAdr, blankData },
	};
    //printf("\n%s calling htonFpgaRegArray for %u registers\n", __PRETTY_FUNCTION__, readRegCount +1 );
	htonFpgaRegArray(pPolledRegMsg_, readRegCount + 1);
    PolledRegMsgSize_ = readRegCount + 1;

    epicsThreadSleep(defaultPollPeriod);
    printf("%s created %ld parameters.\n",__PRETTY_FUNCTION__,NUM_SCLLRFPRC_PARAMS);

	reqWaveEventId_ = epicsEventMustCreate(epicsEventEmpty);
	startWaveformRequester();

    epicsThreadSleep(defaultPollPeriod);
    wakeupPoller();
    wakeupReader();

}

scllrfPRC::~scllrfPRC()
{
	isShuttingDown_ = true;
	epicsThreadSleep(0.1); // Allow threads to run and exit
	epicsEventSignal(reqWaveEventId_);
	wakeupPoller();
	wakeupReader();
	epicsThreadSleep(0.1); // Allow threads to run and exit
	wakeupPoller(); // call this twice in case the poller was never set to run
	wakeupReader();
	epicsThreadSleep(0.1); // Allow threads to run and exit
	wakeupReader();
	pasynOctetSyncIO->disconnect(pOctetAsynUser_);
	pasynCommonSyncIO->disconnectDevice(pCommonAsynUser_);
	pasynCommonSyncIO->disconnect(pCommonAsynUser_);
}

/** Called when you have the asyn parameter name and want the corresponding
 * register address.
  * \param[in] function From pAsynUser->reason, corresponding to a registered parameter.
  * \param[in] pToFpga Pointer to the {Address, Data} structure where the register address will be written
  * \param[in] nElements Number of elements to read. */
asynStatus scllrfPRC::functionToRegister(const int function, FpgaReg *pToFpga)
{
	asynStatus status = asynSuccess;

    if( function == p_HellR )
    {
		pToFpga->addr = HellRAdr|flagReadMask;
    }
    else
    if( function == p_U15SdioAsSdoR )
    {
		pToFpga->addr = U15SdioAsSdoRAdr|flagReadMask;
    }
    else
    if( function == p_U15SdoAddrR )
    {
		pToFpga->addr = U15SdoAddrRAdr|flagReadMask;
    }
    else
    if( function == p_U15SpiReadyR )
    {
		pToFpga->addr = U15SpiReadyRAdr|flagReadMask;
    }
    else
    if( function == p_U18SdioAsSdoR )
    {
		pToFpga->addr = U18SdioAsSdoRAdr|flagReadMask;
    }
    else
    if( function == p_U18SdoAddrR )
    {
		pToFpga->addr = U18SdoAddrRAdr|flagReadMask;
    }
    else
    if( function == p_U18SpiReadyR )
    {
		pToFpga->addr = U18SpiReadyRAdr|flagReadMask;
    }
    else
    if( function == p_U2Doutbits31To0R )
    {
		pToFpga->addr = U2Doutbits31To0RAdr|flagReadMask;
    }
    else
    if( function == p_U2Doutbits63To32R )
    {
		pToFpga->addr = U2Doutbits63To32RAdr|flagReadMask;
    }
    else
    if( function == p_U3Doutbits31To0R )
    {
		pToFpga->addr = U3Doutbits31To0RAdr|flagReadMask;
    }
    else
    if( function == p_U3Doutbits63To32R )
    {
		pToFpga->addr = U3Doutbits63To32RAdr|flagReadMask;
    }
    else
    if( function == p_U15SpiRdbkR )
    {
		pToFpga->addr = U15SpiRdbkRAdr|flagReadMask;
    }
    else
    if( function == p_U18SpiRdbkR )
    {
		pToFpga->addr = U18SpiRdbkRAdr|flagReadMask;
    }
    else
    if( function == p_AdcMmcmR )
    {
		pToFpga->addr = AdcMmcmRAdr|flagReadMask;
    }
    else
    if( function == p_AdcMmcmW )
    {
		pToFpga->addr = AdcMmcmWAdr;
    }
    else
    if( function == p_AdcTestTrigCntR )
    {
		pToFpga->addr = AdcTestTrigCntRAdr|flagReadMask;
    }
    else
    if( function == p_AdcTestWave1OutR )
    {
		pToFpga->addr = AdcTestWave1OutRAdr|flagReadMask;
    }
    else
    if( function == p_AdcTestWave2OutR )
    {
		pToFpga->addr = AdcTestWave2OutRAdr|flagReadMask;
    }
    else
    if( function == p_AdcTestWave3OutR )
    {
		pToFpga->addr = AdcTestWave3OutRAdr|flagReadMask;
    }
    else
    if( function == p_AdcTestWave4OutR )
    {
		pToFpga->addr = AdcTestWave4OutRAdr|flagReadMask;
    }
    else
    if( function == p_BanyanBufR )
    {
		pToFpga->addr = BanyanBufRAdr|flagReadMask;
    }
    else
    if( function == p_BanyanStatusR )
    {
		pToFpga->addr = BanyanStatusRAdr|flagReadMask;
    }
    else
    if( function == p_ClkPhaseDiffOutU2R )
    {
		pToFpga->addr = ClkPhaseDiffOutU2RAdr|flagReadMask;
    }
    else
    if( function == p_ClkPhaseDiffOutU3R )
    {
		pToFpga->addr = ClkPhaseDiffOutU3RAdr|flagReadMask;
    }
    else
    if( function == p_CtraceRunningR )
    {
		pToFpga->addr = CtraceRunningRAdr|flagReadMask;
    }
    else
    if( function == p_DigCfgU15SpiDataAddrRR )
    {
		pToFpga->addr = DigCfgU15SpiDataAddrRRAdr|flagReadMask;
    }
    else
    if( function == p_DigCfgU15SpiDataAddrRW )
    {
		pToFpga->addr = DigCfgU15SpiDataAddrRWAdr;
    }
    else
    if( function == p_DigCfgU15SpiReadAndStartRR )
    {
		pToFpga->addr = DigCfgU15SpiReadAndStartRRAdr|flagReadMask;
    }
    else
    if( function == p_DigCfgU15SpiReadAndStartRW )
    {
		pToFpga->addr = DigCfgU15SpiReadAndStartRWAdr;
    }
    else
    if( function == p_DigCfgU18SpiDataAddrRR )
    {
		pToFpga->addr = DigCfgU18SpiDataAddrRRAdr|flagReadMask;
    }
    else
    if( function == p_DigCfgU18SpiDataAddrRW )
    {
		pToFpga->addr = DigCfgU18SpiDataAddrRWAdr;
    }
    else
    if( function == p_DigCfgU18SpiReadAndStartRR )
    {
		pToFpga->addr = DigCfgU18SpiReadAndStartRRAdr|flagReadMask;
    }
    else
    if( function == p_DigCfgU18SpiReadAndStartRW )
    {
		pToFpga->addr = DigCfgU18SpiReadAndStartRWAdr;
    }
    else
    if( function == p_DigCfgU2ClkResetRR )
    {
		pToFpga->addr = DigCfgU2ClkResetRRAdr|flagReadMask;
    }
    else
    if( function == p_DigCfgU2ClkResetRW )
    {
		pToFpga->addr = DigCfgU2ClkResetRWAdr;
    }
    else
    if( function == p_DigCfgU2IserdesResetRR )
    {
		pToFpga->addr = DigCfgU2IserdesResetRRAdr|flagReadMask;
    }
    else
    if( function == p_DigCfgU2IserdesResetRW )
    {
		pToFpga->addr = DigCfgU2IserdesResetRWAdr;
    }
    else
    if( function == p_DigCfgU3ClkResetRR )
    {
		pToFpga->addr = DigCfgU3ClkResetRRAdr|flagReadMask;
    }
    else
    if( function == p_DigCfgU3ClkResetRW )
    {
		pToFpga->addr = DigCfgU3ClkResetRWAdr;
    }
    else
    if( function == p_DigCfgU3IserdesResetRR )
    {
		pToFpga->addr = DigCfgU3IserdesResetRRAdr|flagReadMask;
    }
    else
    if( function == p_DigCfgU3IserdesResetRW )
    {
		pToFpga->addr = DigCfgU3IserdesResetRWAdr;
    }
    else
    if( function == p_DigCfgU4ResetRR )
    {
		pToFpga->addr = DigCfgU4ResetRRAdr|flagReadMask;
    }
    else
    if( function == p_DigCfgU4ResetRW )
    {
		pToFpga->addr = DigCfgU4ResetRWAdr;
    }
    else
    if( function == p_DigCfgBanyanMaskR )
    {
		pToFpga->addr = DigCfgBanyanMaskRAdr|flagReadMask;
    }
    else
    if( function == p_DigCfgBanyanMaskW )
    {
		pToFpga->addr = DigCfgBanyanMaskWAdr;
    }
    else
    if( function == p_DigCfgBitslipR )
    {
		pToFpga->addr = DigCfgBitslipRAdr|flagReadMask;
    }
    else
    if( function == p_DigCfgBitslipW )
    {
		pToFpga->addr = DigCfgBitslipWAdr;
    }
    else
    if( function == p_DigCfgIdelayctrlResetRR )
    {
		pToFpga->addr = DigCfgIdelayctrlResetRRAdr|flagReadMask;
    }
    else
    if( function == p_DigCfgIdelayctrlResetRW )
    {
		pToFpga->addr = DigCfgIdelayctrlResetRWAdr;
    }
    else
    if( function == p_DigCfgLlspiWeR )
    {
		pToFpga->addr = DigCfgLlspiWeRAdr|flagReadMask;
    }
    else
    if( function == p_DigCfgLlspiWeW )
    {
		pToFpga->addr = DigCfgLlspiWeWAdr;
    }
    else
    if( function == p_DigCfgMmcmResetRR )
    {
		pToFpga->addr = DigCfgMmcmResetRRAdr|flagReadMask;
    }
    else
    if( function == p_DigCfgMmcmResetRW )
    {
		pToFpga->addr = DigCfgMmcmResetRWAdr;
    }
    else
    if( function == p_DigCfgPeriphConfigR )
    {
		pToFpga->addr = DigCfgPeriphConfigRAdr|flagReadMask;
    }
    else
    if( function == p_DigCfgPeriphConfigW )
    {
		pToFpga->addr = DigCfgPeriphConfigWAdr;
    }
    else
    if( function == p_DigCfgPhasexTrigR )
    {
		pToFpga->addr = DigCfgPhasexTrigRAdr|flagReadMask;
    }
    else
    if( function == p_DigCfgPhasexTrigW )
    {
		pToFpga->addr = DigCfgPhasexTrigWAdr;
    }
    else
    if( function == p_DigCfgRawadcTrigR )
    {
		pToFpga->addr = DigCfgRawadcTrigRAdr|flagReadMask;
    }
    else
    if( function == p_DigCfgRawadcTrigW )
    {
		pToFpga->addr = DigCfgRawadcTrigWAdr;
    }
    else
    if( function == p_DigCfgScanTriggerWeR )
    {
		pToFpga->addr = DigCfgScanTriggerWeRAdr|flagReadMask;
    }
    else
    if( function == p_DigCfgScanTriggerWeW )
    {
		pToFpga->addr = DigCfgScanTriggerWeWAdr;
    }
    else
    if( function == p_DigCfgScannerDebugR )
    {
		pToFpga->addr = DigCfgScannerDebugRAdr|flagReadMask;
    }
    else
    if( function == p_DigCfgScannerDebugW )
    {
		pToFpga->addr = DigCfgScannerDebugWAdr;
    }
    else
    if( function == p_DigCfgSyncAd7794CsetR )
    {
		pToFpga->addr = DigCfgSyncAd7794CsetRAdr|flagReadMask;
    }
    else
    if( function == p_DigCfgSyncAd7794CsetW )
    {
		pToFpga->addr = DigCfgSyncAd7794CsetWAdr;
    }
    else
    if( function == p_DigCfgSyncTps62210CsetR )
    {
		pToFpga->addr = DigCfgSyncTps62210CsetRAdr|flagReadMask;
    }
    else
    if( function == p_DigCfgSyncTps62210CsetW )
    {
		pToFpga->addr = DigCfgSyncTps62210CsetWAdr;
    }
    else
    if( function == p_DigDspAdcTestModeR )
    {
		pToFpga->addr = DigDspAdcTestModeRAdr|flagReadMask;
    }
    else
    if( function == p_DigDspAdcTestModeW )
    {
		pToFpga->addr = DigDspAdcTestModeWAdr;
    }
    else
    if( function == p_DigDspAdcTestResetR )
    {
		pToFpga->addr = DigDspAdcTestResetRAdr|flagReadMask;
    }
    else
    if( function == p_DigDspAdcTestResetW )
    {
		pToFpga->addr = DigDspAdcTestResetWAdr;
    }
    else
    if( function == p_DigDspAmplitudeR )
    {
		pToFpga->addr = DigDspAmplitudeRAdr|flagReadMask;
    }
    else
    if( function == p_DigDspAmplitudeW )
    {
		pToFpga->addr = DigDspAmplitudeWAdr;
    }
    else
    if( function == p_DigDspAverageLenR )
    {
		pToFpga->addr = DigDspAverageLenRAdr|flagReadMask;
    }
    else
    if( function == p_DigDspAverageLenW )
    {
		pToFpga->addr = DigDspAverageLenWAdr;
    }
    else
    if( function == p_DigDspBufTrigR )
    {
		pToFpga->addr = DigDspBufTrigRAdr|flagReadMask;
    }
    else
    if( function == p_DigDspBufTrigW )
    {
		pToFpga->addr = DigDspBufTrigWAdr;
    }
    else
    if( function == p_DigDspCicPeriodR )
    {
		pToFpga->addr = DigDspCicPeriodRAdr|flagReadMask;
    }
    else
    if( function == p_DigDspCicPeriodW )
    {
		pToFpga->addr = DigDspCicPeriodWAdr;
    }
    else
    if( function == p_DigDspCicShiftR )
    {
		pToFpga->addr = DigDspCicShiftRAdr|flagReadMask;
    }
    else
    if( function == p_DigDspCicShiftW )
    {
		pToFpga->addr = DigDspCicShiftWAdr;
    }
    else
    if( function == p_DigDspDacDdsResetR )
    {
		pToFpga->addr = DigDspDacDdsResetRAdr|flagReadMask;
    }
    else
    if( function == p_DigDspDacDdsResetW )
    {
		pToFpga->addr = DigDspDacDdsResetWAdr;
    }
    else
    if( function == p_DigDspDacModeR )
    {
		pToFpga->addr = DigDspDacModeRAdr|flagReadMask;
    }
    else
    if( function == p_DigDspDacModeW )
    {
		pToFpga->addr = DigDspDacModeWAdr;
    }
    else
    if( function == p_DigDspDdsaModuloR )
    {
		pToFpga->addr = DigDspDdsaModuloRAdr|flagReadMask;
    }
    else
    if( function == p_DigDspDdsaModuloW )
    {
		pToFpga->addr = DigDspDdsaModuloWAdr;
    }
    else
    if( function == p_DigDspDdsaPhstepHR )
    {
		pToFpga->addr = DigDspDdsaPhstepHRAdr|flagReadMask;
    }
    else
    if( function == p_DigDspDdsaPhstepHW )
    {
		pToFpga->addr = DigDspDdsaPhstepHWAdr;
    }
    else
    if( function == p_DigDspDdsaPhstepLR )
    {
		pToFpga->addr = DigDspDdsaPhstepLRAdr|flagReadMask;
    }
    else
    if( function == p_DigDspDdsaPhstepLW )
    {
		pToFpga->addr = DigDspDdsaPhstepLWAdr;
    }
    else
    if( function == p_DigDspHistCountWStrobeR )
    {
		pToFpga->addr = DigDspHistCountWStrobeRAdr|flagReadMask;
    }
    else
    if( function == p_DigDspHistCountWStrobeW )
    {
		pToFpga->addr = DigDspHistCountWStrobeWAdr;
    }
    else
    if( function == p_DigDspLoAmpR )
    {
		pToFpga->addr = DigDspLoAmpRAdr|flagReadMask;
    }
    else
    if( function == p_DigDspLoAmpW )
    {
		pToFpga->addr = DigDspLoAmpWAdr;
    }
    else
    if( function == p_DigDspModuloR )
    {
		pToFpga->addr = DigDspModuloRAdr|flagReadMask;
    }
    else
    if( function == p_DigDspModuloW )
    {
		pToFpga->addr = DigDspModuloWAdr;
    }
    else
    if( function == p_DigDspPhaseStepHR )
    {
		pToFpga->addr = DigDspPhaseStepHRAdr|flagReadMask;
    }
    else
    if( function == p_DigDspPhaseStepHW )
    {
		pToFpga->addr = DigDspPhaseStepHWAdr;
    }
    else
    if( function == p_DigDspPhaseStepLR )
    {
		pToFpga->addr = DigDspPhaseStepLRAdr|flagReadMask;
    }
    else
    if( function == p_DigDspPhaseStepLW )
    {
		pToFpga->addr = DigDspPhaseStepLWAdr;
    }
    else
    if( function == p_DigDspRewindR )
    {
		pToFpga->addr = DigDspRewindRAdr|flagReadMask;
    }
    else
    if( function == p_DigDspRewindW )
    {
		pToFpga->addr = DigDspRewindWAdr;
    }
    else
    if( function == p_DigDspSsaStimAmpstepR )
    {
		pToFpga->addr = DigDspSsaStimAmpstepRAdr|flagReadMask;
    }
    else
    if( function == p_DigDspSsaStimAmpstepW )
    {
		pToFpga->addr = DigDspSsaStimAmpstepWAdr;
    }
    else
    if( function == p_DigDspSsaStimEnR )
    {
		pToFpga->addr = DigDspSsaStimEnRAdr|flagReadMask;
    }
    else
    if( function == p_DigDspSsaStimEnW )
    {
		pToFpga->addr = DigDspSsaStimEnWAdr;
    }
    else
    if( function == p_DigDspSsaStimGPeriodR )
    {
		pToFpga->addr = DigDspSsaStimGPeriodRAdr|flagReadMask;
    }
    else
    if( function == p_DigDspSsaStimGPeriodW )
    {
		pToFpga->addr = DigDspSsaStimGPeriodWAdr;
    }
    else
    if( function == p_DigDspSsaStimPertstepR )
    {
		pToFpga->addr = DigDspSsaStimPertstepRAdr|flagReadMask;
    }
    else
    if( function == p_DigDspSsaStimPertstepW )
    {
		pToFpga->addr = DigDspSsaStimPertstepWAdr;
    }
    else
    if( function == p_DigDspTraceKeepR )
    {
		pToFpga->addr = DigDspTraceKeepRAdr|flagReadMask;
    }
    else
    if( function == p_DigDspTraceKeepW )
    {
		pToFpga->addr = DigDspTraceKeepWAdr;
    }
    else
    if( function == p_DigDspTraceResetWeR )
    {
		pToFpga->addr = DigDspTraceResetWeRAdr|flagReadMask;
    }
    else
    if( function == p_DigDspTraceResetWeW )
    {
		pToFpga->addr = DigDspTraceResetWeWAdr;
    }
    else
    if( function == p_DigDspTrigInternalR )
    {
		pToFpga->addr = DigDspTrigInternalRAdr|flagReadMask;
    }
    else
    if( function == p_DigDspTrigInternalW )
    {
		pToFpga->addr = DigDspTrigInternalWAdr;
    }
    else
    if( function == p_DigDspTrigModeR )
    {
		pToFpga->addr = DigDspTrigModeRAdr|flagReadMask;
    }
    else
    if( function == p_DigDspTrigModeW )
    {
		pToFpga->addr = DigDspTrigModeWAdr;
    }
    else
    if( function == p_DigDspWave0SrcR )
    {
		pToFpga->addr = DigDspWave0SrcRAdr|flagReadMask;
    }
    else
    if( function == p_DigDspWave0SrcW )
    {
		pToFpga->addr = DigDspWave0SrcWAdr;
    }
    else
    if( function == p_DigDspWave1SrcR )
    {
		pToFpga->addr = DigDspWave1SrcRAdr|flagReadMask;
    }
    else
    if( function == p_DigDspWave1SrcW )
    {
		pToFpga->addr = DigDspWave1SrcWAdr;
    }
    else
    if( function == p_DigSlowreadTagNowR )
    {
		pToFpga->addr = DigSlowreadTagNowRAdr|flagReadMask;
    }
    else
    if( function == p_DigSlowreadTagNowW )
    {
		pToFpga->addr = DigSlowreadTagNowWAdr;
    }
    else
    if( function == p_FfffffffR )
    {
		pToFpga->addr = FfffffffRAdr|flagReadMask;
    }
    else
    if( function == p_Frequency4XoutR )
    {
		pToFpga->addr = Frequency4XoutRAdr|flagReadMask;
    }
    else
    if( function == p_FrequencyAdcR )
    {
		pToFpga->addr = FrequencyAdcRAdr|flagReadMask;
    }
    else
    if( function == p_FrequencyClkout3R )
    {
		pToFpga->addr = FrequencyClkout3RAdr|flagReadMask;
    }
    else
    if( function == p_FrequencyDcoR )
    {
		pToFpga->addr = FrequencyDcoRAdr|flagReadMask;
    }
    else
    if( function == p_FrequencyGtxRxR )
    {
		pToFpga->addr = FrequencyGtxRxRAdr|flagReadMask;
    }
    else
    if( function == p_FrequencyGtxTxR )
    {
		pToFpga->addr = FrequencyGtxTxRAdr|flagReadMask;
    }
    else
    if( function == p_H0D0A0D0AR )
    {
		pToFpga->addr = H0D0A0D0ARAdr|flagReadMask;
    }
    else
    if( function == p_HistDoutR )
    {
		pToFpga->addr = HistDoutRAdr|flagReadMask;
    }
    else
    if( function == p_HistStatusR )
    {
		pToFpga->addr = HistStatusRAdr|flagReadMask;
    }
    else
    if( function == p_IccCfgR )
    {
		pToFpga->addr = IccCfgRAdr|flagReadMask;
    }
    else
    if( function == p_IccCfgW )
    {
		pToFpga->addr = IccCfgWAdr;
    }
    else
    if( function == p_Idelay0W )
    {
		pToFpga->addr = Idelay0WAdr;
    }
    else
    if( function == p_Idelay0R )
    {
		pToFpga->addr = Idelay0RAdr|flagReadMask;
    }
    else
    if( function == p_Idelay1W )
    {
		pToFpga->addr = Idelay1WAdr;
    }
    else
    if( function == p_Idelay1R )
    {
		pToFpga->addr = Idelay1RAdr|flagReadMask;
    }
    else
    if( function == p_Idelay10W )
    {
		pToFpga->addr = Idelay10WAdr;
    }
    else
    if( function == p_Idelay10R )
    {
		pToFpga->addr = Idelay10RAdr|flagReadMask;
    }
    else
    if( function == p_Idelay11W )
    {
		pToFpga->addr = Idelay11WAdr;
    }
    else
    if( function == p_Idelay11R )
    {
		pToFpga->addr = Idelay11RAdr|flagReadMask;
    }
    else
    if( function == p_Idelay12W )
    {
		pToFpga->addr = Idelay12WAdr;
    }
    else
    if( function == p_Idelay12R )
    {
		pToFpga->addr = Idelay12RAdr|flagReadMask;
    }
    else
    if( function == p_Idelay13W )
    {
		pToFpga->addr = Idelay13WAdr;
    }
    else
    if( function == p_Idelay13R )
    {
		pToFpga->addr = Idelay13RAdr|flagReadMask;
    }
    else
    if( function == p_Idelay14W )
    {
		pToFpga->addr = Idelay14WAdr;
    }
    else
    if( function == p_Idelay14R )
    {
		pToFpga->addr = Idelay14RAdr|flagReadMask;
    }
    else
    if( function == p_Idelay15W )
    {
		pToFpga->addr = Idelay15WAdr;
    }
    else
    if( function == p_Idelay15R )
    {
		pToFpga->addr = Idelay15RAdr|flagReadMask;
    }
    else
    if( function == p_Idelay2W )
    {
		pToFpga->addr = Idelay2WAdr;
    }
    else
    if( function == p_Idelay2R )
    {
		pToFpga->addr = Idelay2RAdr|flagReadMask;
    }
    else
    if( function == p_Idelay3W )
    {
		pToFpga->addr = Idelay3WAdr;
    }
    else
    if( function == p_Idelay3R )
    {
		pToFpga->addr = Idelay3RAdr|flagReadMask;
    }
    else
    if( function == p_Idelay4W )
    {
		pToFpga->addr = Idelay4WAdr;
    }
    else
    if( function == p_Idelay4R )
    {
		pToFpga->addr = Idelay4RAdr|flagReadMask;
    }
    else
    if( function == p_Idelay5W )
    {
		pToFpga->addr = Idelay5WAdr;
    }
    else
    if( function == p_Idelay5R )
    {
		pToFpga->addr = Idelay5RAdr|flagReadMask;
    }
    else
    if( function == p_Idelay6W )
    {
		pToFpga->addr = Idelay6WAdr;
    }
    else
    if( function == p_Idelay6R )
    {
		pToFpga->addr = Idelay6RAdr|flagReadMask;
    }
    else
    if( function == p_Idelay7W )
    {
		pToFpga->addr = Idelay7WAdr;
    }
    else
    if( function == p_Idelay7R )
    {
		pToFpga->addr = Idelay7RAdr|flagReadMask;
    }
    else
    if( function == p_Idelay8W )
    {
		pToFpga->addr = Idelay8WAdr;
    }
    else
    if( function == p_Idelay8R )
    {
		pToFpga->addr = Idelay8RAdr|flagReadMask;
    }
    else
    if( function == p_Idelay9W )
    {
		pToFpga->addr = Idelay9WAdr;
    }
    else
    if( function == p_Idelay9R )
    {
		pToFpga->addr = Idelay9RAdr|flagReadMask;
    }
    else
    if( function == p_IdelayValueOutU2Bits19To0R )
    {
		pToFpga->addr = IdelayValueOutU2Bits19To0RAdr|flagReadMask;
    }
    else
    if( function == p_IdelayValueOutU2Bits39To20R )
    {
		pToFpga->addr = IdelayValueOutU2Bits39To20RAdr|flagReadMask;
    }
    else
    if( function == p_IdelayValueOutU3Bits19To0R )
    {
		pToFpga->addr = IdelayValueOutU3Bits19To0RAdr|flagReadMask;
    }
    else
    if( function == p_IdelayValueOutU3Bits39To20R )
    {
		pToFpga->addr = IdelayValueOutU3Bits39To20RAdr|flagReadMask;
    }
    else
    if( function == p_LlspiResultR )
    {
		pToFpga->addr = LlspiResultRAdr|flagReadMask;
    }
    else
    if( function == p_LlspiStatusR )
    {
		pToFpga->addr = LlspiStatusRAdr|flagReadMask;
    }
    else
    if( function == p_LlspiWeW )
    {
		pToFpga->addr = LlspiWeWAdr;
    }
    else
    if( function == p_OWoR )
    {
		pToFpga->addr = OWoRAdr|flagReadMask;
    }
    else
    if( function == p_PhasexDoutR )
    {
		pToFpga->addr = PhasexDoutRAdr|flagReadMask;
    }
    else
    if( function == p_PhasexStatusR )
    {
		pToFpga->addr = PhasexStatusRAdr|flagReadMask;
    }
    else
    if( function == p_QsfpI2CRegR )
    {
		pToFpga->addr = QsfpI2CRegRAdr|flagReadMask;
    }
    else
    if( function == p_QsfpI2CRegW )
    {
		pToFpga->addr = QsfpI2CRegWAdr;
    }
    else
    if( function == p_RldR )
    {
		pToFpga->addr = RldRAdr|flagReadMask;
    }
    else
    if( function == p_ScannerResultR )
    {
		pToFpga->addr = ScannerResultRAdr|flagReadMask;
    }
    else
    if( function == p_SfpAddressSetR )
    {
		pToFpga->addr = SfpAddressSetRAdr|flagReadMask;
    }
    else
    if( function == p_SfpAddressSetW )
    {
		pToFpga->addr = SfpAddressSetWAdr;
    }
    else
    if( function == p_SlowChainOutR )
    {
		pToFpga->addr = SlowChainOutRAdr|flagReadMask;
    }
    else
    if( function == p_TraceStatusR )
    {
		pToFpga->addr = TraceStatusRAdr|flagReadMask;
    }
    else
    if( function == p_TraceStatus2R )
    {
		pToFpga->addr = TraceStatus2RAdr|flagReadMask;
    }
    else
    if( function == p_Wave0OutR )
    {
		pToFpga->addr = Wave0OutRAdr|flagReadMask;
    }
    else
    if( function == p_Wave1OutR )
    {
		pToFpga->addr = Wave1OutRAdr|flagReadMask;
    }
    else
    if( function == p_WaveformsAvailableR )
    {
		pToFpga->addr = WaveformsAvailableRAdr|flagReadMask;
    }
    else
    	status = asynError;

    return status;
}


/** Called when asyn clients call pasynInt32->read().
 * \param[in] pasynUser pasynUser structure that encodes the reason and address.
 * \param[in] value Pointer to the value to read. */
asynStatus scllrfPRC::writeInt32(asynUser *pasynUser, epicsInt32 value)
{
	int function = pasynUser->reason;
//	int addr = 0;
	asynStatus status = asynSuccess;
    const char *paramName;
//    FpgaReg regSendBuf[2];

	epicsTimeStamp timeStamp; getTimeStamp(&timeStamp);

    /* Set the parameter in the parameter library. */
    status = (asynStatus) setIntegerParam(function, value);

    /* Fetch the parameter string name for possible use in debugging */
    getParamName(function, &paramName);
    asynPrint(pasynUser, ASYN_TRACEIO_DRIVER, "%s: function=%d, %s, set to %d\n",
			__PRETTY_FUNCTION__, function, paramName, value);

    if (function == p_IQBitWidth)
    {
    	wavBitWidth_ = (scllrfPRC::WavBitWidth) value;
    }

    scllrfAsynPortDriver::writeInt32(pasynUser, value);

	/* Do callbacks so higher layers see any changes */
	status = (asynStatus) callParamCallbacks();

    if (status)
        epicsSnprintf(pasynUser->errorMessage, pasynUser->errorMessageSize,
                  "%s: status=%d, function=%d, name=%s, value=%d",
				  __PRETTY_FUNCTION__, status, function, paramName, value);
    else
        asynPrint(pasynUser, ASYN_TRACEIO_DRIVER,
              "<-- %s: function=%d, name=%s, value=%d\n",
			  __PRETTY_FUNCTION__, function, paramName, value);
    return status;
}

/** Called when asyn clients call pasynInt32Array->write().
  * The base class implementation simply prints an error message.
  * Derived classes may reimplement this function if required.
  * \param[in] pasynUser pasynUser structure that encodes the reason and address.
  * \param[in] value Pointer to the array to write.
  * \param[in] nElements Number of elements to write. */
asynStatus scllrfPRC::writeInt32Array(asynUser *pasynUser, epicsInt32 *value,
                                size_t nElements)
{
	int function = pasynUser->reason;
	asynStatus status = asynSuccess;
//	int nCopy;
	FpgaReg regSendBuf[maxMsgSize/sizeof(FpgaReg)];
	unsigned int i, uOutBuffIndex;
	uint32_t uRegAddr;
    const char *paramName;

	//getIntegerParam(P_ArrayLength, &nCopy);
	//if ((int) nElements < nCopy)
	//	nCopy = (int) nElements;

    /* Fetch the parameter string name for possible use in debugging */
    getParamName(function, &paramName);

	if(nElements < 2)
	{
		asynPrint(pasynUser, ASYN_TRACEIO_DRIVER, "%s: array with %d elements, function=%d, %s\n",
				__PRETTY_FUNCTION__, (int) nElements, function, paramName);
		return status;
	}
	else
		asynPrint(pasynUser, ASYN_TRACEIO_DRIVER, "%s: array with %d elements, function=%d, %s\n",
				__PRETTY_FUNCTION__, (int) nElements, function, paramName);

	status = functionToRegister(function, &regSendBuf[1]);
	if (status != asynSuccess)
		return status;

	uRegAddr = regSendBuf[1].addr;
	uOutBuffIndex = 1; // index of first register past the nonce

	for(i=0; i<nElements; ++i, ++uOutBuffIndex)
	{
		regSendBuf[uOutBuffIndex].data = (int32_t) value[i];
		regSendBuf[uOutBuffIndex].addr = (uint32_t) uRegAddr + i;

		// If there's more to send than will fit in the max message size, break
		// it up into chunks and send each chunk individually
		if(uOutBuffIndex == maxMsgSize/sizeof(FpgaReg)-1)
		{
			//printf("\n%s calling htonFpgaRegArray for %u registers\n", __PRETTY_FUNCTION__, uOutBuffIndex );
                        htonFpgaRegArray(regSendBuf, uOutBuffIndex);
			sendRegRequest(regSendBuf, uOutBuffIndex+1);

			if (status)
				epicsSnprintf(pasynUser->errorMessage, pasynUser->errorMessageSize,
						"%s: status=%d, function=%d, sending array segment %u of %s", __PRETTY_FUNCTION__,
						status, function, i/uOutBuffIndex +1, paramName);
			else
				asynPrint(pasynUser, ASYN_TRACEIO_DRIVER, "%s: function=%d, sending array segment %u of %s\n",
						__PRETTY_FUNCTION__, function, i/uOutBuffIndex +1, paramName);
			uOutBuffIndex = 0; // loop will increment to index of first register past the nonce
		}
	}
        //printf("\n%s calling htonFpgaRegArray for %u registers\n", __PRETTY_FUNCTION__, uOutBuffIndex );

	htonFpgaRegArray(regSendBuf, uOutBuffIndex);
	sendRegRequest(regSendBuf, uOutBuffIndex+1);

	if (status)
		epicsSnprintf(pasynUser->errorMessage, pasynUser->errorMessageSize,
				"%s: status=%d, function=%d, sent %s", __PRETTY_FUNCTION__,
				status, function, paramName);
	else
		asynPrint(pasynUser, ASYN_TRACEIO_DRIVER, "%s: function=%d, sent %s\n",
				__PRETTY_FUNCTION__, function, paramName);

	return status; //(writeArray < epicsInt32 > (pasynUser, value, nElements));
}



static void waveformRequesterC(void *drvPvt)
{
	printf("%s: starting\n", __PRETTY_FUNCTION__);
	scllrfPRC *pscllrfDriver = (scllrfPRC*)drvPvt;
	pscllrfDriver->waveformRequester();
	printf("%s: exiting\n", __PRETTY_FUNCTION__);
}

/** Starts the poller thread.
 ** Derived classes will typically call this at near the end of their constructor.
 ** Derived classes can typically use the base class implementation of the poller thread,
 ** but are free to re-implement it if necessary.
 ** \param[in] pollPeriod The time between polls. */
asynStatus scllrfPRC::startWaveformRequester()
{
	epicsThreadCreate("waveformRequester",
			epicsThreadPriorityMedium,
			epicsThreadGetStackSize(epicsThreadStackMedium),
			(EPICSTHREADFUNC)waveformRequesterC, (void *)this);
	return asynSuccess;
}

// When a new value for npt_ (number of points in each waveform) is calculated,
// run this to compose new waveform request messages with the new size.
void scllrfPRC::fillWavReqMsg()
{
	int i, segmentNum, segmentOffset;
	unsigned int addr=0, segStartAddr = wavesStart;
	FpgaReg reqWaveMsg[waveSegmentCount][waveSegmentSize];

	for(i = 0; i<4; i++)
	{
		segmentNum = 0;
		segmentOffset = 1; // Start data past the nonce
		reqWaveMsg[segmentNum][0] = {0,0};
//		printf("\n%s filling waveform request %d: [%u][%u]={0x%x,0x%x}", __PRETTY_FUNCTION__, i, segmentNum, 0,
//				addr, reqWaveMsg[segmentNum][0].data);
		for (addr = segStartAddr; addr < segStartAddr+npt_; addr++, segmentOffset++)
		{
			reqWaveMsg[segmentNum][segmentOffset].addr = (uint32_t) (addr | flagReadMask);
			reqWaveMsg[segmentNum][segmentOffset].data = blankData + addr;
//			printf(", [%u][%u]={0x%x,0x%x}", segmentNum, segmentOffset,
//					addr, reqWaveMsg[segmentNum][segmentOffset].data);

			// If there's more to send than will fit in the max message size, break
			// it up into chunks and send each chunk individually
			if(segmentOffset == maxMsgSize/sizeof(FpgaReg)-1)
			{
				segmentNum++;
				reqWaveMsg[segmentNum][0] = {0,0};
				printf(" %lu bytes in this segment.\n", (segmentOffset +1) * sizeof (FpgaReg));
				segmentOffset = 0; // will be incremented to 1 at the top of the loop
//				printf("\nfilling waveform request %d: [%u][%u]={0x0,0x0}", i, segmentNum, segmentOffset);
			}
		}
//		printf(" %lu of %lu bytes filled in this segment.\n",
//				(segmentOffset +1) * sizeof (FpgaReg), waveSegmentSize * sizeof (FpgaReg));

		// Each segment has unused elements at the end. Safest to convert whole thing.
		//printf("\n%s calling htonFpgaRegArray for waveform %u, %u registers\n", __PRETTY_FUNCTION__, i, waveSegmentCount * waveSegmentSize );
                htonFpgaRegArray(reqWaveMsg[0], waveSegmentCount * waveSegmentSize);

		switch (i)
		{
		case 0:
			std::copy(&reqWaveMsg[0][0], &reqWaveMsg[0][0]+waveSegmentCount * waveSegmentSize,
					&pReqIQ16bAMsg_[0][0]); // Canned message to request 16 bit I/Q data, first npt_ points
			break;
		case 1:
			std::copy(&reqWaveMsg[0][0], &reqWaveMsg[0][0]+waveSegmentCount * waveSegmentSize,
					&pReqIQ16bBMsg_[0][0]); // Canned message to request 16 bit I/Q data, last npt_ points
			break;
		case 2:
			std::copy(&reqWaveMsg[0][0], &reqWaveMsg[0][0]+waveSegmentCount * waveSegmentSize,
					&pReqI22bMsg_[0][0]); // Canned message to request 22 bit I data
			break;
		case 3:
			std::copy(&reqWaveMsg[0][0], &reqWaveMsg[0][0]+waveSegmentCount * waveSegmentSize,
					&pReqQ22bMsg_[0][0]); // Canned message to request 22 bit Q data
			break;
		}
//		printf("Filled up %d of %d segments, last one with %d points\n",
//				segmentNum, waveSegmentCount, segmentOffset);
//		printf("Setting start address of next waveform segment to 0x%x\n", addr);
		segStartAddr = addr;
	}
}


void scllrfPRC::reqOneWaveform(FpgaReg (*readWaveformsMsg)[waveSegmentSize])
{
	int regsLeftToSend = npt_;
	uint i;

//	printf(" --> %s\n", __PRETTY_FUNCTION__);
//	printf("%s waveSegmentSize = %u, waveSegmentCount = %u, regsLeftToSend = %d\n",
//			__PRETTY_FUNCTION__, waveSegmentSize, waveSegmentCount, regsLeftToSend);
//	printf("%s waveBufferRegCount = %u, waveBuffSize = %u, waveSegmentCount = %d\n",
//			__PRETTY_FUNCTION__, waveBufferRegCount, waveBuffSize, waveSegmentCount);
	for (i=0; i<waveSegmentCount; ++i)
	{
		if(regsLeftToSend > (int) (maxMsgSize/sizeof(FpgaReg)))
		{
			sendRegRequest(&readWaveformsMsg[i][0], maxMsgSize/sizeof(FpgaReg));
			regsLeftToSend -= maxMsgSize/sizeof(FpgaReg) - 1;
//			printf("%s sent segment %u, regsLeftToSend = %d\n", __PRETTY_FUNCTION__, i, regsLeftToSend);
		}
		else
		{
			sendRegRequest(&readWaveformsMsg[i][0], regsLeftToSend + 1);
//			printf("%s sent segment %u, last %d registers\n", __PRETTY_FUNCTION__, i, regsLeftToSend);
			break;
		}
	}
//	printf(" <-- %s\n", __PRETTY_FUNCTION__);
}

void scllrfPRC::waveformRequester()
{
	epicsEventWaitStatus status;
	static FpgaReg traceAck[5] =
	{
			{0,0},
			{DigDspTraceResetWeWAdr,1},
			{DigDspBufTrigWAdr,0},
			{DigDspBufTrigWAdr,1},
			{DigDspBufTrigWAdr,0}
	};
	//printf("\n%s calling htonFpgaRegArray for %u registers of traceAck\n", __PRETTY_FUNCTION__, 5 );
    htonFpgaRegArray(traceAck, 5);

	// A canned request to read all waveforms
	// Split up because the packet would be too big for UDP otherwise
	//	static FpgaReg readWaveformsMsg[waveSegmentCount][waveSegmentSize];
	//
	//	for (i=0; i<waveSegmentCount; ++i)
	//	{
	//		readWaveformsMsg[i][0] = (FpgaReg) {0, 0}; // space for the nonce
	//	}
	//
	//	for (waveSegmentNumber=0; waveSegmentNumber < waveSegmentCount; ++waveSegmentNumber)
	//	{
	//		for (waveSegmentOffset = 0; waveSegmentOffset < waveSegmentSize-1; ++waveSegmentOffset)
	//		{
	//			regAddress = wavesStart + waveSegmentNumber*(waveSegmentSize-1) + waveSegmentOffset;
	//			if (regAddress > wavesEnd)
	//			{
	//				lastPointIndex = waveSegmentOffset+1;
	//				break;
	//			}
	//			// put in some data that's a little interesting, but obviously unnatural.
	//			readWaveformsMsg[waveSegmentNumber][waveSegmentOffset+1] = (FpgaReg) { flagReadMask | regAddress, (int32_t) ((double) blankData + 10000.0 * sin((double)regAddress* (regAddress % maxWavesCount)/360.0))};
	//		}
	//	}
	//
	//
	//	htonFpgaRegArray(cmocReadWaveformsMsg[0], sizeof(cmocReadWaveformsMsg)/sizeof(FpgaReg));

	// Main polling loop
	while (1)
	{
		status = epicsEventWait(reqWaveEventId_);

		if (isShuttingDown_)
		{
			break;
		}

		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: signaled by reqWaveEventId_\n", __PRETTY_FUNCTION__);

		if (status == epicsEventWaitOK)
		{
			/* We got an event, rather than a timeout.
			 **/
			switch (wavBitWidth_)
			{
			case read16bit:
				reqOneWaveform(pReqIQ16bAMsg_);
				reqOneWaveform(pReqIQ16bBMsg_);
				break;
			case read22bit:
				reqOneWaveform(pReqI22bMsg_);
				reqOneWaveform(pReqQ22bMsg_);
				break;
			default:
				printf("%s: impossible bit width\n", __PRETTY_FUNCTION__);
			}

			newWaveRead_ = newWaveAvailable_; // Indicate that we got the signal
			sendRegRequest(traceAck, 5);
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
					"%s: done sending waveform request\n", __PRETTY_FUNCTION__);
		}
	}
//	printf("%s: exiting\n", __PRETTY_FUNCTION__);
}


// parse register data, write to array PV
asynStatus scllrfPRC::processWaveReadback(const FpgaReg *pFromFpga)
{
	// avoid divide by 0 errors when waveforms are misconfigured
	if (nchan_ <=0)
	{
		printf("%s can't process waveform data with 0 active channels\n", __PRETTY_FUNCTION__);
		return asynError;
	}
	if (npt_ <=0)
	{
		printf("%s waveform length set to %u but array index is %u\n",
				__PRETTY_FUNCTION__, (unsigned int) npt_, pFromFpga->addr);
		return asynError;
	}

//	printf("--> %s\n", __PRETTY_FUNCTION__);
	unsigned int bufferOffset = (pFromFpga->addr & addrMask) - wavesStart;
	// additional base offsets
	//   0 * npt  16-bit I and Q
	//   1 * npt  16-bit I and Q
	//   2 * npt  22-bit I
	//   3 * npt  22-bit Q
	unsigned int bufferNumber = bufferOffset / npt_; // of the 4 buffers above, which range are we in?
	unsigned int bufferBase = npt_ * bufferNumber; // in bufferNumber, base address offset
	unsigned int waveOffset = (bufferOffset - bufferBase);
	unsigned int waveNumber = waveOffset % nchan_;
	unsigned int waveIndex = waveOffset / nchan_;
	unsigned int i;
//	printf("%s bufferOffset = %u, npt_ = %u, waveNumber = %u waveIndex =%u\n", __PRETTY_FUNCTION__, bufferOffset, npt_, waveNumber, waveIndex);

	switch (bufferNumber)
	{
	case 0: //TODO: verify the packing of the bits for 16 bit data
		pWave16bitI_[waveNumber][waveIndex] = (epicsInt16) pFromFpga->data;
		pWave16bitQ_[waveNumber][waveIndex] = (epicsInt16) (pFromFpga->data >> 16);
		break;

	case 1:
		waveIndex += npt_; // continued from addresses in "case 0"
		pWave16bitI_[waveNumber][waveIndex] = (epicsInt16) pFromFpga->data;
		pWave16bitQ_[waveNumber][waveIndex] = (epicsInt16) (pFromFpga->data >> 16);
		if (waveOffset +1 == npt_) // if this is the last point of the waveform
		{
			setIntegerParam(p_IQ16BitNELM, npt_ * 2/nchan_);
			for (i=0; i<8; ++i)
			{
				if(i<nchan_)
				{
					doCallbacksInt16Array(pWave16bitI_[i], 2*npt_/nchan_, p_WaveformI16Bit, i);
					doCallbacksInt16Array(pWave16bitQ_[i], 2*npt_/nchan_, p_WaveformQ16Bit, i);
				} else { // clear inactive channels
					doCallbacksInt16Array(pWave16bitI_[i], 0, p_WaveformI16Bit, i);
					doCallbacksInt16Array(pWave16bitQ_[i], 0, p_WaveformQ16Bit, i);
				}
			}
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
					"%s: got last waveform datapoint. Publishing.\n", __PRETTY_FUNCTION__);
		}
		break;

	case 2:
		pWave22bitI_[waveNumber][waveIndex] = (epicsInt32) pFromFpga->data;

		if (waveOffset +1 == npt_) // if this is the last point of the waveform
		{
			setIntegerParam(p_IQ22BitNELM, npt_/nchan_);
			for (i=0; i<8; ++i)
			{
				if(i<nchan_)
				{
					doCallbacksInt32Array(pWave22bitI_[i], npt_/nchan_, p_WaveformI22Bit, i);
				} else { // clear inactive channels
					doCallbacksInt32Array(pWave22bitI_[i], 0, p_WaveformI22Bit, i);
				}
			}
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
					"%s: got last waveform datapoint. Publishing.\n", __PRETTY_FUNCTION__);
		}
		break;

	case 3:
		pWave22bitQ_[waveNumber][waveIndex] = (epicsInt32) pFromFpga->data;
		if (waveOffset +1 == npt_) // if this is the last point of the waveform
		{
			setIntegerParam(p_IQ22BitNELM, npt_/nchan_);
			for (i=0; i<8; ++i)
			{
				if(i<nchan_)
				{
					doCallbacksInt32Array(pWave22bitQ_[i], npt_/nchan_, p_WaveformQ22Bit, i);
				} else { // clear inactive channels
					doCallbacksInt32Array(pWave22bitQ_[i], 0, p_WaveformQ22Bit, i);
				}
			}
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
					"%s: got last waveform datapoint. Publishing.\n", __PRETTY_FUNCTION__);
		}
		break;

	}

//	printf("<-- %s\n", __PRETTY_FUNCTION__);
	return asynSuccess;
}

//asynStatus scllrfPRC::catGitSHA1()
//{
//	int oneByte;
//	int i;
//	asynStatus status;
//
//	strGitSHA1.str("");
//	strGitSHA1.clear();
//	strGitSHA1<<std::hex;
//
////	for (i=p_GitSHA1a; i<=p_GitSHA1t; i++)
////	{
////		status = (asynStatus) getIntegerParam(i, &oneByte);
////		strGitSHA1<< std::setw(2) << oneByte;
////	}
////	// used with stringin reccord, which unfortunately can only handle 19 of the 20 characters
////	status = setStringParam(p_GitSHA1, strGitSHA1.str().c_str());
//
//	return asynSuccess;
//}

/**  Extract register address and data from the received message and set the appropriate
 * asyn parameter.
 * Some registers have a "new waveform data ready" flag. If they have this and it is set,
 * set weveIsReady to true.
 * Note: This function should not set waveIsReady to false. That is done by a loop in the
 * calling function.
* \param[in] pFromFpga Data returned from the FPGA for a single register
* \param[in] waveIsReady A flag that gets set to true if the appropriate bit was set by the FPGA
*/
asynStatus scllrfPRC::processRegReadback(const FpgaReg *pFromFpga, bool &waveIsReady)
{
//	unsigned int i;
	asynStatus status = asynSuccess;
	assert(pFromFpga->addr&flagReadMask); // This function is only for read registers
	epicsInt32 errorCount;
	epicsInt32 tmpData;
	int32_t signExtBits = 0;

	/* Map address to parameter, set the parameter in the parameter library. */
	switch (pFromFpga->addr)
    {
    case HellRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_HellR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				HellRString, (unsigned ) pFromFpga->data);
	break;

    case OWoRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_OWoR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				OWoRString, (unsigned ) pFromFpga->data);
	break;

    case RldRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_RldR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				RldRString, (unsigned ) pFromFpga->data);
	break;

    case H0D0A0D0ARAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_H0D0A0D0AR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				H0D0A0D0ARString, (unsigned ) pFromFpga->data);
	break;

    case LlspiStatusRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_LlspiStatusR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				LlspiStatusRString, (unsigned ) pFromFpga->data);
	break;

    case LlspiResultRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_LlspiResultR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				LlspiResultRString, (unsigned ) pFromFpga->data);
	break;

    case FfffffffRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_FfffffffR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				FfffffffRString, (unsigned ) pFromFpga->data);
	break;

    case FrequencyAdcRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_FrequencyAdcR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				FrequencyAdcRString, (unsigned ) pFromFpga->data);
	break;

    case Frequency4XoutRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Frequency4XoutR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Frequency4XoutRString, (unsigned ) pFromFpga->data);
	break;

    case FrequencyClkout3RAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_FrequencyClkout3R,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				FrequencyClkout3RString, (unsigned ) pFromFpga->data);
	break;

    case FrequencyDcoRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_FrequencyDcoR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				FrequencyDcoRString, (unsigned ) pFromFpga->data);
	break;

    case U2Doutbits31To0RAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_U2Doutbits31To0R,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				U2Doutbits31To0RString, (unsigned ) pFromFpga->data);
	break;

    case U2Doutbits63To32RAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_U2Doutbits63To32R,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				U2Doutbits63To32RString, (unsigned ) pFromFpga->data);
	break;

    case IdelayValueOutU2Bits19To0RAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_IdelayValueOutU2Bits19To0R,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				IdelayValueOutU2Bits19To0RString, (unsigned ) pFromFpga->data);
	break;

    case IdelayValueOutU2Bits39To20RAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_IdelayValueOutU2Bits39To20R,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				IdelayValueOutU2Bits39To20RString, (unsigned ) pFromFpga->data);
	break;

    case U3Doutbits31To0RAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_U3Doutbits31To0R,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				U3Doutbits31To0RString, (unsigned ) pFromFpga->data);
	break;

    case U3Doutbits63To32RAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_U3Doutbits63To32R,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				U3Doutbits63To32RString, (unsigned ) pFromFpga->data);
	break;

    case IdelayValueOutU3Bits19To0RAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_IdelayValueOutU3Bits19To0R,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				IdelayValueOutU3Bits19To0RString, (unsigned ) pFromFpga->data);
	break;

    case IdelayValueOutU3Bits39To20RAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_IdelayValueOutU3Bits39To20R,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				IdelayValueOutU3Bits39To20RString, (unsigned ) pFromFpga->data);
	break;

    case Wave0OutRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Wave0OutR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Wave0OutRString, (unsigned ) pFromFpga->data);
	break;

    case Wave1OutRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Wave1OutR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Wave1OutRString, (unsigned ) pFromFpga->data);
	break;

    case AdcTestWave1OutRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_AdcTestWave1OutR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				AdcTestWave1OutRString, (unsigned ) pFromFpga->data);
	break;

    case AdcTestWave2OutRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_AdcTestWave2OutR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				AdcTestWave2OutRString, (unsigned ) pFromFpga->data);
	break;

    case AdcTestWave3OutRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_AdcTestWave3OutR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				AdcTestWave3OutRString, (unsigned ) pFromFpga->data);
	break;

    case AdcTestWave4OutRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_AdcTestWave4OutR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				AdcTestWave4OutRString, (unsigned ) pFromFpga->data);
	break;

    case CtraceRunningRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_CtraceRunningR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				CtraceRunningRString, (unsigned ) pFromFpga->data);
	break;

    case FrequencyGtxTxRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_FrequencyGtxTxR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				FrequencyGtxTxRString, (unsigned ) pFromFpga->data);
	break;

    case FrequencyGtxRxRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_FrequencyGtxRxR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				FrequencyGtxRxRString, (unsigned ) pFromFpga->data);
	break;

    case HistStatusRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_HistStatusR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				HistStatusRString, (unsigned ) pFromFpga->data);
	break;

    case PhasexStatusRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_PhasexStatusR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				PhasexStatusRString, (unsigned ) pFromFpga->data);
	break;

    case ClkPhaseDiffOutU2RAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_ClkPhaseDiffOutU2R,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				ClkPhaseDiffOutU2RString, (unsigned ) pFromFpga->data);
	break;

    case ClkPhaseDiffOutU3RAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_ClkPhaseDiffOutU3R,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				ClkPhaseDiffOutU3RString, (unsigned ) pFromFpga->data);
	break;

    case U15SdoAddrRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_U15SdoAddrR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				U15SdoAddrRString, (unsigned ) pFromFpga->data);
	
	// shared address with U15SpiRdbkRAdr
		status = (asynStatus) setIntegerParam(p_U15SpiRdbkR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				U15SpiRdbkRString, (unsigned ) pFromFpga->data);
	break;

    case U15SdioAsSdoRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_U15SdioAsSdoR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				U15SdioAsSdoRString, (unsigned ) pFromFpga->data);
	
	// shared address with U15SpiReadyRAdr
		status = (asynStatus) setIntegerParam(p_U15SpiReadyR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				U15SpiReadyRString, (unsigned ) pFromFpga->data);
	break;

    case U18SdoAddrRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_U18SdoAddrR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				U18SdoAddrRString, (unsigned ) pFromFpga->data);
	
	// shared address with U18SpiRdbkRAdr
		status = (asynStatus) setIntegerParam(p_U18SpiRdbkR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				U18SpiRdbkRString, (unsigned ) pFromFpga->data);
	break;

    case U18SdioAsSdoRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_U18SdioAsSdoR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				U18SdioAsSdoRString, (unsigned ) pFromFpga->data);
	
	// shared address with U18SpiReadyRAdr
		status = (asynStatus) setIntegerParam(p_U18SpiReadyR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				U18SpiReadyRString, (unsigned ) pFromFpga->data);
	break;

    case AdcTestTrigCntRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_AdcTestTrigCntR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				AdcTestTrigCntRString, (unsigned ) pFromFpga->data);
	break;

    case WaveformsAvailableRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_WaveformsAvailableR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				WaveformsAvailableRString, (unsigned ) pFromFpga->data);
	break;

    case BanyanStatusRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_BanyanStatusR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				BanyanStatusRString, (unsigned ) pFromFpga->data);
	break;

    case SlowChainOutRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_SlowChainOutR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				SlowChainOutRString, (unsigned ) pFromFpga->data);
	break;

    case TraceStatusRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_TraceStatusR,
				pFromFpga->data);
		if (pFromFpga->data & waveIsReadyMask)
		{
			waveIsReady = true;
		}
		// Calculate number of points per waveform, and update request
		// waveform messages if it has changed.
		if(npt_ != (size_t) (1 << ((pFromFpga->data & nptMask)>> 24)))
		{
			npt_ = 1 << ((pFromFpga->data & nptMask)>> 24);
			fillWavReqMsg();
		}
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				TraceStatusRString, (unsigned ) pFromFpga->data);
	break;

    case TraceStatus2RAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_TraceStatus2R,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				TraceStatus2RString, (unsigned ) pFromFpga->data);
	break;
	
    case Idelay0RAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Idelay0R,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Idelay0RString, (unsigned ) pFromFpga->data);
	break;
	
    case Idelay1RAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Idelay1R,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Idelay1RString, (unsigned ) pFromFpga->data);
	break;
	
    case Idelay2RAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Idelay2R,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Idelay2RString, (unsigned ) pFromFpga->data);
	break;
	
    case Idelay3RAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Idelay3R,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Idelay3RString, (unsigned ) pFromFpga->data);
	break;
	
    case Idelay4RAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Idelay4R,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Idelay4RString, (unsigned ) pFromFpga->data);
	break;
	
    case Idelay5RAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Idelay5R,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Idelay5RString, (unsigned ) pFromFpga->data);
	break;
	
    case Idelay6RAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Idelay6R,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Idelay6RString, (unsigned ) pFromFpga->data);
	break;
	
    case Idelay7RAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Idelay7R,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Idelay7RString, (unsigned ) pFromFpga->data);
	break;
	
    case Idelay8RAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Idelay8R,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Idelay8RString, (unsigned ) pFromFpga->data);
	break;
	
    case Idelay9RAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Idelay9R,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Idelay9RString, (unsigned ) pFromFpga->data);
	break;
	
    case Idelay10RAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Idelay10R,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Idelay10RString, (unsigned ) pFromFpga->data);
	break;
	
    case Idelay11RAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Idelay11R,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Idelay11RString, (unsigned ) pFromFpga->data);
	break;
	
    case Idelay12RAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Idelay12R,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Idelay12RString, (unsigned ) pFromFpga->data);
	break;
	
    case Idelay13RAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Idelay13R,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Idelay13RString, (unsigned ) pFromFpga->data);
	break;
	
    case Idelay14RAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Idelay14R,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Idelay14RString, (unsigned ) pFromFpga->data);
	break;
	
    case Idelay15RAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Idelay15R,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Idelay15RString, (unsigned ) pFromFpga->data);
	break;

    case HistDoutRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_HistDoutR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				HistDoutRString, (unsigned ) pFromFpga->data);
	break;

    case PhasexDoutRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_PhasexDoutR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				PhasexDoutRString, (unsigned ) pFromFpga->data);
	break;

    case BanyanBufRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_BanyanBufR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				BanyanBufRString, (unsigned ) pFromFpga->data);
	break;

    case ScannerResultRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_ScannerResultR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				ScannerResultRString, (unsigned ) pFromFpga->data);
	break;

    case AdcMmcmRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_AdcMmcmR,
				(pFromFpga->data & AdcMmcmMask) | signExtBits);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				AdcMmcmRString,
				(unsigned ) pFromFpga->data & AdcMmcmMask);
	break;

    case DigCfgU15SpiDataAddrRRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_DigCfgU15SpiDataAddrRR,
				(pFromFpga->data & DigCfgU15SpiDataAddrRMask) | signExtBits);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigCfgU15SpiDataAddrRRString,
				(unsigned ) pFromFpga->data & DigCfgU15SpiDataAddrRMask);
	break;

    case DigCfgU15SpiReadAndStartRRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_DigCfgU15SpiReadAndStartRR,
				(pFromFpga->data & DigCfgU15SpiReadAndStartRMask) | signExtBits);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigCfgU15SpiReadAndStartRRString,
				(unsigned ) pFromFpga->data & DigCfgU15SpiReadAndStartRMask);
	break;

    case DigCfgU18SpiDataAddrRRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_DigCfgU18SpiDataAddrRR,
				(pFromFpga->data & DigCfgU18SpiDataAddrRMask) | signExtBits);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigCfgU18SpiDataAddrRRString,
				(unsigned ) pFromFpga->data & DigCfgU18SpiDataAddrRMask);
	break;

    case DigCfgU18SpiReadAndStartRRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_DigCfgU18SpiReadAndStartRR,
				(pFromFpga->data & DigCfgU18SpiReadAndStartRMask) | signExtBits);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigCfgU18SpiReadAndStartRRString,
				(unsigned ) pFromFpga->data & DigCfgU18SpiReadAndStartRMask);
	break;

    case DigCfgU2ClkResetRRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_DigCfgU2ClkResetRR,
				(pFromFpga->data & DigCfgU2ClkResetRMask) | signExtBits);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigCfgU2ClkResetRRString,
				(unsigned ) pFromFpga->data & DigCfgU2ClkResetRMask);
	break;

    case DigCfgU2IserdesResetRRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_DigCfgU2IserdesResetRR,
				(pFromFpga->data & DigCfgU2IserdesResetRMask) | signExtBits);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigCfgU2IserdesResetRRString,
				(unsigned ) pFromFpga->data & DigCfgU2IserdesResetRMask);
	break;

    case DigCfgU3ClkResetRRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_DigCfgU3ClkResetRR,
				(pFromFpga->data & DigCfgU3ClkResetRMask) | signExtBits);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigCfgU3ClkResetRRString,
				(unsigned ) pFromFpga->data & DigCfgU3ClkResetRMask);
	break;

    case DigCfgU3IserdesResetRRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_DigCfgU3IserdesResetRR,
				(pFromFpga->data & DigCfgU3IserdesResetRMask) | signExtBits);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigCfgU3IserdesResetRRString,
				(unsigned ) pFromFpga->data & DigCfgU3IserdesResetRMask);
	break;

    case DigCfgU4ResetRRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_DigCfgU4ResetRR,
				(pFromFpga->data & DigCfgU4ResetRMask) | signExtBits);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigCfgU4ResetRRString,
				(unsigned ) pFromFpga->data & DigCfgU4ResetRMask);
	break;

    case DigCfgBanyanMaskRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_DigCfgBanyanMaskR,
				(pFromFpga->data & DigCfgBanyanMaskMask) | signExtBits);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigCfgBanyanMaskRString,
				(unsigned ) pFromFpga->data & DigCfgBanyanMaskMask);
	break;

    case DigCfgBitslipRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_DigCfgBitslipR,
				(pFromFpga->data & DigCfgBitslipMask) | signExtBits);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigCfgBitslipRString,
				(unsigned ) pFromFpga->data & DigCfgBitslipMask);
	break;

    case DigCfgIdelayctrlResetRRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_DigCfgIdelayctrlResetRR,
				(pFromFpga->data & DigCfgIdelayctrlResetRMask) | signExtBits);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigCfgIdelayctrlResetRRString,
				(unsigned ) pFromFpga->data & DigCfgIdelayctrlResetRMask);
	break;

    case DigCfgLlspiWeRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_DigCfgLlspiWeR,
				(pFromFpga->data & DigCfgLlspiWeMask) | signExtBits);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigCfgLlspiWeRString,
				(unsigned ) pFromFpga->data & DigCfgLlspiWeMask);
	break;

    case DigCfgMmcmResetRRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_DigCfgMmcmResetRR,
				(pFromFpga->data & DigCfgMmcmResetRMask) | signExtBits);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigCfgMmcmResetRRString,
				(unsigned ) pFromFpga->data & DigCfgMmcmResetRMask);
	break;

    case DigCfgPeriphConfigRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_DigCfgPeriphConfigR,
				(pFromFpga->data & DigCfgPeriphConfigMask) | signExtBits);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigCfgPeriphConfigRString,
				(unsigned ) pFromFpga->data & DigCfgPeriphConfigMask);
	break;

    case DigCfgPhasexTrigRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_DigCfgPhasexTrigR,
				(pFromFpga->data & DigCfgPhasexTrigMask) | signExtBits);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigCfgPhasexTrigRString,
				(unsigned ) pFromFpga->data & DigCfgPhasexTrigMask);
	break;

    case DigCfgRawadcTrigRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_DigCfgRawadcTrigR,
				(pFromFpga->data & DigCfgRawadcTrigMask) | signExtBits);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigCfgRawadcTrigRString,
				(unsigned ) pFromFpga->data & DigCfgRawadcTrigMask);
	break;

    case DigCfgScanTriggerWeRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_DigCfgScanTriggerWeR,
				(pFromFpga->data & DigCfgScanTriggerWeMask) | signExtBits);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigCfgScanTriggerWeRString,
				(unsigned ) pFromFpga->data & DigCfgScanTriggerWeMask);
	break;

    case DigCfgScannerDebugRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_DigCfgScannerDebugR,
				(pFromFpga->data & DigCfgScannerDebugMask) | signExtBits);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigCfgScannerDebugRString,
				(unsigned ) pFromFpga->data & DigCfgScannerDebugMask);
	break;

    case DigCfgSyncAd7794CsetRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_DigCfgSyncAd7794CsetR,
				(pFromFpga->data & DigCfgSyncAd7794CsetMask) | signExtBits);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigCfgSyncAd7794CsetRString,
				(unsigned ) pFromFpga->data & DigCfgSyncAd7794CsetMask);
	break;

    case DigCfgSyncTps62210CsetRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_DigCfgSyncTps62210CsetR,
				(pFromFpga->data & DigCfgSyncTps62210CsetMask) | signExtBits);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigCfgSyncTps62210CsetRString,
				(unsigned ) pFromFpga->data & DigCfgSyncTps62210CsetMask);
	break;

    case DigDspAdcTestModeRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_DigDspAdcTestModeR,
				(pFromFpga->data & DigDspAdcTestModeMask) | signExtBits);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspAdcTestModeRString,
				(unsigned ) pFromFpga->data & DigDspAdcTestModeMask);
	break;

    case DigDspAdcTestResetRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_DigDspAdcTestResetR,
				(pFromFpga->data & DigDspAdcTestResetMask) | signExtBits);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspAdcTestResetRString,
				(unsigned ) pFromFpga->data & DigDspAdcTestResetMask);
	break;

    case DigDspAmplitudeRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_DigDspAmplitudeR,
				(pFromFpga->data & DigDspAmplitudeMask) | signExtBits);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspAmplitudeRString,
				(unsigned ) pFromFpga->data & DigDspAmplitudeMask);
	break;

    case DigDspAverageLenRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_DigDspAverageLenR,
				(pFromFpga->data & DigDspAverageLenMask) | signExtBits);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspAverageLenRString,
				(unsigned ) pFromFpga->data & DigDspAverageLenMask);
	break;

    case DigDspBufTrigRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_DigDspBufTrigR,
				(pFromFpga->data & DigDspBufTrigMask) | signExtBits);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspBufTrigRString,
				(unsigned ) pFromFpga->data & DigDspBufTrigMask);
	break;

    case DigDspCicPeriodRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_DigDspCicPeriodR,
				(pFromFpga->data & DigDspCicPeriodMask) | signExtBits);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspCicPeriodRString,
				(unsigned ) pFromFpga->data & DigDspCicPeriodMask);
	break;

    case DigDspCicShiftRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_DigDspCicShiftR,
				(pFromFpga->data & DigDspCicShiftMask) | signExtBits);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspCicShiftRString,
				(unsigned ) pFromFpga->data & DigDspCicShiftMask);
	break;

    case DigDspDacDdsResetRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_DigDspDacDdsResetR,
				(pFromFpga->data & DigDspDacDdsResetMask) | signExtBits);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspDacDdsResetRString,
				(unsigned ) pFromFpga->data & DigDspDacDdsResetMask);
	break;

    case DigDspDacModeRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_DigDspDacModeR,
				(pFromFpga->data & DigDspDacModeMask) | signExtBits);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspDacModeRString,
				(unsigned ) pFromFpga->data & DigDspDacModeMask);
	break;

    case DigDspDdsaModuloRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_DigDspDdsaModuloR,
				(pFromFpga->data & DigDspDdsaModuloMask) | signExtBits);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspDdsaModuloRString,
				(unsigned ) pFromFpga->data & DigDspDdsaModuloMask);
	break;

    case DigDspDdsaPhstepHRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_DigDspDdsaPhstepHR,
				(pFromFpga->data & DigDspDdsaPhstepHMask) | signExtBits);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspDdsaPhstepHRString,
				(unsigned ) pFromFpga->data & DigDspDdsaPhstepHMask);
	break;

    case DigDspDdsaPhstepLRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_DigDspDdsaPhstepLR,
				(pFromFpga->data & DigDspDdsaPhstepLMask) | signExtBits);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspDdsaPhstepLRString,
				(unsigned ) pFromFpga->data & DigDspDdsaPhstepLMask);
	break;

    case DigDspHistCountWStrobeRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_DigDspHistCountWStrobeR,
				(pFromFpga->data & DigDspHistCountWStrobeMask) | signExtBits);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspHistCountWStrobeRString,
				(unsigned ) pFromFpga->data & DigDspHistCountWStrobeMask);
	break;

    case DigDspLoAmpRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_DigDspLoAmpR,
				(pFromFpga->data & DigDspLoAmpMask) | signExtBits);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspLoAmpRString,
				(unsigned ) pFromFpga->data & DigDspLoAmpMask);
	break;

    case DigDspModuloRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_DigDspModuloR,
				(pFromFpga->data & DigDspModuloMask) | signExtBits);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspModuloRString,
				(unsigned ) pFromFpga->data & DigDspModuloMask);
	break;

    case DigDspPhaseStepHRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_DigDspPhaseStepHR,
				(pFromFpga->data & DigDspPhaseStepHMask) | signExtBits);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspPhaseStepHRString,
				(unsigned ) pFromFpga->data & DigDspPhaseStepHMask);
	break;

    case DigDspPhaseStepLRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_DigDspPhaseStepLR,
				(pFromFpga->data & DigDspPhaseStepLMask) | signExtBits);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspPhaseStepLRString,
				(unsigned ) pFromFpga->data & DigDspPhaseStepLMask);
	break;

    case DigDspRewindRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_DigDspRewindR,
				(pFromFpga->data & DigDspRewindMask) | signExtBits);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspRewindRString,
				(unsigned ) pFromFpga->data & DigDspRewindMask);
	break;

    case DigDspSsaStimAmpstepRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_DigDspSsaStimAmpstepR,
				(pFromFpga->data & DigDspSsaStimAmpstepMask) | signExtBits);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspSsaStimAmpstepRString,
				(unsigned ) pFromFpga->data & DigDspSsaStimAmpstepMask);
	break;

    case DigDspSsaStimEnRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_DigDspSsaStimEnR,
				(pFromFpga->data & DigDspSsaStimEnMask) | signExtBits);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspSsaStimEnRString,
				(unsigned ) pFromFpga->data & DigDspSsaStimEnMask);
	break;

    case DigDspSsaStimGPeriodRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_DigDspSsaStimGPeriodR,
				(pFromFpga->data & DigDspSsaStimGPeriodMask) | signExtBits);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspSsaStimGPeriodRString,
				(unsigned ) pFromFpga->data & DigDspSsaStimGPeriodMask);
	break;

    case DigDspSsaStimPertstepRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_DigDspSsaStimPertstepR,
				(pFromFpga->data & DigDspSsaStimPertstepMask) | signExtBits);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspSsaStimPertstepRString,
				(unsigned ) pFromFpga->data & DigDspSsaStimPertstepMask);
	break;

    case DigDspTraceKeepRAdr|flagReadMask:
	tmpData = pFromFpga->data & TraceKeepRMask;
//    printf("%s got data 0x%x for TraceKeepRAdr\n",__PRETTY_FUNCTION__,tmpData);
		status = (asynStatus) setIntegerParam(p_DigDspTraceKeepR,
				(pFromFpga->data & DigDspTraceKeepMask) | signExtBits);
		// Count the number of bits set
		for (nchan_ = 0; tmpData; nchan_++)
		{
		  tmpData &= tmpData - 1; // clear the least significant bit set
		}
		setIntegerParam(p_IQNActive, nchan_);
//	    printf("%s TraceKeepRAdr says %d active channels\n",__PRETTY_FUNCTION__,nchan_);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspTraceKeepRString,
				(unsigned ) pFromFpga->data & DigDspTraceKeepMask);
	break;

    case DigDspTraceResetWeRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_DigDspTraceResetWeR,
				(pFromFpga->data & DigDspTraceResetWeMask) | signExtBits);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspTraceResetWeRString,
				(unsigned ) pFromFpga->data & DigDspTraceResetWeMask);
	break;

    case DigDspTrigInternalRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_DigDspTrigInternalR,
				(pFromFpga->data & DigDspTrigInternalMask) | signExtBits);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspTrigInternalRString,
				(unsigned ) pFromFpga->data & DigDspTrigInternalMask);
	break;

    case DigDspTrigModeRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_DigDspTrigModeR,
				(pFromFpga->data & DigDspTrigModeMask) | signExtBits);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspTrigModeRString,
				(unsigned ) pFromFpga->data & DigDspTrigModeMask);
	break;

    case DigDspWave0SrcRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_DigDspWave0SrcR,
				(pFromFpga->data & DigDspWave0SrcMask) | signExtBits);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspWave0SrcRString,
				(unsigned ) pFromFpga->data & DigDspWave0SrcMask);
	break;

    case DigDspWave1SrcRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_DigDspWave1SrcR,
				(pFromFpga->data & DigDspWave1SrcMask) | signExtBits);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspWave1SrcRString,
				(unsigned ) pFromFpga->data & DigDspWave1SrcMask);
	break;

    case DigSlowreadTagNowRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_DigSlowreadTagNowR,
				(pFromFpga->data & DigSlowreadTagNowMask) | signExtBits);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigSlowreadTagNowRString,
				(unsigned ) pFromFpga->data & DigSlowreadTagNowMask);
	break;

    case IccCfgRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_IccCfgR,
				(pFromFpga->data & IccCfgMask) | signExtBits);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				IccCfgRString,
				(unsigned ) pFromFpga->data & IccCfgMask);
	break;

    case QsfpI2CRegRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_QsfpI2CRegR,
				(pFromFpga->data & QsfpI2CRegMask) | signExtBits);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				QsfpI2CRegRString,
				(unsigned ) pFromFpga->data & QsfpI2CRegMask);
	break;

    case SfpAddressSetRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_SfpAddressSetR,
				(pFromFpga->data & SfpAddressSetMask) | signExtBits);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				SfpAddressSetRString,
				(unsigned ) pFromFpga->data & SfpAddressSetMask);
	break;

	default:
		if( wavesStart <= (pFromFpga->addr & addrMask) && (pFromFpga->addr & addrMask) <= wavesEnd )
		{
//			printf("%s waveform addres 0x%x, value %d\n", __PRETTY_FUNCTION__, (pFromFpga->addr & addrMask), pFromFpga->data);
			processWaveReadback(pFromFpga);
		}
		else
		{
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, errorCount + 1);
		status = asynError;
		}
		break;
    }

    return status;
}


/**  Extract register address and data from the received message and set the appropriate
 * asyn parameter.
 * Some registers have a "new waveform data ready" flag. If they have this and it is set,
 * set weveIsReady to true.
 * Note: This function should not set waveIsReady to false. That is done by a loop in the
 * calling function.
* \param[in] pFromFpga Data returned from the FPGA for a single register
* \param[in] waveIsReady A flag that gets set to true if the appropriate bit was set by the FPGA
*/
asynStatus scllrfPRC::processRegWriteResponse(const FpgaReg *pFromFpga)
{
	asynStatus status = asynSuccess;
	epicsInt32 valueSet[maxMsgSize/sizeof(FpgaReg)]; // Put the value sent to the FPGA here for comparison
//	epicsUInt32 uValueSet;
	epicsInt32 tmpData;
	epicsInt32 errorCount;
//  variables that may be useful for checking array data
//	asynUser *pAsynArrayUser;
//	unsigned int i;
	assert(!(pFromFpga->addr&flagReadMask)); // This function is only for read registers

	/* Map address to parameter, set the parameter in the parameter library. */
	switch (pFromFpga->addr)
    {
    case LlspiWeWAdr:
		status = (asynStatus) getIntegerParam(p_LlspiWeW, valueSet);
		if( (valueSet[0] ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				LlspiWeWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				LlspiWeWString, valueSet[0] , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_LlspiWeW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Idelay0WAdr:
		status = (asynStatus) getIntegerParam(p_Idelay0W, valueSet);
		if( (valueSet[0] ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Idelay0WString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Idelay0WString, valueSet[0] , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Idelay0W, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Idelay1WAdr:
		status = (asynStatus) getIntegerParam(p_Idelay1W, valueSet);
		if( (valueSet[0] ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Idelay1WString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Idelay1WString, valueSet[0] , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Idelay1W, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Idelay2WAdr:
		status = (asynStatus) getIntegerParam(p_Idelay2W, valueSet);
		if( (valueSet[0] ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Idelay2WString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Idelay2WString, valueSet[0] , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Idelay2W, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Idelay3WAdr:
		status = (asynStatus) getIntegerParam(p_Idelay3W, valueSet);
		if( (valueSet[0] ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Idelay3WString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Idelay3WString, valueSet[0] , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Idelay3W, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Idelay4WAdr:
		status = (asynStatus) getIntegerParam(p_Idelay4W, valueSet);
		if( (valueSet[0] ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Idelay4WString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Idelay4WString, valueSet[0] , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Idelay4W, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Idelay5WAdr:
		status = (asynStatus) getIntegerParam(p_Idelay5W, valueSet);
		if( (valueSet[0] ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Idelay5WString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Idelay5WString, valueSet[0] , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Idelay5W, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Idelay6WAdr:
		status = (asynStatus) getIntegerParam(p_Idelay6W, valueSet);
		if( (valueSet[0] ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Idelay6WString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Idelay6WString, valueSet[0] , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Idelay6W, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Idelay7WAdr:
		status = (asynStatus) getIntegerParam(p_Idelay7W, valueSet);
		if( (valueSet[0] ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Idelay7WString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Idelay7WString, valueSet[0] , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Idelay7W, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Idelay8WAdr:
		status = (asynStatus) getIntegerParam(p_Idelay8W, valueSet);
		if( (valueSet[0] ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Idelay8WString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Idelay8WString, valueSet[0] , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Idelay8W, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Idelay9WAdr:
		status = (asynStatus) getIntegerParam(p_Idelay9W, valueSet);
		if( (valueSet[0] ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Idelay9WString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Idelay9WString, valueSet[0] , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Idelay9W, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Idelay10WAdr:
		status = (asynStatus) getIntegerParam(p_Idelay10W, valueSet);
		if( (valueSet[0] ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Idelay10WString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Idelay10WString, valueSet[0] , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Idelay10W, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Idelay11WAdr:
		status = (asynStatus) getIntegerParam(p_Idelay11W, valueSet);
		if( (valueSet[0] ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Idelay11WString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Idelay11WString, valueSet[0] , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Idelay11W, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Idelay12WAdr:
		status = (asynStatus) getIntegerParam(p_Idelay12W, valueSet);
		if( (valueSet[0] ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Idelay12WString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Idelay12WString, valueSet[0] , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Idelay12W, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Idelay13WAdr:
		status = (asynStatus) getIntegerParam(p_Idelay13W, valueSet);
		if( (valueSet[0] ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Idelay13WString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Idelay13WString, valueSet[0] , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Idelay13W, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Idelay14WAdr:
		status = (asynStatus) getIntegerParam(p_Idelay14W, valueSet);
		if( (valueSet[0] ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Idelay14WString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Idelay14WString, valueSet[0] , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Idelay14W, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Idelay15WAdr:
		status = (asynStatus) getIntegerParam(p_Idelay15W, valueSet);
		if( (valueSet[0] ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Idelay15WString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Idelay15WString, valueSet[0] , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Idelay15W, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case AdcMmcmWAdr:
		status = (asynStatus) getIntegerParam(p_AdcMmcmW, valueSet);
		if( (valueSet[0] & AdcMmcmMask) == (pFromFpga->data & AdcMmcmMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				AdcMmcmWString, (unsigned ) pFromFpga->data & AdcMmcmMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				AdcMmcmWString, valueSet[0] & AdcMmcmMask, (unsigned ) pFromFpga->data & AdcMmcmMask);
			status = asynError;
			setParamStatus(p_AdcMmcmW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case DigCfgU15SpiDataAddrRWAdr:
		status = (asynStatus) getIntegerParam(p_DigCfgU15SpiDataAddrRW, valueSet);
		if( (valueSet[0] & DigCfgU15SpiDataAddrRMask) == (pFromFpga->data & DigCfgU15SpiDataAddrRMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigCfgU15SpiDataAddrRWString, (unsigned ) pFromFpga->data & DigCfgU15SpiDataAddrRMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				DigCfgU15SpiDataAddrRWString, valueSet[0] & DigCfgU15SpiDataAddrRMask, (unsigned ) pFromFpga->data & DigCfgU15SpiDataAddrRMask);
			status = asynError;
			setParamStatus(p_DigCfgU15SpiDataAddrRW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case DigCfgU15SpiReadAndStartRWAdr:
		status = (asynStatus) getIntegerParam(p_DigCfgU15SpiReadAndStartRW, valueSet);
		if( (valueSet[0] & DigCfgU15SpiReadAndStartRMask) == (pFromFpga->data & DigCfgU15SpiReadAndStartRMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigCfgU15SpiReadAndStartRWString, (unsigned ) pFromFpga->data & DigCfgU15SpiReadAndStartRMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				DigCfgU15SpiReadAndStartRWString, valueSet[0] & DigCfgU15SpiReadAndStartRMask, (unsigned ) pFromFpga->data & DigCfgU15SpiReadAndStartRMask);
			status = asynError;
			setParamStatus(p_DigCfgU15SpiReadAndStartRW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case DigCfgU18SpiDataAddrRWAdr:
		status = (asynStatus) getIntegerParam(p_DigCfgU18SpiDataAddrRW, valueSet);
		if( (valueSet[0] & DigCfgU18SpiDataAddrRMask) == (pFromFpga->data & DigCfgU18SpiDataAddrRMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigCfgU18SpiDataAddrRWString, (unsigned ) pFromFpga->data & DigCfgU18SpiDataAddrRMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				DigCfgU18SpiDataAddrRWString, valueSet[0] & DigCfgU18SpiDataAddrRMask, (unsigned ) pFromFpga->data & DigCfgU18SpiDataAddrRMask);
			status = asynError;
			setParamStatus(p_DigCfgU18SpiDataAddrRW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case DigCfgU18SpiReadAndStartRWAdr:
		status = (asynStatus) getIntegerParam(p_DigCfgU18SpiReadAndStartRW, valueSet);
		if( (valueSet[0] & DigCfgU18SpiReadAndStartRMask) == (pFromFpga->data & DigCfgU18SpiReadAndStartRMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigCfgU18SpiReadAndStartRWString, (unsigned ) pFromFpga->data & DigCfgU18SpiReadAndStartRMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				DigCfgU18SpiReadAndStartRWString, valueSet[0] & DigCfgU18SpiReadAndStartRMask, (unsigned ) pFromFpga->data & DigCfgU18SpiReadAndStartRMask);
			status = asynError;
			setParamStatus(p_DigCfgU18SpiReadAndStartRW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case DigCfgU2ClkResetRWAdr:
		status = (asynStatus) getIntegerParam(p_DigCfgU2ClkResetRW, valueSet);
		if( (valueSet[0] & DigCfgU2ClkResetRMask) == (pFromFpga->data & DigCfgU2ClkResetRMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigCfgU2ClkResetRWString, (unsigned ) pFromFpga->data & DigCfgU2ClkResetRMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				DigCfgU2ClkResetRWString, valueSet[0] & DigCfgU2ClkResetRMask, (unsigned ) pFromFpga->data & DigCfgU2ClkResetRMask);
			status = asynError;
			setParamStatus(p_DigCfgU2ClkResetRW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case DigCfgU2IserdesResetRWAdr:
		status = (asynStatus) getIntegerParam(p_DigCfgU2IserdesResetRW, valueSet);
		if( (valueSet[0] & DigCfgU2IserdesResetRMask) == (pFromFpga->data & DigCfgU2IserdesResetRMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigCfgU2IserdesResetRWString, (unsigned ) pFromFpga->data & DigCfgU2IserdesResetRMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				DigCfgU2IserdesResetRWString, valueSet[0] & DigCfgU2IserdesResetRMask, (unsigned ) pFromFpga->data & DigCfgU2IserdesResetRMask);
			status = asynError;
			setParamStatus(p_DigCfgU2IserdesResetRW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case DigCfgU3ClkResetRWAdr:
		status = (asynStatus) getIntegerParam(p_DigCfgU3ClkResetRW, valueSet);
		if( (valueSet[0] & DigCfgU3ClkResetRMask) == (pFromFpga->data & DigCfgU3ClkResetRMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigCfgU3ClkResetRWString, (unsigned ) pFromFpga->data & DigCfgU3ClkResetRMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				DigCfgU3ClkResetRWString, valueSet[0] & DigCfgU3ClkResetRMask, (unsigned ) pFromFpga->data & DigCfgU3ClkResetRMask);
			status = asynError;
			setParamStatus(p_DigCfgU3ClkResetRW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case DigCfgU3IserdesResetRWAdr:
		status = (asynStatus) getIntegerParam(p_DigCfgU3IserdesResetRW, valueSet);
		if( (valueSet[0] & DigCfgU3IserdesResetRMask) == (pFromFpga->data & DigCfgU3IserdesResetRMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigCfgU3IserdesResetRWString, (unsigned ) pFromFpga->data & DigCfgU3IserdesResetRMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				DigCfgU3IserdesResetRWString, valueSet[0] & DigCfgU3IserdesResetRMask, (unsigned ) pFromFpga->data & DigCfgU3IserdesResetRMask);
			status = asynError;
			setParamStatus(p_DigCfgU3IserdesResetRW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case DigCfgU4ResetRWAdr:
		status = (asynStatus) getIntegerParam(p_DigCfgU4ResetRW, valueSet);
		if( (valueSet[0] & DigCfgU4ResetRMask) == (pFromFpga->data & DigCfgU4ResetRMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigCfgU4ResetRWString, (unsigned ) pFromFpga->data & DigCfgU4ResetRMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				DigCfgU4ResetRWString, valueSet[0] & DigCfgU4ResetRMask, (unsigned ) pFromFpga->data & DigCfgU4ResetRMask);
			status = asynError;
			setParamStatus(p_DigCfgU4ResetRW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case DigCfgBanyanMaskWAdr:
		status = (asynStatus) getIntegerParam(p_DigCfgBanyanMaskW, valueSet);
		if( (valueSet[0] & DigCfgBanyanMaskMask) == (pFromFpga->data & DigCfgBanyanMaskMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigCfgBanyanMaskWString, (unsigned ) pFromFpga->data & DigCfgBanyanMaskMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				DigCfgBanyanMaskWString, valueSet[0] & DigCfgBanyanMaskMask, (unsigned ) pFromFpga->data & DigCfgBanyanMaskMask);
			status = asynError;
			setParamStatus(p_DigCfgBanyanMaskW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case DigCfgBitslipWAdr:
		status = (asynStatus) getIntegerParam(p_DigCfgBitslipW, valueSet);
		if( (valueSet[0] & DigCfgBitslipMask) == (pFromFpga->data & DigCfgBitslipMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigCfgBitslipWString, (unsigned ) pFromFpga->data & DigCfgBitslipMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				DigCfgBitslipWString, valueSet[0] & DigCfgBitslipMask, (unsigned ) pFromFpga->data & DigCfgBitslipMask);
			status = asynError;
			setParamStatus(p_DigCfgBitslipW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case DigCfgIdelayctrlResetRWAdr:
		status = (asynStatus) getIntegerParam(p_DigCfgIdelayctrlResetRW, valueSet);
		if( (valueSet[0] & DigCfgIdelayctrlResetRMask) == (pFromFpga->data & DigCfgIdelayctrlResetRMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigCfgIdelayctrlResetRWString, (unsigned ) pFromFpga->data & DigCfgIdelayctrlResetRMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				DigCfgIdelayctrlResetRWString, valueSet[0] & DigCfgIdelayctrlResetRMask, (unsigned ) pFromFpga->data & DigCfgIdelayctrlResetRMask);
			status = asynError;
			setParamStatus(p_DigCfgIdelayctrlResetRW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case DigCfgLlspiWeWAdr:
		status = (asynStatus) getIntegerParam(p_DigCfgLlspiWeW, valueSet);
		if( (valueSet[0] & DigCfgLlspiWeMask) == (pFromFpga->data & DigCfgLlspiWeMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigCfgLlspiWeWString, (unsigned ) pFromFpga->data & DigCfgLlspiWeMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				DigCfgLlspiWeWString, valueSet[0] & DigCfgLlspiWeMask, (unsigned ) pFromFpga->data & DigCfgLlspiWeMask);
			status = asynError;
			setParamStatus(p_DigCfgLlspiWeW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case DigCfgMmcmResetRWAdr:
		status = (asynStatus) getIntegerParam(p_DigCfgMmcmResetRW, valueSet);
		if( (valueSet[0] & DigCfgMmcmResetRMask) == (pFromFpga->data & DigCfgMmcmResetRMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigCfgMmcmResetRWString, (unsigned ) pFromFpga->data & DigCfgMmcmResetRMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				DigCfgMmcmResetRWString, valueSet[0] & DigCfgMmcmResetRMask, (unsigned ) pFromFpga->data & DigCfgMmcmResetRMask);
			status = asynError;
			setParamStatus(p_DigCfgMmcmResetRW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case DigCfgPeriphConfigWAdr:
		status = (asynStatus) getIntegerParam(p_DigCfgPeriphConfigW, valueSet);
		if( (valueSet[0] & DigCfgPeriphConfigMask) == (pFromFpga->data & DigCfgPeriphConfigMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigCfgPeriphConfigWString, (unsigned ) pFromFpga->data & DigCfgPeriphConfigMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				DigCfgPeriphConfigWString, valueSet[0] & DigCfgPeriphConfigMask, (unsigned ) pFromFpga->data & DigCfgPeriphConfigMask);
			status = asynError;
			setParamStatus(p_DigCfgPeriphConfigW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case DigCfgPhasexTrigWAdr:
		status = (asynStatus) getIntegerParam(p_DigCfgPhasexTrigW, valueSet);
		if( (valueSet[0] & DigCfgPhasexTrigMask) == (pFromFpga->data & DigCfgPhasexTrigMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigCfgPhasexTrigWString, (unsigned ) pFromFpga->data & DigCfgPhasexTrigMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				DigCfgPhasexTrigWString, valueSet[0] & DigCfgPhasexTrigMask, (unsigned ) pFromFpga->data & DigCfgPhasexTrigMask);
			status = asynError;
			setParamStatus(p_DigCfgPhasexTrigW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case DigCfgRawadcTrigWAdr:
		status = (asynStatus) getIntegerParam(p_DigCfgRawadcTrigW, valueSet);
		if( (valueSet[0] & DigCfgRawadcTrigMask) == (pFromFpga->data & DigCfgRawadcTrigMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigCfgRawadcTrigWString, (unsigned ) pFromFpga->data & DigCfgRawadcTrigMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				DigCfgRawadcTrigWString, valueSet[0] & DigCfgRawadcTrigMask, (unsigned ) pFromFpga->data & DigCfgRawadcTrigMask);
			status = asynError;
			setParamStatus(p_DigCfgRawadcTrigW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case DigCfgScanTriggerWeWAdr:
		status = (asynStatus) getIntegerParam(p_DigCfgScanTriggerWeW, valueSet);
		if( (valueSet[0] & DigCfgScanTriggerWeMask) == (pFromFpga->data & DigCfgScanTriggerWeMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigCfgScanTriggerWeWString, (unsigned ) pFromFpga->data & DigCfgScanTriggerWeMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				DigCfgScanTriggerWeWString, valueSet[0] & DigCfgScanTriggerWeMask, (unsigned ) pFromFpga->data & DigCfgScanTriggerWeMask);
			status = asynError;
			setParamStatus(p_DigCfgScanTriggerWeW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case DigCfgScannerDebugWAdr:
		status = (asynStatus) getIntegerParam(p_DigCfgScannerDebugW, valueSet);
		if( (valueSet[0] & DigCfgScannerDebugMask) == (pFromFpga->data & DigCfgScannerDebugMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigCfgScannerDebugWString, (unsigned ) pFromFpga->data & DigCfgScannerDebugMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				DigCfgScannerDebugWString, valueSet[0] & DigCfgScannerDebugMask, (unsigned ) pFromFpga->data & DigCfgScannerDebugMask);
			status = asynError;
			setParamStatus(p_DigCfgScannerDebugW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case DigCfgSyncAd7794CsetWAdr:
		status = (asynStatus) getIntegerParam(p_DigCfgSyncAd7794CsetW, valueSet);
		if( (valueSet[0] & DigCfgSyncAd7794CsetMask) == (pFromFpga->data & DigCfgSyncAd7794CsetMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigCfgSyncAd7794CsetWString, (unsigned ) pFromFpga->data & DigCfgSyncAd7794CsetMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				DigCfgSyncAd7794CsetWString, valueSet[0] & DigCfgSyncAd7794CsetMask, (unsigned ) pFromFpga->data & DigCfgSyncAd7794CsetMask);
			status = asynError;
			setParamStatus(p_DigCfgSyncAd7794CsetW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case DigCfgSyncTps62210CsetWAdr:
		status = (asynStatus) getIntegerParam(p_DigCfgSyncTps62210CsetW, valueSet);
		if( (valueSet[0] & DigCfgSyncTps62210CsetMask) == (pFromFpga->data & DigCfgSyncTps62210CsetMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigCfgSyncTps62210CsetWString, (unsigned ) pFromFpga->data & DigCfgSyncTps62210CsetMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				DigCfgSyncTps62210CsetWString, valueSet[0] & DigCfgSyncTps62210CsetMask, (unsigned ) pFromFpga->data & DigCfgSyncTps62210CsetMask);
			status = asynError;
			setParamStatus(p_DigCfgSyncTps62210CsetW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case DigDspAdcTestModeWAdr:
		status = (asynStatus) getIntegerParam(p_DigDspAdcTestModeW, valueSet);
		if( (valueSet[0] & DigDspAdcTestModeMask) == (pFromFpga->data & DigDspAdcTestModeMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspAdcTestModeWString, (unsigned ) pFromFpga->data & DigDspAdcTestModeMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspAdcTestModeWString, valueSet[0] & DigDspAdcTestModeMask, (unsigned ) pFromFpga->data & DigDspAdcTestModeMask);
			status = asynError;
			setParamStatus(p_DigDspAdcTestModeW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case DigDspAdcTestResetWAdr:
		status = (asynStatus) getIntegerParam(p_DigDspAdcTestResetW, valueSet);
		if( (valueSet[0] & DigDspAdcTestResetMask) == (pFromFpga->data & DigDspAdcTestResetMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspAdcTestResetWString, (unsigned ) pFromFpga->data & DigDspAdcTestResetMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspAdcTestResetWString, valueSet[0] & DigDspAdcTestResetMask, (unsigned ) pFromFpga->data & DigDspAdcTestResetMask);
			status = asynError;
			setParamStatus(p_DigDspAdcTestResetW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case DigDspAmplitudeWAdr:
		status = (asynStatus) getIntegerParam(p_DigDspAmplitudeW, valueSet);
		if( (valueSet[0] & DigDspAmplitudeMask) == (pFromFpga->data & DigDspAmplitudeMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspAmplitudeWString, (unsigned ) pFromFpga->data & DigDspAmplitudeMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspAmplitudeWString, valueSet[0] & DigDspAmplitudeMask, (unsigned ) pFromFpga->data & DigDspAmplitudeMask);
			status = asynError;
			setParamStatus(p_DigDspAmplitudeW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case DigDspAverageLenWAdr:
		status = (asynStatus) getIntegerParam(p_DigDspAverageLenW, valueSet);
		if( (valueSet[0] & DigDspAverageLenMask) == (pFromFpga->data & DigDspAverageLenMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspAverageLenWString, (unsigned ) pFromFpga->data & DigDspAverageLenMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspAverageLenWString, valueSet[0] & DigDspAverageLenMask, (unsigned ) pFromFpga->data & DigDspAverageLenMask);
			status = asynError;
			setParamStatus(p_DigDspAverageLenW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case DigDspBufTrigWAdr:
		status = (asynStatus) getIntegerParam(p_DigDspBufTrigW, valueSet);
		if( (valueSet[0] & DigDspBufTrigMask) == (pFromFpga->data & DigDspBufTrigMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspBufTrigWString, (unsigned ) pFromFpga->data & DigDspBufTrigMask);
		else
		{
			// We don't care, since this is typically part of a canned sequence of writes
		}

		break;
    case DigDspCicPeriodWAdr:
		status = (asynStatus) getIntegerParam(p_DigDspCicPeriodW, valueSet);
		if( (valueSet[0] & DigDspCicPeriodMask) == (pFromFpga->data & DigDspCicPeriodMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspCicPeriodWString, (unsigned ) pFromFpga->data & DigDspCicPeriodMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspCicPeriodWString, valueSet[0] & DigDspCicPeriodMask, (unsigned ) pFromFpga->data & DigDspCicPeriodMask);
			status = asynError;
			setParamStatus(p_DigDspCicPeriodW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case DigDspCicShiftWAdr:
		status = (asynStatus) getIntegerParam(p_DigDspCicShiftW, valueSet);
		if( (valueSet[0] & DigDspCicShiftMask) == (pFromFpga->data & DigDspCicShiftMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspCicShiftWString, (unsigned ) pFromFpga->data & DigDspCicShiftMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspCicShiftWString, valueSet[0] & DigDspCicShiftMask, (unsigned ) pFromFpga->data & DigDspCicShiftMask);
			status = asynError;
			setParamStatus(p_DigDspCicShiftW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case DigDspDacDdsResetWAdr:
		status = (asynStatus) getIntegerParam(p_DigDspDacDdsResetW, valueSet);
		if( (valueSet[0] & DigDspDacDdsResetMask) == (pFromFpga->data & DigDspDacDdsResetMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspDacDdsResetWString, (unsigned ) pFromFpga->data & DigDspDacDdsResetMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspDacDdsResetWString, valueSet[0] & DigDspDacDdsResetMask, (unsigned ) pFromFpga->data & DigDspDacDdsResetMask);
			status = asynError;
			setParamStatus(p_DigDspDacDdsResetW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case DigDspDacModeWAdr:
		status = (asynStatus) getIntegerParam(p_DigDspDacModeW, valueSet);
		if( (valueSet[0] & DigDspDacModeMask) == (pFromFpga->data & DigDspDacModeMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspDacModeWString, (unsigned ) pFromFpga->data & DigDspDacModeMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspDacModeWString, valueSet[0] & DigDspDacModeMask, (unsigned ) pFromFpga->data & DigDspDacModeMask);
			status = asynError;
			setParamStatus(p_DigDspDacModeW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case DigDspDdsaModuloWAdr:
		status = (asynStatus) getIntegerParam(p_DigDspDdsaModuloW, valueSet);
		if( (valueSet[0] & DigDspDdsaModuloMask) == (pFromFpga->data & DigDspDdsaModuloMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspDdsaModuloWString, (unsigned ) pFromFpga->data & DigDspDdsaModuloMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspDdsaModuloWString, valueSet[0] & DigDspDdsaModuloMask, (unsigned ) pFromFpga->data & DigDspDdsaModuloMask);
			status = asynError;
			setParamStatus(p_DigDspDdsaModuloW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case DigDspDdsaPhstepHWAdr:
		status = (asynStatus) getIntegerParam(p_DigDspDdsaPhstepHW, valueSet);
		if( (valueSet[0] & DigDspDdsaPhstepHMask) == (pFromFpga->data & DigDspDdsaPhstepHMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspDdsaPhstepHWString, (unsigned ) pFromFpga->data & DigDspDdsaPhstepHMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspDdsaPhstepHWString, valueSet[0] & DigDspDdsaPhstepHMask, (unsigned ) pFromFpga->data & DigDspDdsaPhstepHMask);
			status = asynError;
			setParamStatus(p_DigDspDdsaPhstepHW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case DigDspDdsaPhstepLWAdr:
		status = (asynStatus) getIntegerParam(p_DigDspDdsaPhstepLW, valueSet);
		if( (valueSet[0] & DigDspDdsaPhstepLMask) == (pFromFpga->data & DigDspDdsaPhstepLMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspDdsaPhstepLWString, (unsigned ) pFromFpga->data & DigDspDdsaPhstepLMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspDdsaPhstepLWString, valueSet[0] & DigDspDdsaPhstepLMask, (unsigned ) pFromFpga->data & DigDspDdsaPhstepLMask);
			status = asynError;
			setParamStatus(p_DigDspDdsaPhstepLW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case DigDspHistCountWStrobeWAdr:
		status = (asynStatus) getIntegerParam(p_DigDspHistCountWStrobeW, valueSet);
		if( (valueSet[0] & DigDspHistCountWStrobeMask) == (pFromFpga->data & DigDspHistCountWStrobeMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspHistCountWStrobeWString, (unsigned ) pFromFpga->data & DigDspHistCountWStrobeMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspHistCountWStrobeWString, valueSet[0] & DigDspHistCountWStrobeMask, (unsigned ) pFromFpga->data & DigDspHistCountWStrobeMask);
			status = asynError;
			setParamStatus(p_DigDspHistCountWStrobeW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case DigDspLoAmpWAdr:
		status = (asynStatus) getIntegerParam(p_DigDspLoAmpW, valueSet);
		if( (valueSet[0] & DigDspLoAmpMask) == (pFromFpga->data & DigDspLoAmpMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspLoAmpWString, (unsigned ) pFromFpga->data & DigDspLoAmpMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspLoAmpWString, valueSet[0] & DigDspLoAmpMask, (unsigned ) pFromFpga->data & DigDspLoAmpMask);
			status = asynError;
			setParamStatus(p_DigDspLoAmpW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case DigDspModuloWAdr:
		status = (asynStatus) getIntegerParam(p_DigDspModuloW, valueSet);
		if( (valueSet[0] & DigDspModuloMask) == (pFromFpga->data & DigDspModuloMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspModuloWString, (unsigned ) pFromFpga->data & DigDspModuloMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspModuloWString, valueSet[0] & DigDspModuloMask, (unsigned ) pFromFpga->data & DigDspModuloMask);
			status = asynError;
			setParamStatus(p_DigDspModuloW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case DigDspPhaseStepHWAdr:
		status = (asynStatus) getIntegerParam(p_DigDspPhaseStepHW, valueSet);
		if( (valueSet[0] & DigDspPhaseStepHMask) == (pFromFpga->data & DigDspPhaseStepHMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspPhaseStepHWString, (unsigned ) pFromFpga->data & DigDspPhaseStepHMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspPhaseStepHWString, valueSet[0] & DigDspPhaseStepHMask, (unsigned ) pFromFpga->data & DigDspPhaseStepHMask);
			status = asynError;
			setParamStatus(p_DigDspPhaseStepHW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case DigDspPhaseStepLWAdr:
		status = (asynStatus) getIntegerParam(p_DigDspPhaseStepLW, valueSet);
		if( (valueSet[0] & DigDspPhaseStepLMask) == (pFromFpga->data & DigDspPhaseStepLMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspPhaseStepLWString, (unsigned ) pFromFpga->data & DigDspPhaseStepLMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspPhaseStepLWString, valueSet[0] & DigDspPhaseStepLMask, (unsigned ) pFromFpga->data & DigDspPhaseStepLMask);
			status = asynError;
			setParamStatus(p_DigDspPhaseStepLW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case DigDspRewindWAdr:
		status = (asynStatus) getIntegerParam(p_DigDspRewindW, valueSet);
		if( (valueSet[0] & DigDspRewindMask) == (pFromFpga->data & DigDspRewindMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspRewindWString, (unsigned ) pFromFpga->data & DigDspRewindMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspRewindWString, valueSet[0] & DigDspRewindMask, (unsigned ) pFromFpga->data & DigDspRewindMask);
			status = asynError;
			setParamStatus(p_DigDspRewindW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case DigDspSsaStimAmpstepWAdr:
		status = (asynStatus) getIntegerParam(p_DigDspSsaStimAmpstepW, valueSet);
		if( (valueSet[0] & DigDspSsaStimAmpstepMask) == (pFromFpga->data & DigDspSsaStimAmpstepMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspSsaStimAmpstepWString, (unsigned ) pFromFpga->data & DigDspSsaStimAmpstepMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspSsaStimAmpstepWString, valueSet[0] & DigDspSsaStimAmpstepMask, (unsigned ) pFromFpga->data & DigDspSsaStimAmpstepMask);
			status = asynError;
			setParamStatus(p_DigDspSsaStimAmpstepW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case DigDspSsaStimEnWAdr:
		status = (asynStatus) getIntegerParam(p_DigDspSsaStimEnW, valueSet);
		if( (valueSet[0] & DigDspSsaStimEnMask) == (pFromFpga->data & DigDspSsaStimEnMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspSsaStimEnWString, (unsigned ) pFromFpga->data & DigDspSsaStimEnMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspSsaStimEnWString, valueSet[0] & DigDspSsaStimEnMask, (unsigned ) pFromFpga->data & DigDspSsaStimEnMask);
			status = asynError;
			setParamStatus(p_DigDspSsaStimEnW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case DigDspSsaStimGPeriodWAdr:
		status = (asynStatus) getIntegerParam(p_DigDspSsaStimGPeriodW, valueSet);
		if( (valueSet[0] & DigDspSsaStimGPeriodMask) == (pFromFpga->data & DigDspSsaStimGPeriodMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspSsaStimGPeriodWString, (unsigned ) pFromFpga->data & DigDspSsaStimGPeriodMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspSsaStimGPeriodWString, valueSet[0] & DigDspSsaStimGPeriodMask, (unsigned ) pFromFpga->data & DigDspSsaStimGPeriodMask);
			status = asynError;
			setParamStatus(p_DigDspSsaStimGPeriodW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case DigDspSsaStimPertstepWAdr:
		status = (asynStatus) getIntegerParam(p_DigDspSsaStimPertstepW, valueSet);
		if( (valueSet[0] & DigDspSsaStimPertstepMask) == (pFromFpga->data & DigDspSsaStimPertstepMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspSsaStimPertstepWString, (unsigned ) pFromFpga->data & DigDspSsaStimPertstepMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspSsaStimPertstepWString, valueSet[0] & DigDspSsaStimPertstepMask, (unsigned ) pFromFpga->data & DigDspSsaStimPertstepMask);
			status = asynError;
			setParamStatus(p_DigDspSsaStimPertstepW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case DigDspTraceKeepWAdr:
		status = (asynStatus) getIntegerParam(p_DigDspTraceKeepW, valueSet);
		if( (valueSet[0] & DigDspTraceKeepMask) == (pFromFpga->data & DigDspTraceKeepMask))
		{		// Count the number of bits set
			tmpData = (pFromFpga->data & DigDspTraceKeepMask);
			for (nchan_ = 0; tmpData; nchan_++)
			{
			  tmpData &= tmpData - 1; // clear the least significant bit set
			}
			setIntegerParam(p_IQNActive, nchan_);
		    printf("%s TraceKeepWAdr says %d active channels\n",__PRETTY_FUNCTION__,nchan_);

			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspTraceKeepWString, (unsigned ) pFromFpga->data & DigDspTraceKeepMask);
		}
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspTraceKeepWString, valueSet[0] & DigDspTraceKeepMask, (unsigned ) pFromFpga->data & DigDspTraceKeepMask);
			status = asynError;
			setParamStatus(p_DigDspTraceKeepW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case DigDspTraceResetWeWAdr:
		status = (asynStatus) getIntegerParam(p_DigDspTraceResetWeW, valueSet);
		if( (valueSet[0] & DigDspTraceResetWeMask) == (pFromFpga->data & DigDspTraceResetWeMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspTraceResetWeWString, (unsigned ) pFromFpga->data & DigDspTraceResetWeMask);
		else
		{
			// We don't care, since there are typically several writes to this per message: 0, 1, 0
		}

		break;
    case DigDspTrigInternalWAdr:
		status = (asynStatus) getIntegerParam(p_DigDspTrigInternalW, valueSet);
		if( (valueSet[0] & DigDspTrigInternalMask) == (pFromFpga->data & DigDspTrigInternalMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspTrigInternalWString, (unsigned ) pFromFpga->data & DigDspTrigInternalMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspTrigInternalWString, valueSet[0] & DigDspTrigInternalMask, (unsigned ) pFromFpga->data & DigDspTrigInternalMask);
			status = asynError;
			setParamStatus(p_DigDspTrigInternalW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case DigDspTrigModeWAdr:
		status = (asynStatus) getIntegerParam(p_DigDspTrigModeW, valueSet);
		if( (valueSet[0] & DigDspTrigModeMask) == (pFromFpga->data & DigDspTrigModeMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspTrigModeWString, (unsigned ) pFromFpga->data & DigDspTrigModeMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspTrigModeWString, valueSet[0] & DigDspTrigModeMask, (unsigned ) pFromFpga->data & DigDspTrigModeMask);
			status = asynError;
			setParamStatus(p_DigDspTrigModeW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case DigDspWave0SrcWAdr:
		status = (asynStatus) getIntegerParam(p_DigDspWave0SrcW, valueSet);
		if( (valueSet[0] & DigDspWave0SrcMask) == (pFromFpga->data & DigDspWave0SrcMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspWave0SrcWString, (unsigned ) pFromFpga->data & DigDspWave0SrcMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspWave0SrcWString, valueSet[0] & DigDspWave0SrcMask, (unsigned ) pFromFpga->data & DigDspWave0SrcMask);
			status = asynError;
			setParamStatus(p_DigDspWave0SrcW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case DigDspWave1SrcWAdr:
		status = (asynStatus) getIntegerParam(p_DigDspWave1SrcW, valueSet);
		if( (valueSet[0] & DigDspWave1SrcMask) == (pFromFpga->data & DigDspWave1SrcMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspWave1SrcWString, (unsigned ) pFromFpga->data & DigDspWave1SrcMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				DigDspWave1SrcWString, valueSet[0] & DigDspWave1SrcMask, (unsigned ) pFromFpga->data & DigDspWave1SrcMask);
			status = asynError;
			setParamStatus(p_DigDspWave1SrcW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case DigSlowreadTagNowWAdr:
		status = (asynStatus) getIntegerParam(p_DigSlowreadTagNowW, valueSet);
		if( (valueSet[0] & DigSlowreadTagNowMask) == (pFromFpga->data & DigSlowreadTagNowMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigSlowreadTagNowWString, (unsigned ) pFromFpga->data & DigSlowreadTagNowMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				DigSlowreadTagNowWString, valueSet[0] & DigSlowreadTagNowMask, (unsigned ) pFromFpga->data & DigSlowreadTagNowMask);
			status = asynError;
			setParamStatus(p_DigSlowreadTagNowW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case IccCfgWAdr:
		status = (asynStatus) getIntegerParam(p_IccCfgW, valueSet);
		if( (valueSet[0] & IccCfgMask) == (pFromFpga->data & IccCfgMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				IccCfgWString, (unsigned ) pFromFpga->data & IccCfgMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				IccCfgWString, valueSet[0] & IccCfgMask, (unsigned ) pFromFpga->data & IccCfgMask);
			status = asynError;
			setParamStatus(p_IccCfgW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case QsfpI2CRegWAdr:
		status = (asynStatus) getIntegerParam(p_QsfpI2CRegW, valueSet);
		if( (valueSet[0] & QsfpI2CRegMask) == (pFromFpga->data & QsfpI2CRegMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				QsfpI2CRegWString, (unsigned ) pFromFpga->data & QsfpI2CRegMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				QsfpI2CRegWString, valueSet[0] & QsfpI2CRegMask, (unsigned ) pFromFpga->data & QsfpI2CRegMask);
			status = asynError;
			setParamStatus(p_QsfpI2CRegW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case SfpAddressSetWAdr:
		status = (asynStatus) getIntegerParam(p_SfpAddressSetW, valueSet);
		if( (valueSet[0] & SfpAddressSetMask) == (pFromFpga->data & SfpAddressSetMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				SfpAddressSetWString, (unsigned ) pFromFpga->data & SfpAddressSetMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				SfpAddressSetWString, valueSet[0] & SfpAddressSetMask, (unsigned ) pFromFpga->data & SfpAddressSetMask);
			status = asynError;
			setParamStatus(p_SfpAddressSetW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
	default:
// TODO: Add checking for arrays. Until then, we'll hit "default" for array values, so not really an error. GWB 8-23-2016
//		getIntegerParam(p_CommErrorCount, &errorCount);
//		setIntegerParam(p_CommErrorCount, errorCount + 1);
		printf("Unmapped register 0x%x %d\n", pFromFpga->addr, pFromFpga->data);
	
		getIntegerParam(p_CommErrorCount, &errorCount);
		setIntegerParam(p_CommErrorCount, ++errorCount);

		status = asynError;
		break;
    }

	// TODO: handle arrays

    return status;
}



extern "C" {

/* Configuration routine.  Called directly, or from the iocsh function below */

/** EPICS iocsh callable function to call constructor for the scllrfPRC class.
 * \param[in] portName The name of the asyn port driver to be created.
 * \param[in] netPortName The name of the asynIPport this will use to communicate */
int scllrfPRCConfigure(const char *drvPortName, const char *netPortName)
{
	new scllrfPRC(drvPortName, netPortName);
	return asynSuccess;
}


/* EPICS iocsh shell commands */

static const iocshArg initArg0 = { "drvPortName",iocshArgString};
static const iocshArg initArg1 = { "IP port name",iocshArgString};
static const iocshArg * const initArgs[] = {&initArg0,
		&initArg1};
static const iocshFuncDef initFuncDef = {"scllrfPRCConfigure",2,initArgs};
static void initCallFunc(const iocshArgBuf *args)
{
	scllrfPRCConfigure(args[0].sval, args[1].sval);
}

void scllrfPRCRegister(void)
{
	iocshRegister(&initFuncDef,initCallFunc);
}

epicsExportRegistrar(scllrfPRCRegister);

}




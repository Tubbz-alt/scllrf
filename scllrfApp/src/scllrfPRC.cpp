/**
 *-----------------------------------------------------------------------------
 * Title      : superconducting low level RF EPICS interface
 * ----------------------------------------------------------------------------
 * File       : scllrfPRCDriver.h
 * Author     : Garth Brown, gwbrown@slac.stanford.edu
 * Created    : June 17, 2016
 * Last update: September 6, 2016
 * ----------------------------------------------------------------------------
 * Description:
 * Header defining register interface to scllrfPRC, autogenerated from a python
 * dictionary.
 *
 * ----------------------------------------------------------------------------
 * This file is part of LCLS II. It is subject to
 * the license terms in the LICENSE.txt file found in the top-level directory
 * of this distribution and at:
    * https://confluence.slac.stanford.edu/display/ppareg/LICENSE.html.
 * No part of LCLS II, including this file, may be
 * copied, modified, propagated, or distributed except according to the terms
 * contained in the LICENSE.txt file.
 * ----------------------------------------------------------------------------
**/

#include "scllrfPRC.h"
#include <asynOctetSyncIO.h>
#include <asynCommonSyncIO.h>
#include <limits>
#include <netinet/in.h>
#include <iostream>
using namespace std;
#include <math.h>

/* Register names */
const char *scllrfPRCDriver::U15SpiRdbkRString = "U15_SPI_RDBK_R";
const char *scllrfPRCDriver::U15SpiStatusRString = "U15_SPI_STATUS_R";
const char *scllrfPRCDriver::U18SpiRdbkRString = "U18_SPI_RDBK_R";
const char *scllrfPRCDriver::U18SpiStatusRString = "U18_SPI_STATUS_R";
const char *scllrfPRCDriver::U2DoutLsbRString = "U2DOUT_LSB_R";
const char *scllrfPRCDriver::U2DoutMsbRString = "U2DOUT_MSB_R";
const char *scllrfPRCDriver::U3DoutLsbRString = "U3DOUT_LSB_R";
const char *scllrfPRCDriver::U3DoutMsbRString = "U3DOUT_MSB_R";
const char *scllrfPRCDriver::AdcMmcmRString = "ADC_MMCM_R";
const char *scllrfPRCDriver::AdcMmcmWString = "ADC_MMCM_W";
const char *scllrfPRCDriver::AdcTestModeRString = "ADC_TEST_MODE_R";
const char *scllrfPRCDriver::AdcTestModeWString = "ADC_TEST_MODE_W";
const char *scllrfPRCDriver::AdcTestResetRString = "ADC_TEST_RESET_R";
const char *scllrfPRCDriver::AdcTestResetWString = "ADC_TEST_RESET_W";
const char *scllrfPRCDriver::AdcTestTrigCntRString = "ADC_TEST_TRIG_CNT_R";
const char *scllrfPRCDriver::AdcTestWave1OutRString = "ADC_TEST_WAVE1_OUT_R";
const char *scllrfPRCDriver::AdcTestWave2OutRString = "ADC_TEST_WAVE2_OUT_R";
const char *scllrfPRCDriver::AdcTestWave3OutRString = "ADC_TEST_WAVE3_OUT_R";
const char *scllrfPRCDriver::AdcTestWave4OutRString = "ADC_TEST_WAVE4_OUT_R";
const char *scllrfPRCDriver::AmplitudeRString = "AMPLITUDE_R";
const char *scllrfPRCDriver::AmplitudeWString = "AMPLITUDE_W";
const char *scllrfPRCDriver::AverageLenRString = "AVERAGE_LEN_R";
const char *scllrfPRCDriver::AverageLenWString = "AVERAGE_LEN_W";
const char *scllrfPRCDriver::BanyanBufRString = "BANYAN_BUF_R";
const char *scllrfPRCDriver::BanyanStatusRString = "BANYAN_STATUS_R";
const char *scllrfPRCDriver::Beam0ModuloRString = "BEAM_0_MODULO_R";
const char *scllrfPRCDriver::Beam0ModuloWString = "BEAM_0_MODULO_W";
const char *scllrfPRCDriver::Beam0PhaseInitRString = "BEAM_0_PHASE_INIT_R";
const char *scllrfPRCDriver::Beam0PhaseInitWString = "BEAM_0_PHASE_INIT_W";
const char *scllrfPRCDriver::Beam0PhaseStepRString = "BEAM_0_PHASE_STEP_R";
const char *scllrfPRCDriver::Beam0PhaseStepWString = "BEAM_0_PHASE_STEP_W";
const char *scllrfPRCDriver::Beam1ModuloRString = "BEAM_1_MODULO_R";
const char *scllrfPRCDriver::Beam1ModuloWString = "BEAM_1_MODULO_W";
const char *scllrfPRCDriver::Beam1PhaseInitRString = "BEAM_1_PHASE_INIT_R";
const char *scllrfPRCDriver::Beam1PhaseInitWString = "BEAM_1_PHASE_INIT_W";
const char *scllrfPRCDriver::Beam1PhaseStepRString = "BEAM_1_PHASE_STEP_R";
const char *scllrfPRCDriver::Beam1PhaseStepWString = "BEAM_1_PHASE_STEP_W";
const char *scllrfPRCDriver::BufTrigRString = "BUF_TRIG_R";
const char *scllrfPRCDriver::BufTrigWString = "BUF_TRIG_W";
const char *scllrfPRCDriver::Cav4MechNoiseCoupleKOutWString = "CAV4_MECH_NOISE_COUPLE_K_OUT_W";
const char *scllrfPRCDriver::Cav4MechPrngIvaRString = "CAV4_MECH_PRNG_IVA_R";
const char *scllrfPRCDriver::Cav4MechPrngIvaWString = "CAV4_MECH_PRNG_IVA_W";
const char *scllrfPRCDriver::Cav4MechPrngIvbRString = "CAV4_MECH_PRNG_IVB_R";
const char *scllrfPRCDriver::Cav4MechPrngIvbWString = "CAV4_MECH_PRNG_IVB_W";
const char *scllrfPRCDriver::Cav4MechPrngRandomRunRString = "CAV4_MECH_PRNG_RANDOM_RUN_R";
const char *scllrfPRCDriver::Cav4MechPrngRandomRunWString = "CAV4_MECH_PRNG_RANDOM_RUN_W";
const char *scllrfPRCDriver::Cav4MechResonatorPropConstWString = "CAV4_MECH_RESONATOR_PROP_CONST_W";
const char *scllrfPRCDriver::Cavity0DetuneRString = "CAVITY0_DETUNE_R";
const char *scllrfPRCDriver::Cavity1DetuneRString = "CAVITY1_DETUNE_R";
const char *scllrfPRCDriver::Cavity0ACavOffsetRString = "CAVITY_0_A_CAV_OFFSET_R";
const char *scllrfPRCDriver::Cavity0ACavOffsetWString = "CAVITY_0_A_CAV_OFFSET_W";
const char *scllrfPRCDriver::Cavity0AForOffsetRString = "CAVITY_0_A_FOR_OFFSET_R";
const char *scllrfPRCDriver::Cavity0AForOffsetWString = "CAVITY_0_A_FOR_OFFSET_W";
const char *scllrfPRCDriver::Cavity0ARflOffsetRString = "CAVITY_0_A_RFL_OFFSET_R";
const char *scllrfPRCDriver::Cavity0ARflOffsetWString = "CAVITY_0_A_RFL_OFFSET_W";
const char *scllrfPRCDriver::Cavity0AmpLpBwRString = "CAVITY_0_AMP_LP_BW_R";
const char *scllrfPRCDriver::Cavity0AmpLpBwWString = "CAVITY_0_AMP_LP_BW_W";
const char *scllrfPRCDriver::Cavity0ComprSatCtlRString = "CAVITY_0_COMPR_SAT_CTL_R";
const char *scllrfPRCDriver::Cavity0ComprSatCtlWString = "CAVITY_0_COMPR_SAT_CTL_W";
const char *scllrfPRCDriver::Cavity0Dot0KOutWString = "CAVITY_0_DOT_0_K_OUT_W";
const char *scllrfPRCDriver::Cavity0Dot1KOutWString = "CAVITY_0_DOT_1_K_OUT_W";
const char *scllrfPRCDriver::Cavity0Dot2KOutWString = "CAVITY_0_DOT_2_K_OUT_W";
const char *scllrfPRCDriver::Cavity0DriveCoupleOutCouplingRString = "CAVITY_0_DRIVE_COUPLE_OUT_COUPLING_R";
const char *scllrfPRCDriver::Cavity0DriveCoupleOutCouplingWString = "CAVITY_0_DRIVE_COUPLE_OUT_COUPLING_W";
const char *scllrfPRCDriver::Cavity0DriveCoupleOutPhaseOffsetRString = "CAVITY_0_DRIVE_COUPLE_OUT_PHASE_OFFSET_R";
const char *scllrfPRCDriver::Cavity0DriveCoupleOutPhaseOffsetWString = "CAVITY_0_DRIVE_COUPLE_OUT_PHASE_OFFSET_W";
const char *scllrfPRCDriver::Cavity0Freq0CoarseFreqRString = "CAVITY_0_FREQ_0_COARSE_FREQ_R";
const char *scllrfPRCDriver::Cavity0Freq0CoarseFreqWString = "CAVITY_0_FREQ_0_COARSE_FREQ_W";
const char *scllrfPRCDriver::Cavity0Freq1CoarseFreqRString = "CAVITY_0_FREQ_1_COARSE_FREQ_R";
const char *scllrfPRCDriver::Cavity0Freq1CoarseFreqWString = "CAVITY_0_FREQ_1_COARSE_FREQ_W";
const char *scllrfPRCDriver::Cavity0Freq2CoarseFreqRString = "CAVITY_0_FREQ_2_COARSE_FREQ_R";
const char *scllrfPRCDriver::Cavity0Freq2CoarseFreqWString = "CAVITY_0_FREQ_2_COARSE_FREQ_W";
const char *scllrfPRCDriver::Cavity0Mode0BeamCouplingRString = "CAVITY_0_MODE_0_BEAM_COUPLING_R";
const char *scllrfPRCDriver::Cavity0Mode0BeamCouplingWString = "CAVITY_0_MODE_0_BEAM_COUPLING_W";
const char *scllrfPRCDriver::Cavity0Mode0BwRString = "CAVITY_0_MODE_0_BW_R";
const char *scllrfPRCDriver::Cavity0Mode0BwWString = "CAVITY_0_MODE_0_BW_W";
const char *scllrfPRCDriver::Cavity0Mode0CoupleOutCouplingRString = "CAVITY_0_MODE_0_COUPLE_OUT_COUPLING_R";
const char *scllrfPRCDriver::Cavity0Mode0CoupleOutCouplingWString = "CAVITY_0_MODE_0_COUPLE_OUT_COUPLING_W";
const char *scllrfPRCDriver::Cavity0Mode0CoupleOutPhaseOffsetRString = "CAVITY_0_MODE_0_COUPLE_OUT_PHASE_OFFSET_R";
const char *scllrfPRCDriver::Cavity0Mode0CoupleOutPhaseOffsetWString = "CAVITY_0_MODE_0_COUPLE_OUT_PHASE_OFFSET_W";
const char *scllrfPRCDriver::Cavity0Mode0DriveCouplingRString = "CAVITY_0_MODE_0_DRIVE_COUPLING_R";
const char *scllrfPRCDriver::Cavity0Mode0DriveCouplingWString = "CAVITY_0_MODE_0_DRIVE_COUPLING_W";
const char *scllrfPRCDriver::Cavity0Mode1BeamCouplingRString = "CAVITY_0_MODE_1_BEAM_COUPLING_R";
const char *scllrfPRCDriver::Cavity0Mode1BeamCouplingWString = "CAVITY_0_MODE_1_BEAM_COUPLING_W";
const char *scllrfPRCDriver::Cavity0Mode1BwRString = "CAVITY_0_MODE_1_BW_R";
const char *scllrfPRCDriver::Cavity0Mode1BwWString = "CAVITY_0_MODE_1_BW_W";
const char *scllrfPRCDriver::Cavity0Mode1CoupleOutCouplingRString = "CAVITY_0_MODE_1_COUPLE_OUT_COUPLING_R";
const char *scllrfPRCDriver::Cavity0Mode1CoupleOutCouplingWString = "CAVITY_0_MODE_1_COUPLE_OUT_COUPLING_W";
const char *scllrfPRCDriver::Cavity0Mode1CoupleOutPhaseOffsetRString = "CAVITY_0_MODE_1_COUPLE_OUT_PHASE_OFFSET_R";
const char *scllrfPRCDriver::Cavity0Mode1CoupleOutPhaseOffsetWString = "CAVITY_0_MODE_1_COUPLE_OUT_PHASE_OFFSET_W";
const char *scllrfPRCDriver::Cavity0Mode1DriveCouplingRString = "CAVITY_0_MODE_1_DRIVE_COUPLING_R";
const char *scllrfPRCDriver::Cavity0Mode1DriveCouplingWString = "CAVITY_0_MODE_1_DRIVE_COUPLING_W";
const char *scllrfPRCDriver::Cavity0Mode2BeamCouplingRString = "CAVITY_0_MODE_2_BEAM_COUPLING_R";
const char *scllrfPRCDriver::Cavity0Mode2BeamCouplingWString = "CAVITY_0_MODE_2_BEAM_COUPLING_W";
const char *scllrfPRCDriver::Cavity0Mode2BwRString = "CAVITY_0_MODE_2_BW_R";
const char *scllrfPRCDriver::Cavity0Mode2BwWString = "CAVITY_0_MODE_2_BW_W";
const char *scllrfPRCDriver::Cavity0Mode2CoupleOutCouplingRString = "CAVITY_0_MODE_2_COUPLE_OUT_COUPLING_R";
const char *scllrfPRCDriver::Cavity0Mode2CoupleOutCouplingWString = "CAVITY_0_MODE_2_COUPLE_OUT_COUPLING_W";
const char *scllrfPRCDriver::Cavity0Mode2CoupleOutPhaseOffsetRString = "CAVITY_0_MODE_2_COUPLE_OUT_PHASE_OFFSET_R";
const char *scllrfPRCDriver::Cavity0Mode2CoupleOutPhaseOffsetWString = "CAVITY_0_MODE_2_COUPLE_OUT_PHASE_OFFSET_W";
const char *scllrfPRCDriver::Cavity0Mode2DriveCouplingRString = "CAVITY_0_MODE_2_DRIVE_COUPLING_R";
const char *scllrfPRCDriver::Cavity0Mode2DriveCouplingWString = "CAVITY_0_MODE_2_DRIVE_COUPLING_W";
const char *scllrfPRCDriver::Cavity0ModuloRString = "CAVITY_0_MODULO_R";
const char *scllrfPRCDriver::Cavity0ModuloWString = "CAVITY_0_MODULO_W";
const char *scllrfPRCDriver::Cavity0OuterProd0KOutWString = "CAVITY_0_OUTER_PROD_0_K_OUT_W";
const char *scllrfPRCDriver::Cavity0OuterProd1KOutWString = "CAVITY_0_OUTER_PROD_1_K_OUT_W";
const char *scllrfPRCDriver::Cavity0OuterProd2KOutWString = "CAVITY_0_OUTER_PROD_2_K_OUT_W";
const char *scllrfPRCDriver::Cavity0PhaseStepRString = "CAVITY_0_PHASE_STEP_R";
const char *scllrfPRCDriver::Cavity0PhaseStepWString = "CAVITY_0_PHASE_STEP_W";
const char *scllrfPRCDriver::Cavity0PiezoCoupleKOutWString = "CAVITY_0_PIEZO_COUPLE_K_OUT_W";
const char *scllrfPRCDriver::Cavity0PrngIvaRString = "CAVITY_0_PRNG_IVA_R";
const char *scllrfPRCDriver::Cavity0PrngIvaWString = "CAVITY_0_PRNG_IVA_W";
const char *scllrfPRCDriver::Cavity0PrngIvbRString = "CAVITY_0_PRNG_IVB_R";
const char *scllrfPRCDriver::Cavity0PrngIvbWString = "CAVITY_0_PRNG_IVB_W";
const char *scllrfPRCDriver::Cavity0PrngRandomRunRString = "CAVITY_0_PRNG_RANDOM_RUN_R";
const char *scllrfPRCDriver::Cavity0PrngRandomRunWString = "CAVITY_0_PRNG_RANDOM_RUN_W";
const char *scllrfPRCDriver::Cavity1ACavOffsetRString = "CAVITY_1_A_CAV_OFFSET_R";
const char *scllrfPRCDriver::Cavity1ACavOffsetWString = "CAVITY_1_A_CAV_OFFSET_W";
const char *scllrfPRCDriver::Cavity1AForOffsetRString = "CAVITY_1_A_FOR_OFFSET_R";
const char *scllrfPRCDriver::Cavity1AForOffsetWString = "CAVITY_1_A_FOR_OFFSET_W";
const char *scllrfPRCDriver::Cavity1ARflOffsetRString = "CAVITY_1_A_RFL_OFFSET_R";
const char *scllrfPRCDriver::Cavity1ARflOffsetWString = "CAVITY_1_A_RFL_OFFSET_W";
const char *scllrfPRCDriver::Cavity1AmpLpBwRString = "CAVITY_1_AMP_LP_BW_R";
const char *scllrfPRCDriver::Cavity1AmpLpBwWString = "CAVITY_1_AMP_LP_BW_W";
const char *scllrfPRCDriver::Cavity1ComprSatCtlRString = "CAVITY_1_COMPR_SAT_CTL_R";
const char *scllrfPRCDriver::Cavity1ComprSatCtlWString = "CAVITY_1_COMPR_SAT_CTL_W";
const char *scllrfPRCDriver::Cavity1Dot0KOutWString = "CAVITY_1_DOT_0_K_OUT_W";
const char *scllrfPRCDriver::Cavity1Dot1KOutWString = "CAVITY_1_DOT_1_K_OUT_W";
const char *scllrfPRCDriver::Cavity1Dot2KOutWString = "CAVITY_1_DOT_2_K_OUT_W";
const char *scllrfPRCDriver::Cavity1DriveCoupleOutCouplingRString = "CAVITY_1_DRIVE_COUPLE_OUT_COUPLING_R";
const char *scllrfPRCDriver::Cavity1DriveCoupleOutCouplingWString = "CAVITY_1_DRIVE_COUPLE_OUT_COUPLING_W";
const char *scllrfPRCDriver::Cavity1DriveCoupleOutPhaseOffsetRString = "CAVITY_1_DRIVE_COUPLE_OUT_PHASE_OFFSET_R";
const char *scllrfPRCDriver::Cavity1DriveCoupleOutPhaseOffsetWString = "CAVITY_1_DRIVE_COUPLE_OUT_PHASE_OFFSET_W";
const char *scllrfPRCDriver::Cavity1Freq0CoarseFreqRString = "CAVITY_1_FREQ_0_COARSE_FREQ_R";
const char *scllrfPRCDriver::Cavity1Freq0CoarseFreqWString = "CAVITY_1_FREQ_0_COARSE_FREQ_W";
const char *scllrfPRCDriver::Cavity1Freq1CoarseFreqRString = "CAVITY_1_FREQ_1_COARSE_FREQ_R";
const char *scllrfPRCDriver::Cavity1Freq1CoarseFreqWString = "CAVITY_1_FREQ_1_COARSE_FREQ_W";
const char *scllrfPRCDriver::Cavity1Freq2CoarseFreqRString = "CAVITY_1_FREQ_2_COARSE_FREQ_R";
const char *scllrfPRCDriver::Cavity1Freq2CoarseFreqWString = "CAVITY_1_FREQ_2_COARSE_FREQ_W";
const char *scllrfPRCDriver::Cavity1Mode0BeamCouplingRString = "CAVITY_1_MODE_0_BEAM_COUPLING_R";
const char *scllrfPRCDriver::Cavity1Mode0BeamCouplingWString = "CAVITY_1_MODE_0_BEAM_COUPLING_W";
const char *scllrfPRCDriver::Cavity1Mode0BwRString = "CAVITY_1_MODE_0_BW_R";
const char *scllrfPRCDriver::Cavity1Mode0BwWString = "CAVITY_1_MODE_0_BW_W";
const char *scllrfPRCDriver::Cavity1Mode0CoupleOutCouplingRString = "CAVITY_1_MODE_0_COUPLE_OUT_COUPLING_R";
const char *scllrfPRCDriver::Cavity1Mode0CoupleOutCouplingWString = "CAVITY_1_MODE_0_COUPLE_OUT_COUPLING_W";
const char *scllrfPRCDriver::Cavity1Mode0CoupleOutPhaseOffsetRString = "CAVITY_1_MODE_0_COUPLE_OUT_PHASE_OFFSET_R";
const char *scllrfPRCDriver::Cavity1Mode0CoupleOutPhaseOffsetWString = "CAVITY_1_MODE_0_COUPLE_OUT_PHASE_OFFSET_W";
const char *scllrfPRCDriver::Cavity1Mode0DriveCouplingRString = "CAVITY_1_MODE_0_DRIVE_COUPLING_R";
const char *scllrfPRCDriver::Cavity1Mode0DriveCouplingWString = "CAVITY_1_MODE_0_DRIVE_COUPLING_W";
const char *scllrfPRCDriver::Cavity1Mode1BeamCouplingRString = "CAVITY_1_MODE_1_BEAM_COUPLING_R";
const char *scllrfPRCDriver::Cavity1Mode1BeamCouplingWString = "CAVITY_1_MODE_1_BEAM_COUPLING_W";
const char *scllrfPRCDriver::Cavity1Mode1BwRString = "CAVITY_1_MODE_1_BW_R";
const char *scllrfPRCDriver::Cavity1Mode1BwWString = "CAVITY_1_MODE_1_BW_W";
const char *scllrfPRCDriver::Cavity1Mode1CoupleOutCouplingRString = "CAVITY_1_MODE_1_COUPLE_OUT_COUPLING_R";
const char *scllrfPRCDriver::Cavity1Mode1CoupleOutCouplingWString = "CAVITY_1_MODE_1_COUPLE_OUT_COUPLING_W";
const char *scllrfPRCDriver::Cavity1Mode1CoupleOutPhaseOffsetRString = "CAVITY_1_MODE_1_COUPLE_OUT_PHASE_OFFSET_R";
const char *scllrfPRCDriver::Cavity1Mode1CoupleOutPhaseOffsetWString = "CAVITY_1_MODE_1_COUPLE_OUT_PHASE_OFFSET_W";
const char *scllrfPRCDriver::Cavity1Mode1DriveCouplingRString = "CAVITY_1_MODE_1_DRIVE_COUPLING_R";
const char *scllrfPRCDriver::Cavity1Mode1DriveCouplingWString = "CAVITY_1_MODE_1_DRIVE_COUPLING_W";
const char *scllrfPRCDriver::Cavity1Mode2BeamCouplingRString = "CAVITY_1_MODE_2_BEAM_COUPLING_R";
const char *scllrfPRCDriver::Cavity1Mode2BeamCouplingWString = "CAVITY_1_MODE_2_BEAM_COUPLING_W";
const char *scllrfPRCDriver::Cavity1Mode2BwRString = "CAVITY_1_MODE_2_BW_R";
const char *scllrfPRCDriver::Cavity1Mode2BwWString = "CAVITY_1_MODE_2_BW_W";
const char *scllrfPRCDriver::Cavity1Mode2CoupleOutCouplingRString = "CAVITY_1_MODE_2_COUPLE_OUT_COUPLING_R";
const char *scllrfPRCDriver::Cavity1Mode2CoupleOutCouplingWString = "CAVITY_1_MODE_2_COUPLE_OUT_COUPLING_W";
const char *scllrfPRCDriver::Cavity1Mode2CoupleOutPhaseOffsetRString = "CAVITY_1_MODE_2_COUPLE_OUT_PHASE_OFFSET_R";
const char *scllrfPRCDriver::Cavity1Mode2CoupleOutPhaseOffsetWString = "CAVITY_1_MODE_2_COUPLE_OUT_PHASE_OFFSET_W";
const char *scllrfPRCDriver::Cavity1Mode2DriveCouplingRString = "CAVITY_1_MODE_2_DRIVE_COUPLING_R";
const char *scllrfPRCDriver::Cavity1Mode2DriveCouplingWString = "CAVITY_1_MODE_2_DRIVE_COUPLING_W";
const char *scllrfPRCDriver::Cavity1ModuloRString = "CAVITY_1_MODULO_R";
const char *scllrfPRCDriver::Cavity1ModuloWString = "CAVITY_1_MODULO_W";
const char *scllrfPRCDriver::Cavity1OuterProd0KOutWString = "CAVITY_1_OUTER_PROD_0_K_OUT_W";
const char *scllrfPRCDriver::Cavity1OuterProd1KOutWString = "CAVITY_1_OUTER_PROD_1_K_OUT_W";
const char *scllrfPRCDriver::Cavity1OuterProd2KOutWString = "CAVITY_1_OUTER_PROD_2_K_OUT_W";
const char *scllrfPRCDriver::Cavity1PhaseStepRString = "CAVITY_1_PHASE_STEP_R";
const char *scllrfPRCDriver::Cavity1PhaseStepWString = "CAVITY_1_PHASE_STEP_W";
const char *scllrfPRCDriver::Cavity1PiezoCoupleKOutWString = "CAVITY_1_PIEZO_COUPLE_K_OUT_W";
const char *scllrfPRCDriver::Cavity1PrngIvaRString = "CAVITY_1_PRNG_IVA_R";
const char *scllrfPRCDriver::Cavity1PrngIvaWString = "CAVITY_1_PRNG_IVA_W";
const char *scllrfPRCDriver::Cavity1PrngIvbRString = "CAVITY_1_PRNG_IVB_R";
const char *scllrfPRCDriver::Cavity1PrngIvbWString = "CAVITY_1_PRNG_IVB_W";
const char *scllrfPRCDriver::Cavity1PrngRandomRunRString = "CAVITY_1_PRNG_RANDOM_RUN_R";
const char *scllrfPRCDriver::Cavity1PrngRandomRunWString = "CAVITY_1_PRNG_RANDOM_RUN_W";
const char *scllrfPRCDriver::CcErrorClearRString = "CC_ERROR_CLEAR_R";
const char *scllrfPRCDriver::CcErrorClearWString = "CC_ERROR_CLEAR_W";
const char *scllrfPRCDriver::CcLoc1RString = "CC_LOC1_R";
const char *scllrfPRCDriver::CcLoc1WString = "CC_LOC1_W";
const char *scllrfPRCDriver::Cct1Cavity0StatusAuxRString = "CCT1_CAVITY0_STATUS_AUX_R";
const char *scllrfPRCDriver::Cct1Cavity0StatusAuxWString = "CCT1_CAVITY0_STATUS_AUX_W";
const char *scllrfPRCDriver::Cct1Cavity1StatusAuxRString = "CCT1_CAVITY1_STATUS_AUX_R";
const char *scllrfPRCDriver::Cct1Cavity1StatusAuxWString = "CCT1_CAVITY1_STATUS_AUX_W";
const char *scllrfPRCDriver::CicPeriodRString = "CIC_PERIOD_R";
const char *scllrfPRCDriver::CicPeriodWString = "CIC_PERIOD_W";
const char *scllrfPRCDriver::CicShiftRString = "CIC_SHIFT_R";
const char *scllrfPRCDriver::CicShiftWString = "CIC_SHIFT_W";
const char *scllrfPRCDriver::CircleBufFlipRString = "CIRCLE_BUF_FLIP_R";
const char *scllrfPRCDriver::CircleBufFlipWString = "CIRCLE_BUF_FLIP_W";
const char *scllrfPRCDriver::ClkPhaseDiffOutU2RString = "CLK_PHASE_DIFF_OUT_U2_R";
const char *scllrfPRCDriver::ClkPhaseDiffOutU3RString = "CLK_PHASE_DIFF_OUT_U3_R";
const char *scllrfPRCDriver::ClkStatusOutRString = "CLK_STATUS_OUT_R";
const char *scllrfPRCDriver::ConfigU15SpiDataAddrRRString = "CONFIG_U15_SPI_DATA_ADDR_R_R";
const char *scllrfPRCDriver::ConfigU15SpiDataAddrRWString = "CONFIG_U15_SPI_DATA_ADDR_R_W";
const char *scllrfPRCDriver::ConfigU15SpiReadAndStartRRString = "CONFIG_U15_SPI_READ_AND_START_R_R";
const char *scllrfPRCDriver::ConfigU15SpiReadAndStartRWString = "CONFIG_U15_SPI_READ_AND_START_R_W";
const char *scllrfPRCDriver::ConfigU18SpiDataAddrRRString = "CONFIG_U18_SPI_DATA_ADDR_R_R";
const char *scllrfPRCDriver::ConfigU18SpiDataAddrRWString = "CONFIG_U18_SPI_DATA_ADDR_R_W";
const char *scllrfPRCDriver::ConfigU18SpiReadAndStartRRString = "CONFIG_U18_SPI_READ_AND_START_R_R";
const char *scllrfPRCDriver::ConfigU18SpiReadAndStartRWString = "CONFIG_U18_SPI_READ_AND_START_R_W";
const char *scllrfPRCDriver::ConfigU2ClkResetRRString = "CONFIG_U2_CLK_RESET_R_R";
const char *scllrfPRCDriver::ConfigU2ClkResetRWString = "CONFIG_U2_CLK_RESET_R_W";
const char *scllrfPRCDriver::ConfigU2IserdesResetRRString = "CONFIG_U2_ISERDES_RESET_R_R";
const char *scllrfPRCDriver::ConfigU2IserdesResetRWString = "CONFIG_U2_ISERDES_RESET_R_W";
const char *scllrfPRCDriver::ConfigU3ClkResetRRString = "CONFIG_U3_CLK_RESET_R_R";
const char *scllrfPRCDriver::ConfigU3ClkResetRWString = "CONFIG_U3_CLK_RESET_R_W";
const char *scllrfPRCDriver::ConfigU3IserdesResetRRString = "CONFIG_U3_ISERDES_RESET_R_R";
const char *scllrfPRCDriver::ConfigU3IserdesResetRWString = "CONFIG_U3_ISERDES_RESET_R_W";
const char *scllrfPRCDriver::ConfigU4ResetRRString = "CONFIG_U4_RESET_R_R";
const char *scllrfPRCDriver::ConfigU4ResetRWString = "CONFIG_U4_RESET_R_W";
const char *scllrfPRCDriver::ConfigBanyanMaskRString = "CONFIG_BANYAN_MASK_R";
const char *scllrfPRCDriver::ConfigBanyanMaskWString = "CONFIG_BANYAN_MASK_W";
const char *scllrfPRCDriver::ConfigBitslipRString = "CONFIG_BITSLIP_R";
const char *scllrfPRCDriver::ConfigBitslipWString = "CONFIG_BITSLIP_W";
const char *scllrfPRCDriver::ConfigClkStatusWeRString = "CONFIG_CLK_STATUS_WE_R";
const char *scllrfPRCDriver::ConfigClkStatusWeWString = "CONFIG_CLK_STATUS_WE_W";
const char *scllrfPRCDriver::ConfigIdelayctrlResetRRString = "CONFIG_IDELAYCTRL_RESET_R_R";
const char *scllrfPRCDriver::ConfigIdelayctrlResetRWString = "CONFIG_IDELAYCTRL_RESET_R_W";
const char *scllrfPRCDriver::ConfigLlspiWeRString = "CONFIG_LLSPI_WE_R";
const char *scllrfPRCDriver::ConfigLlspiWeWString = "CONFIG_LLSPI_WE_W";
const char *scllrfPRCDriver::ConfigMmcmResetRRString = "CONFIG_MMCM_RESET_R_R";
const char *scllrfPRCDriver::ConfigMmcmResetRWString = "CONFIG_MMCM_RESET_R_W";
const char *scllrfPRCDriver::ConfigPeriphConfigRString = "CONFIG_PERIPH_CONFIG_R";
const char *scllrfPRCDriver::ConfigPeriphConfigWString = "CONFIG_PERIPH_CONFIG_W";
const char *scllrfPRCDriver::ConfigPhasexTrigRString = "CONFIG_PHASEX_TRIG_R";
const char *scllrfPRCDriver::ConfigPhasexTrigWString = "CONFIG_PHASEX_TRIG_W";
const char *scllrfPRCDriver::ConfigRawadcTrigRString = "CONFIG_RAWADC_TRIG_R";
const char *scllrfPRCDriver::ConfigRawadcTrigWString = "CONFIG_RAWADC_TRIG_W";
const char *scllrfPRCDriver::ConfigScanTriggerWeRString = "CONFIG_SCAN_TRIGGER_WE_R";
const char *scllrfPRCDriver::ConfigScanTriggerWeWString = "CONFIG_SCAN_TRIGGER_WE_W";
const char *scllrfPRCDriver::ConfigScannerDebugRString = "CONFIG_SCANNER_DEBUG_R";
const char *scllrfPRCDriver::ConfigScannerDebugWString = "CONFIG_SCANNER_DEBUG_W";
const char *scllrfPRCDriver::ConfigSyncAd7794CsetRString = "CONFIG_SYNC_AD7794_CSET_R";
const char *scllrfPRCDriver::ConfigSyncAd7794CsetWString = "CONFIG_SYNC_AD7794_CSET_W";
const char *scllrfPRCDriver::ConfigSyncTps62210CsetRString = "CONFIG_SYNC_TPS62210_CSET_R";
const char *scllrfPRCDriver::ConfigSyncTps62210CsetWString = "CONFIG_SYNC_TPS62210_CSET_W";
const char *scllrfPRCDriver::CrcErrorsRString = "CRC_ERRORS_R";
const char *scllrfPRCDriver::CtraceRunningRString = "CTRACE_RUNNING_R";
const char *scllrfPRCDriver::DacDdsResetRString = "DAC_DDS_RESET_R";
const char *scllrfPRCDriver::DacDdsResetWString = "DAC_DDS_RESET_W";
const char *scllrfPRCDriver::DacIqPhaseRString = "DAC_IQ_PHASE_R";
const char *scllrfPRCDriver::DacIqPhaseWString = "DAC_IQ_PHASE_W";
const char *scllrfPRCDriver::DacModeRString = "DAC_MODE_R";
const char *scllrfPRCDriver::DacModeWString = "DAC_MODE_W";
const char *scllrfPRCDriver::DdsaModuloRString = "DDSA_MODULO_R";
const char *scllrfPRCDriver::DdsaModuloWString = "DDSA_MODULO_W";
const char *scllrfPRCDriver::DdsaPhstepHRString = "DDSA_PHSTEP_H_R";
const char *scllrfPRCDriver::DdsaPhstepHWString = "DDSA_PHSTEP_H_W";
const char *scllrfPRCDriver::DdsaPhstepLRString = "DDSA_PHSTEP_L_R";
const char *scllrfPRCDriver::DdsaPhstepLWString = "DDSA_PHSTEP_L_W";
const char *scllrfPRCDriver::DomainJumpRealignRString = "DOMAIN_JUMP_REALIGN_R";
const char *scllrfPRCDriver::DomainJumpRealignWString = "DOMAIN_JUMP_REALIGN_W";
const char *scllrfPRCDriver::FfffffffRString = "FFFFFFFF_R";
const char *scllrfPRCDriver::Frequency4XoutRString = "FREQUENCY_4XOUT_R";
const char *scllrfPRCDriver::FrequencyAdcRString = "FREQUENCY_ADC_R";
const char *scllrfPRCDriver::FrequencyClkout3RString = "FREQUENCY_CLKOUT3_R";
const char *scllrfPRCDriver::FrequencyDcoRString = "FREQUENCY_DCO_R";
const char *scllrfPRCDriver::FrequencyGtxRxRString = "FREQUENCY_GTX_RX_R";
const char *scllrfPRCDriver::FrequencyGtxTxRString = "FREQUENCY_GTX_TX_R";
const char *scllrfPRCDriver::Hello0RString = "HELLO_0_R";
const char *scllrfPRCDriver::Hello1RString = "HELLO_1_R";
const char *scllrfPRCDriver::Hello2RString = "HELLO_2_R";
const char *scllrfPRCDriver::Hello3RString = "HELLO_3_R";
const char *scllrfPRCDriver::HistCountWStrobeRString = "HIST_COUNT_W_STROBE_R";
const char *scllrfPRCDriver::HistCountWStrobeWString = "HIST_COUNT_W_STROBE_W";
const char *scllrfPRCDriver::HistDoutRString = "HIST_DOUT_R";
const char *scllrfPRCDriver::HistStatusRString = "HIST_STATUS_R";
const char *scllrfPRCDriver::IccCfgRString = "ICC_CFG_R";
const char *scllrfPRCDriver::IccCfgWString = "ICC_CFG_W";
const char *scllrfPRCDriver::IdelayBaseRString = "IDELAY_BASE_R";
const char *scllrfPRCDriver::IdelayValueOutU2LsbRString = "IDELAY_VALUE_OUT_U2_LSB_R";
const char *scllrfPRCDriver::IdelayValueOutU2MsbRString = "IDELAY_VALUE_OUT_U2_MSB_R";
const char *scllrfPRCDriver::IdelayValueOutU3LsbRString = "IDELAY_VALUE_OUT_U3_LSB_R";
const char *scllrfPRCDriver::IdelayValueOutU3MsbRString = "IDELAY_VALUE_OUT_U3_MSB_R";
const char *scllrfPRCDriver::LlrfCircleDataRString = "LLRF_CIRCLE_DATA_R";
const char *scllrfPRCDriver::LlrfCircleReadyRString = "LLRF_CIRCLE_READY_R";
const char *scllrfPRCDriver::LlrfDspDacEnRString = "LLRF_DSP_DAC_EN_R";
const char *scllrfPRCDriver::LlrfDspDacEnWString = "LLRF_DSP_DAC_EN_W";
const char *scllrfPRCDriver::LlspiResultRString = "LLSPI_RESULT_R";
const char *scllrfPRCDriver::LlspiStatusRString = "LLSPI_STATUS_R";
const char *scllrfPRCDriver::LoAmpRString = "LO_AMP_R";
const char *scllrfPRCDriver::LoAmpWString = "LO_AMP_W";
const char *scllrfPRCDriver::ModuloRString = "MODULO_R";
const char *scllrfPRCDriver::ModuloWString = "MODULO_W";
const char *scllrfPRCDriver::PhaseStepHRString = "PHASE_STEP_H_R";
const char *scllrfPRCDriver::PhaseStepHWString = "PHASE_STEP_H_W";
const char *scllrfPRCDriver::PhaseStepLRString = "PHASE_STEP_L_R";
const char *scllrfPRCDriver::PhaseStepLWString = "PHASE_STEP_L_W";
const char *scllrfPRCDriver::PhasexDoutRString = "PHASEX_DOUT_R";
const char *scllrfPRCDriver::PhasexStatusRString = "PHASEX_STATUS_R";
const char *scllrfPRCDriver::PrcDspCavSelRString = "PRC_DSP_CAV_SEL_R";
const char *scllrfPRCDriver::PrcDspCavSelWString = "PRC_DSP_CAV_SEL_W";
const char *scllrfPRCDriver::PrcDspPrlCfgRString = "PRC_DSP_PRL_CFG_R";
const char *scllrfPRCDriver::PrcDspPrlCfgWString = "PRC_DSP_PRL_CFG_W";
const char *scllrfPRCDriver::PrcDspPrlGainRString = "PRC_DSP_PRL_GAIN_R";
const char *scllrfPRCDriver::PrcDspPrlGainWString = "PRC_DSP_PRL_GAIN_W";
const char *scllrfPRCDriver::QsfpBufRString = "QSFP_BUF_R";
const char *scllrfPRCDriver::QsfpI2CRegRString = "QSFP_I2C_REG_R";
const char *scllrfPRCDriver::QsfpI2CRegWString = "QSFP_I2C_REG_W";
const char *scllrfPRCDriver::RewindRString = "REWIND_R";
const char *scllrfPRCDriver::RewindWString = "REWIND_W";
const char *scllrfPRCDriver::ScannerResultRString = "SCANNER_RESULT_R";
const char *scllrfPRCDriver::SfpAddressSetRString = "SFP_ADDRESS_SET_R";
const char *scllrfPRCDriver::SfpAddressSetWString = "SFP_ADDRESS_SET_W";
const char *scllrfPRCDriver::Shell0DspChanKeepRString = "SHELL_0_DSP_CHAN_KEEP_R";
const char *scllrfPRCDriver::Shell0DspChanKeepWString = "SHELL_0_DSP_CHAN_KEEP_W";
const char *scllrfPRCDriver::Shell0DspFdbkCoreCoarseScaleRString = "SHELL_0_DSP_FDBK_CORE_COARSE_SCALE_R";
const char *scllrfPRCDriver::Shell0DspFdbkCoreCoarseScaleWString = "SHELL_0_DSP_FDBK_CORE_COARSE_SCALE_W";
const char *scllrfPRCDriver::Shell0DspFdbkCoreMpProcCoeffRString = "SHELL_0_DSP_FDBK_CORE_MP_PROC_COEFF_R";
const char *scllrfPRCDriver::Shell0DspFdbkCoreMpProcCoeffWString = "SHELL_0_DSP_FDBK_CORE_MP_PROC_COEFF_W";
const char *scllrfPRCDriver::Shell0DspFdbkCoreMpProcLimRString = "SHELL_0_DSP_FDBK_CORE_MP_PROC_LIM_R";
const char *scllrfPRCDriver::Shell0DspFdbkCoreMpProcLimWString = "SHELL_0_DSP_FDBK_CORE_MP_PROC_LIM_W";
const char *scllrfPRCDriver::Shell0DspFdbkCoreMpProcPhOffsetRString = "SHELL_0_DSP_FDBK_CORE_MP_PROC_PH_OFFSET_R";
const char *scllrfPRCDriver::Shell0DspFdbkCoreMpProcPhOffsetWString = "SHELL_0_DSP_FDBK_CORE_MP_PROC_PH_OFFSET_W";
const char *scllrfPRCDriver::Shell0DspFdbkCoreMpProcSelEnRString = "SHELL_0_DSP_FDBK_CORE_MP_PROC_SEL_EN_R";
const char *scllrfPRCDriver::Shell0DspFdbkCoreMpProcSelEnWString = "SHELL_0_DSP_FDBK_CORE_MP_PROC_SEL_EN_W";
const char *scllrfPRCDriver::Shell0DspFdbkCoreMpProcSelThreshRString = "SHELL_0_DSP_FDBK_CORE_MP_PROC_SEL_THRESH_R";
const char *scllrfPRCDriver::Shell0DspFdbkCoreMpProcSelThreshWString = "SHELL_0_DSP_FDBK_CORE_MP_PROC_SEL_THRESH_W";
const char *scllrfPRCDriver::Shell0DspFdbkCoreMpProcSetmpRString = "SHELL_0_DSP_FDBK_CORE_MP_PROC_SETMP_R";
const char *scllrfPRCDriver::Shell0DspFdbkCoreMpProcSetmpWString = "SHELL_0_DSP_FDBK_CORE_MP_PROC_SETMP_W";
const char *scllrfPRCDriver::Shell0DspLpNotchLp1AKxRString = "SHELL_0_DSP_LP_NOTCH_LP1A_KX_R";
const char *scllrfPRCDriver::Shell0DspLpNotchLp1AKxWString = "SHELL_0_DSP_LP_NOTCH_LP1A_KX_W";
const char *scllrfPRCDriver::Shell0DspLpNotchLp1AKyRString = "SHELL_0_DSP_LP_NOTCH_LP1A_KY_R";
const char *scllrfPRCDriver::Shell0DspLpNotchLp1AKyWString = "SHELL_0_DSP_LP_NOTCH_LP1A_KY_W";
const char *scllrfPRCDriver::Shell0DspLpNotchLp1BKxRString = "SHELL_0_DSP_LP_NOTCH_LP1B_KX_R";
const char *scllrfPRCDriver::Shell0DspLpNotchLp1BKxWString = "SHELL_0_DSP_LP_NOTCH_LP1B_KX_W";
const char *scllrfPRCDriver::Shell0DspLpNotchLp1BKyRString = "SHELL_0_DSP_LP_NOTCH_LP1B_KY_R";
const char *scllrfPRCDriver::Shell0DspLpNotchLp1BKyWString = "SHELL_0_DSP_LP_NOTCH_LP1B_KY_W";
const char *scllrfPRCDriver::Shell0DspModuloRString = "SHELL_0_DSP_MODULO_R";
const char *scllrfPRCDriver::Shell0DspModuloWString = "SHELL_0_DSP_MODULO_W";
const char *scllrfPRCDriver::Shell0DspPhaseStepRString = "SHELL_0_DSP_PHASE_STEP_R";
const char *scllrfPRCDriver::Shell0DspPhaseStepWString = "SHELL_0_DSP_PHASE_STEP_W";
const char *scllrfPRCDriver::Shell0DspPiezoPiezoDcRString = "SHELL_0_DSP_PIEZO_PIEZO_DC_R";
const char *scllrfPRCDriver::Shell0DspPiezoPiezoDcWString = "SHELL_0_DSP_PIEZO_PIEZO_DC_W";
const char *scllrfPRCDriver::Shell0DspPiezoSfConstsRString = "SHELL_0_DSP_PIEZO_SF_CONSTS_R";
const char *scllrfPRCDriver::Shell0DspPiezoSfConstsWString = "SHELL_0_DSP_PIEZO_SF_CONSTS_W";
const char *scllrfPRCDriver::Shell0DspTagRString = "SHELL_0_DSP_TAG_R";
const char *scllrfPRCDriver::Shell0DspTagWString = "SHELL_0_DSP_TAG_W";
const char *scllrfPRCDriver::Shell0DspUseFiberIqRString = "SHELL_0_DSP_USE_FIBER_IQ_R";
const char *scllrfPRCDriver::Shell0DspUseFiberIqWString = "SHELL_0_DSP_USE_FIBER_IQ_W";
const char *scllrfPRCDriver::Shell0DspWaveSampPerRString = "SHELL_0_DSP_WAVE_SAMP_PER_R";
const char *scllrfPRCDriver::Shell0DspWaveSampPerWString = "SHELL_0_DSP_WAVE_SAMP_PER_W";
const char *scllrfPRCDriver::Shell0DspWaveShiftRString = "SHELL_0_DSP_WAVE_SHIFT_R";
const char *scllrfPRCDriver::Shell0DspWaveShiftWString = "SHELL_0_DSP_WAVE_SHIFT_W";
const char *scllrfPRCDriver::Shell0SlowDataRString = "SHELL_0_SLOW_DATA_R";
const char *scllrfPRCDriver::Shell1DspChanKeepRString = "SHELL_1_DSP_CHAN_KEEP_R";
const char *scllrfPRCDriver::Shell1DspChanKeepWString = "SHELL_1_DSP_CHAN_KEEP_W";
const char *scllrfPRCDriver::Shell1DspFdbkCoreCoarseScaleRString = "SHELL_1_DSP_FDBK_CORE_COARSE_SCALE_R";
const char *scllrfPRCDriver::Shell1DspFdbkCoreCoarseScaleWString = "SHELL_1_DSP_FDBK_CORE_COARSE_SCALE_W";
const char *scllrfPRCDriver::Shell1DspFdbkCoreMpProcCoeffRString = "SHELL_1_DSP_FDBK_CORE_MP_PROC_COEFF_R";
const char *scllrfPRCDriver::Shell1DspFdbkCoreMpProcCoeffWString = "SHELL_1_DSP_FDBK_CORE_MP_PROC_COEFF_W";
const char *scllrfPRCDriver::Shell1DspFdbkCoreMpProcLimRString = "SHELL_1_DSP_FDBK_CORE_MP_PROC_LIM_R";
const char *scllrfPRCDriver::Shell1DspFdbkCoreMpProcLimWString = "SHELL_1_DSP_FDBK_CORE_MP_PROC_LIM_W";
const char *scllrfPRCDriver::Shell1DspFdbkCoreMpProcPhOffsetRString = "SHELL_1_DSP_FDBK_CORE_MP_PROC_PH_OFFSET_R";
const char *scllrfPRCDriver::Shell1DspFdbkCoreMpProcPhOffsetWString = "SHELL_1_DSP_FDBK_CORE_MP_PROC_PH_OFFSET_W";
const char *scllrfPRCDriver::Shell1DspFdbkCoreMpProcSelEnRString = "SHELL_1_DSP_FDBK_CORE_MP_PROC_SEL_EN_R";
const char *scllrfPRCDriver::Shell1DspFdbkCoreMpProcSelEnWString = "SHELL_1_DSP_FDBK_CORE_MP_PROC_SEL_EN_W";
const char *scllrfPRCDriver::Shell1DspFdbkCoreMpProcSelThreshRString = "SHELL_1_DSP_FDBK_CORE_MP_PROC_SEL_THRESH_R";
const char *scllrfPRCDriver::Shell1DspFdbkCoreMpProcSelThreshWString = "SHELL_1_DSP_FDBK_CORE_MP_PROC_SEL_THRESH_W";
const char *scllrfPRCDriver::Shell1DspFdbkCoreMpProcSetmpRString = "SHELL_1_DSP_FDBK_CORE_MP_PROC_SETMP_R";
const char *scllrfPRCDriver::Shell1DspFdbkCoreMpProcSetmpWString = "SHELL_1_DSP_FDBK_CORE_MP_PROC_SETMP_W";
const char *scllrfPRCDriver::Shell1DspLpNotchLp1AKxRString = "SHELL_1_DSP_LP_NOTCH_LP1A_KX_R";
const char *scllrfPRCDriver::Shell1DspLpNotchLp1AKxWString = "SHELL_1_DSP_LP_NOTCH_LP1A_KX_W";
const char *scllrfPRCDriver::Shell1DspLpNotchLp1AKyRString = "SHELL_1_DSP_LP_NOTCH_LP1A_KY_R";
const char *scllrfPRCDriver::Shell1DspLpNotchLp1AKyWString = "SHELL_1_DSP_LP_NOTCH_LP1A_KY_W";
const char *scllrfPRCDriver::Shell1DspLpNotchLp1BKxRString = "SHELL_1_DSP_LP_NOTCH_LP1B_KX_R";
const char *scllrfPRCDriver::Shell1DspLpNotchLp1BKxWString = "SHELL_1_DSP_LP_NOTCH_LP1B_KX_W";
const char *scllrfPRCDriver::Shell1DspLpNotchLp1BKyRString = "SHELL_1_DSP_LP_NOTCH_LP1B_KY_R";
const char *scllrfPRCDriver::Shell1DspLpNotchLp1BKyWString = "SHELL_1_DSP_LP_NOTCH_LP1B_KY_W";
const char *scllrfPRCDriver::Shell1DspModuloRString = "SHELL_1_DSP_MODULO_R";
const char *scllrfPRCDriver::Shell1DspModuloWString = "SHELL_1_DSP_MODULO_W";
const char *scllrfPRCDriver::Shell1DspPhaseStepRString = "SHELL_1_DSP_PHASE_STEP_R";
const char *scllrfPRCDriver::Shell1DspPhaseStepWString = "SHELL_1_DSP_PHASE_STEP_W";
const char *scllrfPRCDriver::Shell1DspPiezoPiezoDcRString = "SHELL_1_DSP_PIEZO_PIEZO_DC_R";
const char *scllrfPRCDriver::Shell1DspPiezoPiezoDcWString = "SHELL_1_DSP_PIEZO_PIEZO_DC_W";
const char *scllrfPRCDriver::Shell1DspPiezoSfConstsRString = "SHELL_1_DSP_PIEZO_SF_CONSTS_R";
const char *scllrfPRCDriver::Shell1DspPiezoSfConstsWString = "SHELL_1_DSP_PIEZO_SF_CONSTS_W";
const char *scllrfPRCDriver::Shell1DspTagRString = "SHELL_1_DSP_TAG_R";
const char *scllrfPRCDriver::Shell1DspTagWString = "SHELL_1_DSP_TAG_W";
const char *scllrfPRCDriver::Shell1DspUseFiberIqRString = "SHELL_1_DSP_USE_FIBER_IQ_R";
const char *scllrfPRCDriver::Shell1DspUseFiberIqWString = "SHELL_1_DSP_USE_FIBER_IQ_W";
const char *scllrfPRCDriver::Shell1DspWaveSampPerRString = "SHELL_1_DSP_WAVE_SAMP_PER_R";
const char *scllrfPRCDriver::Shell1DspWaveSampPerWString = "SHELL_1_DSP_WAVE_SAMP_PER_W";
const char *scllrfPRCDriver::Shell1DspWaveShiftRString = "SHELL_1_DSP_WAVE_SHIFT_R";
const char *scllrfPRCDriver::Shell1DspWaveShiftWString = "SHELL_1_DSP_WAVE_SHIFT_W";
const char *scllrfPRCDriver::Shell1SlowDataRString = "SHELL_1_SLOW_DATA_R";
const char *scllrfPRCDriver::SlowChainOutRString = "SLOW_CHAIN_OUT_R";
const char *scllrfPRCDriver::SsaStimAmpstepRString = "SSA_STIM_AMPSTEP_R";
const char *scllrfPRCDriver::SsaStimAmpstepWString = "SSA_STIM_AMPSTEP_W";
const char *scllrfPRCDriver::SsaStimEnRString = "SSA_STIM_EN_R";
const char *scllrfPRCDriver::SsaStimEnWString = "SSA_STIM_EN_W";
const char *scllrfPRCDriver::SsaStimGPeriodRString = "SSA_STIM_G_PERIOD_R";
const char *scllrfPRCDriver::SsaStimGPeriodWString = "SSA_STIM_G_PERIOD_W";
const char *scllrfPRCDriver::SsaStimPertstepRString = "SSA_STIM_PERTSTEP_R";
const char *scllrfPRCDriver::SsaStimPertstepWString = "SSA_STIM_PERTSTEP_W";
const char *scllrfPRCDriver::TagNowRString = "TAG_NOW_R";
const char *scllrfPRCDriver::TagNowWString = "TAG_NOW_W";
const char *scllrfPRCDriver::Tgen0DelayPcXxxWString = "TGEN_0_DELAY_PC_XXX_W";
const char *scllrfPRCDriver::Tgen1DelayPcXxxWString = "TGEN_1_DELAY_PC_XXX_W";
const char *scllrfPRCDriver::TraceIBufRString = "TRACE_I_BUF_R";
const char *scllrfPRCDriver::TraceIqBufRString = "TRACE_IQ_BUF_R";
const char *scllrfPRCDriver::TraceKeepRString = "TRACE_KEEP_R";
const char *scllrfPRCDriver::TraceKeepWString = "TRACE_KEEP_W";
const char *scllrfPRCDriver::TraceQBufRString = "TRACE_Q_BUF_R";
const char *scllrfPRCDriver::TraceResetWeRString = "TRACE_RESET_WE_R";
const char *scllrfPRCDriver::TraceResetWeWString = "TRACE_RESET_WE_W";
const char *scllrfPRCDriver::TraceStatus1RString = "TRACE_STATUS1_R";
const char *scllrfPRCDriver::TraceStatus2RString = "TRACE_STATUS2_R";
const char *scllrfPRCDriver::TrigInternalRString = "TRIG_INTERNAL_R";
const char *scllrfPRCDriver::TrigInternalWString = "TRIG_INTERNAL_W";
const char *scllrfPRCDriver::TrigModeRString = "TRIG_MODE_R";
const char *scllrfPRCDriver::TrigModeWString = "TRIG_MODE_W";
const char *scllrfPRCDriver::Wave0OutRString = "WAVE0_OUT_R";
const char *scllrfPRCDriver::Wave0SrcRString = "WAVE0_SRC_R";
const char *scllrfPRCDriver::Wave0SrcWString = "WAVE0_SRC_W";
const char *scllrfPRCDriver::Wave1OutRString = "WAVE1_OUT_R";
const char *scllrfPRCDriver::Wave1SrcRString = "WAVE1_SRC_R";
const char *scllrfPRCDriver::Wave1SrcWString = "WAVE1_SRC_W";
const char *scllrfPRCDriver::WaveformsAvailableRString = "WAVEFORMS_AVAILABLE_R";

const unsigned int scllrfPRCDriver::scllrfPRCPolledRegCount = 268;

/** Constructor for the scllrfPRC class.
 * Calls constructor for the asynPortDriver base class.
 * \param[in] drvPortName The name of the asyn port driver to be created.
 * \param[in] netPortName The name of the asyn port driver to use for the network connection
 * \param[in] maxAddr The number of channels for the paramater with the most channels
 * \paarm[in] paramTableSize The number of asyn params to be created for each device
 *
 * */
//scllrfPRCDriver::scllrfPRCDriver(const char *drvPortName, const char *netPortName)
//: scllrfAsynPortDriver(drvPortName, netPortName,
//		8, /* maxAddr, i.e. number of channels */
//		NUM_SCLLRFPRC_PARAMS)
//{
//	// NUM_SCLLRFPRC_PARAMS is a macro using protected member variables,
//	// which the compiler has problems with..
//	scllrfPRCDriver(drvPortName, netPortName, 8, NUM_SCLLRFPRC_PARAMS);
//};

scllrfPRCDriver::scllrfPRCDriver(const char *drvPortName, const char *netPortName, int maxAddr, int paramTableAdds)
: scllrfAsynPortDriver(drvPortName, netPortName,
		maxAddr, /* maxAddr, i.e. number of channels */
		paramTableAdds + NUM_SCLLRFPRC_PARAMS)
{
    epicsThreadSleep(defaultPollPeriod);
    createParam(U15SpiRdbkRString, asynParamInt32, &p_U15SpiRdbkR);
    createParam(U15SpiStatusRString, asynParamInt32, &p_U15SpiStatusR);
    createParam(U18SpiRdbkRString, asynParamInt32, &p_U18SpiRdbkR);
    createParam(U18SpiStatusRString, asynParamInt32, &p_U18SpiStatusR);
    createParam(U2DoutLsbRString, asynParamInt32, &p_U2DoutLsbR);
    createParam(U2DoutMsbRString, asynParamInt32, &p_U2DoutMsbR);
    createParam(U3DoutLsbRString, asynParamInt32, &p_U3DoutLsbR);
    createParam(U3DoutMsbRString, asynParamInt32, &p_U3DoutMsbR);
    createParam(AdcMmcmRString, asynParamInt32, &p_AdcMmcmR);
    createParam(AdcMmcmWString, asynParamInt32, &p_AdcMmcmW);
    createParam(AdcTestModeRString, asynParamInt32, &p_AdcTestModeR);
    createParam(AdcTestModeWString, asynParamInt32, &p_AdcTestModeW);
    createParam(AdcTestResetRString, asynParamInt32, &p_AdcTestResetR);
    createParam(AdcTestResetWString, asynParamInt32, &p_AdcTestResetW);
    createParam(AdcTestTrigCntRString, asynParamInt32, &p_AdcTestTrigCntR);
    createParam(AdcTestWave1OutRString, asynParamInt32, &p_AdcTestWave1OutR);
    createParam(AdcTestWave2OutRString, asynParamInt32, &p_AdcTestWave2OutR);
    createParam(AdcTestWave3OutRString, asynParamInt32, &p_AdcTestWave3OutR);
    createParam(AdcTestWave4OutRString, asynParamInt32, &p_AdcTestWave4OutR);
    createParam(AmplitudeRString, asynParamInt32, &p_AmplitudeR);
    createParam(AmplitudeWString, asynParamInt32, &p_AmplitudeW);
    createParam(AverageLenRString, asynParamInt32, &p_AverageLenR);
    createParam(AverageLenWString, asynParamInt32, &p_AverageLenW);
    createParam(BanyanBufRString, asynParamInt32Array, &p_BanyanBufR);
    createParam(BanyanStatusRString, asynParamInt32, &p_BanyanStatusR);
    createParam(Beam0ModuloRString, asynParamInt32, &p_Beam0ModuloR);
    createParam(Beam0ModuloWString, asynParamInt32, &p_Beam0ModuloW);
    createParam(Beam0PhaseInitRString, asynParamInt32, &p_Beam0PhaseInitR);
    createParam(Beam0PhaseInitWString, asynParamInt32, &p_Beam0PhaseInitW);
    createParam(Beam0PhaseStepRString, asynParamInt32, &p_Beam0PhaseStepR);
    createParam(Beam0PhaseStepWString, asynParamInt32, &p_Beam0PhaseStepW);
    createParam(Beam1ModuloRString, asynParamInt32, &p_Beam1ModuloR);
    createParam(Beam1ModuloWString, asynParamInt32, &p_Beam1ModuloW);
    createParam(Beam1PhaseInitRString, asynParamInt32, &p_Beam1PhaseInitR);
    createParam(Beam1PhaseInitWString, asynParamInt32, &p_Beam1PhaseInitW);
    createParam(Beam1PhaseStepRString, asynParamInt32, &p_Beam1PhaseStepR);
    createParam(Beam1PhaseStepWString, asynParamInt32, &p_Beam1PhaseStepW);
    createParam(BufTrigRString, asynParamUInt32Digital, &p_BufTrigR);
    createParam(BufTrigWString, asynParamUInt32Digital, &p_BufTrigW);
    createParam(Cav4MechNoiseCoupleKOutWString, asynParamInt32Array, &p_Cav4MechNoiseCoupleKOutW);
    createParam(Cav4MechPrngIvaRString, asynParamInt32, &p_Cav4MechPrngIvaR);
    createParam(Cav4MechPrngIvaWString, asynParamInt32, &p_Cav4MechPrngIvaW);
    createParam(Cav4MechPrngIvbRString, asynParamInt32, &p_Cav4MechPrngIvbR);
    createParam(Cav4MechPrngIvbWString, asynParamInt32, &p_Cav4MechPrngIvbW);
    createParam(Cav4MechPrngRandomRunRString, asynParamInt32, &p_Cav4MechPrngRandomRunR);
    createParam(Cav4MechPrngRandomRunWString, asynParamInt32, &p_Cav4MechPrngRandomRunW);
    createParam(Cav4MechResonatorPropConstWString, asynParamInt32Array, &p_Cav4MechResonatorPropConstW);
    createParam(Cavity0DetuneRString, asynParamInt32, &p_Cavity0DetuneR);
    createParam(Cavity1DetuneRString, asynParamInt32, &p_Cavity1DetuneR);
    createParam(Cavity0ACavOffsetRString, asynParamInt32, &p_Cavity0ACavOffsetR);
    createParam(Cavity0ACavOffsetWString, asynParamInt32, &p_Cavity0ACavOffsetW);
    createParam(Cavity0AForOffsetRString, asynParamInt32, &p_Cavity0AForOffsetR);
    createParam(Cavity0AForOffsetWString, asynParamInt32, &p_Cavity0AForOffsetW);
    createParam(Cavity0ARflOffsetRString, asynParamInt32, &p_Cavity0ARflOffsetR);
    createParam(Cavity0ARflOffsetWString, asynParamInt32, &p_Cavity0ARflOffsetW);
    createParam(Cavity0AmpLpBwRString, asynParamInt32, &p_Cavity0AmpLpBwR);
    createParam(Cavity0AmpLpBwWString, asynParamInt32, &p_Cavity0AmpLpBwW);
    createParam(Cavity0ComprSatCtlRString, asynParamInt32, &p_Cavity0ComprSatCtlR);
    createParam(Cavity0ComprSatCtlWString, asynParamInt32, &p_Cavity0ComprSatCtlW);
    createParam(Cavity0Dot0KOutWString, asynParamInt32Array, &p_Cavity0Dot0KOutW);
    createParam(Cavity0Dot1KOutWString, asynParamInt32Array, &p_Cavity0Dot1KOutW);
    createParam(Cavity0Dot2KOutWString, asynParamInt32Array, &p_Cavity0Dot2KOutW);
    createParam(Cavity0DriveCoupleOutCouplingRString, asynParamInt32, &p_Cavity0DriveCoupleOutCouplingR);
    createParam(Cavity0DriveCoupleOutCouplingWString, asynParamInt32, &p_Cavity0DriveCoupleOutCouplingW);
    createParam(Cavity0DriveCoupleOutPhaseOffsetRString, asynParamInt32, &p_Cavity0DriveCoupleOutPhaseOffsetR);
    createParam(Cavity0DriveCoupleOutPhaseOffsetWString, asynParamInt32, &p_Cavity0DriveCoupleOutPhaseOffsetW);
    createParam(Cavity0Freq0CoarseFreqRString, asynParamInt32, &p_Cavity0Freq0CoarseFreqR);
    createParam(Cavity0Freq0CoarseFreqWString, asynParamInt32, &p_Cavity0Freq0CoarseFreqW);
    createParam(Cavity0Freq1CoarseFreqRString, asynParamInt32, &p_Cavity0Freq1CoarseFreqR);
    createParam(Cavity0Freq1CoarseFreqWString, asynParamInt32, &p_Cavity0Freq1CoarseFreqW);
    createParam(Cavity0Freq2CoarseFreqRString, asynParamInt32, &p_Cavity0Freq2CoarseFreqR);
    createParam(Cavity0Freq2CoarseFreqWString, asynParamInt32, &p_Cavity0Freq2CoarseFreqW);
    createParam(Cavity0Mode0BeamCouplingRString, asynParamInt32, &p_Cavity0Mode0BeamCouplingR);
    createParam(Cavity0Mode0BeamCouplingWString, asynParamInt32, &p_Cavity0Mode0BeamCouplingW);
    createParam(Cavity0Mode0BwRString, asynParamInt32, &p_Cavity0Mode0BwR);
    createParam(Cavity0Mode0BwWString, asynParamInt32, &p_Cavity0Mode0BwW);
    createParam(Cavity0Mode0CoupleOutCouplingRString, asynParamInt32, &p_Cavity0Mode0CoupleOutCouplingR);
    createParam(Cavity0Mode0CoupleOutCouplingWString, asynParamInt32, &p_Cavity0Mode0CoupleOutCouplingW);
    createParam(Cavity0Mode0CoupleOutPhaseOffsetRString, asynParamInt32, &p_Cavity0Mode0CoupleOutPhaseOffsetR);
    createParam(Cavity0Mode0CoupleOutPhaseOffsetWString, asynParamInt32, &p_Cavity0Mode0CoupleOutPhaseOffsetW);
    createParam(Cavity0Mode0DriveCouplingRString, asynParamInt32, &p_Cavity0Mode0DriveCouplingR);
    createParam(Cavity0Mode0DriveCouplingWString, asynParamInt32, &p_Cavity0Mode0DriveCouplingW);
    createParam(Cavity0Mode1BeamCouplingRString, asynParamInt32, &p_Cavity0Mode1BeamCouplingR);
    createParam(Cavity0Mode1BeamCouplingWString, asynParamInt32, &p_Cavity0Mode1BeamCouplingW);
    createParam(Cavity0Mode1BwRString, asynParamInt32, &p_Cavity0Mode1BwR);
    createParam(Cavity0Mode1BwWString, asynParamInt32, &p_Cavity0Mode1BwW);
    createParam(Cavity0Mode1CoupleOutCouplingRString, asynParamInt32, &p_Cavity0Mode1CoupleOutCouplingR);
    createParam(Cavity0Mode1CoupleOutCouplingWString, asynParamInt32, &p_Cavity0Mode1CoupleOutCouplingW);
    createParam(Cavity0Mode1CoupleOutPhaseOffsetRString, asynParamInt32, &p_Cavity0Mode1CoupleOutPhaseOffsetR);
    createParam(Cavity0Mode1CoupleOutPhaseOffsetWString, asynParamInt32, &p_Cavity0Mode1CoupleOutPhaseOffsetW);
    createParam(Cavity0Mode1DriveCouplingRString, asynParamInt32, &p_Cavity0Mode1DriveCouplingR);
    createParam(Cavity0Mode1DriveCouplingWString, asynParamInt32, &p_Cavity0Mode1DriveCouplingW);
    createParam(Cavity0Mode2BeamCouplingRString, asynParamInt32, &p_Cavity0Mode2BeamCouplingR);
    createParam(Cavity0Mode2BeamCouplingWString, asynParamInt32, &p_Cavity0Mode2BeamCouplingW);
    createParam(Cavity0Mode2BwRString, asynParamInt32, &p_Cavity0Mode2BwR);
    createParam(Cavity0Mode2BwWString, asynParamInt32, &p_Cavity0Mode2BwW);
    createParam(Cavity0Mode2CoupleOutCouplingRString, asynParamInt32, &p_Cavity0Mode2CoupleOutCouplingR);
    createParam(Cavity0Mode2CoupleOutCouplingWString, asynParamInt32, &p_Cavity0Mode2CoupleOutCouplingW);
    createParam(Cavity0Mode2CoupleOutPhaseOffsetRString, asynParamInt32, &p_Cavity0Mode2CoupleOutPhaseOffsetR);
    createParam(Cavity0Mode2CoupleOutPhaseOffsetWString, asynParamInt32, &p_Cavity0Mode2CoupleOutPhaseOffsetW);
    createParam(Cavity0Mode2DriveCouplingRString, asynParamInt32, &p_Cavity0Mode2DriveCouplingR);
    createParam(Cavity0Mode2DriveCouplingWString, asynParamInt32, &p_Cavity0Mode2DriveCouplingW);
    createParam(Cavity0ModuloRString, asynParamInt32, &p_Cavity0ModuloR);
    createParam(Cavity0ModuloWString, asynParamInt32, &p_Cavity0ModuloW);
    createParam(Cavity0OuterProd0KOutWString, asynParamInt32Array, &p_Cavity0OuterProd0KOutW);
    createParam(Cavity0OuterProd1KOutWString, asynParamInt32Array, &p_Cavity0OuterProd1KOutW);
    createParam(Cavity0OuterProd2KOutWString, asynParamInt32Array, &p_Cavity0OuterProd2KOutW);
    createParam(Cavity0PhaseStepRString, asynParamInt32, &p_Cavity0PhaseStepR);
    createParam(Cavity0PhaseStepWString, asynParamInt32, &p_Cavity0PhaseStepW);
    createParam(Cavity0PiezoCoupleKOutWString, asynParamInt32Array, &p_Cavity0PiezoCoupleKOutW);
    createParam(Cavity0PrngIvaRString, asynParamInt32, &p_Cavity0PrngIvaR);
    createParam(Cavity0PrngIvaWString, asynParamInt32, &p_Cavity0PrngIvaW);
    createParam(Cavity0PrngIvbRString, asynParamInt32, &p_Cavity0PrngIvbR);
    createParam(Cavity0PrngIvbWString, asynParamInt32, &p_Cavity0PrngIvbW);
    createParam(Cavity0PrngRandomRunRString, asynParamInt32, &p_Cavity0PrngRandomRunR);
    createParam(Cavity0PrngRandomRunWString, asynParamInt32, &p_Cavity0PrngRandomRunW);
    createParam(Cavity1ACavOffsetRString, asynParamInt32, &p_Cavity1ACavOffsetR);
    createParam(Cavity1ACavOffsetWString, asynParamInt32, &p_Cavity1ACavOffsetW);
    createParam(Cavity1AForOffsetRString, asynParamInt32, &p_Cavity1AForOffsetR);
    createParam(Cavity1AForOffsetWString, asynParamInt32, &p_Cavity1AForOffsetW);
    createParam(Cavity1ARflOffsetRString, asynParamInt32, &p_Cavity1ARflOffsetR);
    createParam(Cavity1ARflOffsetWString, asynParamInt32, &p_Cavity1ARflOffsetW);
    createParam(Cavity1AmpLpBwRString, asynParamInt32, &p_Cavity1AmpLpBwR);
    createParam(Cavity1AmpLpBwWString, asynParamInt32, &p_Cavity1AmpLpBwW);
    createParam(Cavity1ComprSatCtlRString, asynParamInt32, &p_Cavity1ComprSatCtlR);
    createParam(Cavity1ComprSatCtlWString, asynParamInt32, &p_Cavity1ComprSatCtlW);
    createParam(Cavity1Dot0KOutWString, asynParamInt32Array, &p_Cavity1Dot0KOutW);
    createParam(Cavity1Dot1KOutWString, asynParamInt32Array, &p_Cavity1Dot1KOutW);
    createParam(Cavity1Dot2KOutWString, asynParamInt32Array, &p_Cavity1Dot2KOutW);
    createParam(Cavity1DriveCoupleOutCouplingRString, asynParamInt32, &p_Cavity1DriveCoupleOutCouplingR);
    createParam(Cavity1DriveCoupleOutCouplingWString, asynParamInt32, &p_Cavity1DriveCoupleOutCouplingW);
    createParam(Cavity1DriveCoupleOutPhaseOffsetRString, asynParamInt32, &p_Cavity1DriveCoupleOutPhaseOffsetR);
    createParam(Cavity1DriveCoupleOutPhaseOffsetWString, asynParamInt32, &p_Cavity1DriveCoupleOutPhaseOffsetW);
    createParam(Cavity1Freq0CoarseFreqRString, asynParamInt32, &p_Cavity1Freq0CoarseFreqR);
    createParam(Cavity1Freq0CoarseFreqWString, asynParamInt32, &p_Cavity1Freq0CoarseFreqW);
    createParam(Cavity1Freq1CoarseFreqRString, asynParamInt32, &p_Cavity1Freq1CoarseFreqR);
    createParam(Cavity1Freq1CoarseFreqWString, asynParamInt32, &p_Cavity1Freq1CoarseFreqW);
    createParam(Cavity1Freq2CoarseFreqRString, asynParamInt32, &p_Cavity1Freq2CoarseFreqR);
    createParam(Cavity1Freq2CoarseFreqWString, asynParamInt32, &p_Cavity1Freq2CoarseFreqW);
    createParam(Cavity1Mode0BeamCouplingRString, asynParamInt32, &p_Cavity1Mode0BeamCouplingR);
    createParam(Cavity1Mode0BeamCouplingWString, asynParamInt32, &p_Cavity1Mode0BeamCouplingW);
    createParam(Cavity1Mode0BwRString, asynParamInt32, &p_Cavity1Mode0BwR);
    createParam(Cavity1Mode0BwWString, asynParamInt32, &p_Cavity1Mode0BwW);
    createParam(Cavity1Mode0CoupleOutCouplingRString, asynParamInt32, &p_Cavity1Mode0CoupleOutCouplingR);
    createParam(Cavity1Mode0CoupleOutCouplingWString, asynParamInt32, &p_Cavity1Mode0CoupleOutCouplingW);
    createParam(Cavity1Mode0CoupleOutPhaseOffsetRString, asynParamInt32, &p_Cavity1Mode0CoupleOutPhaseOffsetR);
    createParam(Cavity1Mode0CoupleOutPhaseOffsetWString, asynParamInt32, &p_Cavity1Mode0CoupleOutPhaseOffsetW);
    createParam(Cavity1Mode0DriveCouplingRString, asynParamInt32, &p_Cavity1Mode0DriveCouplingR);
    createParam(Cavity1Mode0DriveCouplingWString, asynParamInt32, &p_Cavity1Mode0DriveCouplingW);
    createParam(Cavity1Mode1BeamCouplingRString, asynParamInt32, &p_Cavity1Mode1BeamCouplingR);
    createParam(Cavity1Mode1BeamCouplingWString, asynParamInt32, &p_Cavity1Mode1BeamCouplingW);
    createParam(Cavity1Mode1BwRString, asynParamInt32, &p_Cavity1Mode1BwR);
    createParam(Cavity1Mode1BwWString, asynParamInt32, &p_Cavity1Mode1BwW);
    createParam(Cavity1Mode1CoupleOutCouplingRString, asynParamInt32, &p_Cavity1Mode1CoupleOutCouplingR);
    createParam(Cavity1Mode1CoupleOutCouplingWString, asynParamInt32, &p_Cavity1Mode1CoupleOutCouplingW);
    createParam(Cavity1Mode1CoupleOutPhaseOffsetRString, asynParamInt32, &p_Cavity1Mode1CoupleOutPhaseOffsetR);
    createParam(Cavity1Mode1CoupleOutPhaseOffsetWString, asynParamInt32, &p_Cavity1Mode1CoupleOutPhaseOffsetW);
    createParam(Cavity1Mode1DriveCouplingRString, asynParamInt32, &p_Cavity1Mode1DriveCouplingR);
    createParam(Cavity1Mode1DriveCouplingWString, asynParamInt32, &p_Cavity1Mode1DriveCouplingW);
    createParam(Cavity1Mode2BeamCouplingRString, asynParamInt32, &p_Cavity1Mode2BeamCouplingR);
    createParam(Cavity1Mode2BeamCouplingWString, asynParamInt32, &p_Cavity1Mode2BeamCouplingW);
    createParam(Cavity1Mode2BwRString, asynParamInt32, &p_Cavity1Mode2BwR);
    createParam(Cavity1Mode2BwWString, asynParamInt32, &p_Cavity1Mode2BwW);
    createParam(Cavity1Mode2CoupleOutCouplingRString, asynParamInt32, &p_Cavity1Mode2CoupleOutCouplingR);
    createParam(Cavity1Mode2CoupleOutCouplingWString, asynParamInt32, &p_Cavity1Mode2CoupleOutCouplingW);
    createParam(Cavity1Mode2CoupleOutPhaseOffsetRString, asynParamInt32, &p_Cavity1Mode2CoupleOutPhaseOffsetR);
    createParam(Cavity1Mode2CoupleOutPhaseOffsetWString, asynParamInt32, &p_Cavity1Mode2CoupleOutPhaseOffsetW);
    createParam(Cavity1Mode2DriveCouplingRString, asynParamInt32, &p_Cavity1Mode2DriveCouplingR);
    createParam(Cavity1Mode2DriveCouplingWString, asynParamInt32, &p_Cavity1Mode2DriveCouplingW);
    createParam(Cavity1ModuloRString, asynParamInt32, &p_Cavity1ModuloR);
    createParam(Cavity1ModuloWString, asynParamInt32, &p_Cavity1ModuloW);
    createParam(Cavity1OuterProd0KOutWString, asynParamInt32Array, &p_Cavity1OuterProd0KOutW);
    createParam(Cavity1OuterProd1KOutWString, asynParamInt32Array, &p_Cavity1OuterProd1KOutW);
    createParam(Cavity1OuterProd2KOutWString, asynParamInt32Array, &p_Cavity1OuterProd2KOutW);
    createParam(Cavity1PhaseStepRString, asynParamInt32, &p_Cavity1PhaseStepR);
    createParam(Cavity1PhaseStepWString, asynParamInt32, &p_Cavity1PhaseStepW);
    createParam(Cavity1PiezoCoupleKOutWString, asynParamInt32Array, &p_Cavity1PiezoCoupleKOutW);
    createParam(Cavity1PrngIvaRString, asynParamInt32, &p_Cavity1PrngIvaR);
    createParam(Cavity1PrngIvaWString, asynParamInt32, &p_Cavity1PrngIvaW);
    createParam(Cavity1PrngIvbRString, asynParamInt32, &p_Cavity1PrngIvbR);
    createParam(Cavity1PrngIvbWString, asynParamInt32, &p_Cavity1PrngIvbW);
    createParam(Cavity1PrngRandomRunRString, asynParamInt32, &p_Cavity1PrngRandomRunR);
    createParam(Cavity1PrngRandomRunWString, asynParamInt32, &p_Cavity1PrngRandomRunW);
    createParam(CcErrorClearRString, asynParamInt32, &p_CcErrorClearR);
    createParam(CcErrorClearWString, asynParamInt32, &p_CcErrorClearW);
    createParam(CcLoc1RString, asynParamInt32, &p_CcLoc1R);
    createParam(CcLoc1WString, asynParamInt32, &p_CcLoc1W);
    createParam(Cct1Cavity0StatusAuxRString, asynParamInt32, &p_Cct1Cavity0StatusAuxR);
    createParam(Cct1Cavity0StatusAuxWString, asynParamInt32, &p_Cct1Cavity0StatusAuxW);
    createParam(Cct1Cavity1StatusAuxRString, asynParamInt32, &p_Cct1Cavity1StatusAuxR);
    createParam(Cct1Cavity1StatusAuxWString, asynParamInt32, &p_Cct1Cavity1StatusAuxW);
    createParam(CicPeriodRString, asynParamInt32, &p_CicPeriodR);
    createParam(CicPeriodWString, asynParamInt32, &p_CicPeriodW);
    createParam(CicShiftRString, asynParamInt32, &p_CicShiftR);
    createParam(CicShiftWString, asynParamInt32, &p_CicShiftW);
    createParam(CircleBufFlipRString, asynParamUInt32Digital, &p_CircleBufFlipR);
    createParam(CircleBufFlipWString, asynParamUInt32Digital, &p_CircleBufFlipW);
    createParam(ClkPhaseDiffOutU2RString, asynParamInt32, &p_ClkPhaseDiffOutU2R);
    createParam(ClkPhaseDiffOutU3RString, asynParamInt32, &p_ClkPhaseDiffOutU3R);
    createParam(ClkStatusOutRString, asynParamInt32, &p_ClkStatusOutR);
    createParam(ConfigU15SpiDataAddrRRString, asynParamInt32, &p_ConfigU15SpiDataAddrRR);
    createParam(ConfigU15SpiDataAddrRWString, asynParamInt32, &p_ConfigU15SpiDataAddrRW);
    createParam(ConfigU15SpiReadAndStartRRString, asynParamInt32, &p_ConfigU15SpiReadAndStartRR);
    createParam(ConfigU15SpiReadAndStartRWString, asynParamInt32, &p_ConfigU15SpiReadAndStartRW);
    createParam(ConfigU18SpiDataAddrRRString, asynParamInt32, &p_ConfigU18SpiDataAddrRR);
    createParam(ConfigU18SpiDataAddrRWString, asynParamInt32, &p_ConfigU18SpiDataAddrRW);
    createParam(ConfigU18SpiReadAndStartRRString, asynParamInt32, &p_ConfigU18SpiReadAndStartRR);
    createParam(ConfigU18SpiReadAndStartRWString, asynParamInt32, &p_ConfigU18SpiReadAndStartRW);
    createParam(ConfigU2ClkResetRRString, asynParamInt32, &p_ConfigU2ClkResetRR);
    createParam(ConfigU2ClkResetRWString, asynParamInt32, &p_ConfigU2ClkResetRW);
    createParam(ConfigU2IserdesResetRRString, asynParamInt32, &p_ConfigU2IserdesResetRR);
    createParam(ConfigU2IserdesResetRWString, asynParamInt32, &p_ConfigU2IserdesResetRW);
    createParam(ConfigU3ClkResetRRString, asynParamInt32, &p_ConfigU3ClkResetRR);
    createParam(ConfigU3ClkResetRWString, asynParamInt32, &p_ConfigU3ClkResetRW);
    createParam(ConfigU3IserdesResetRRString, asynParamInt32, &p_ConfigU3IserdesResetRR);
    createParam(ConfigU3IserdesResetRWString, asynParamInt32, &p_ConfigU3IserdesResetRW);
    createParam(ConfigU4ResetRRString, asynParamInt32, &p_ConfigU4ResetRR);
    createParam(ConfigU4ResetRWString, asynParamInt32, &p_ConfigU4ResetRW);
    createParam(ConfigBanyanMaskRString, asynParamInt32, &p_ConfigBanyanMaskR);
    createParam(ConfigBanyanMaskWString, asynParamInt32, &p_ConfigBanyanMaskW);
    createParam(ConfigBitslipRString, asynParamInt32, &p_ConfigBitslipR);
    createParam(ConfigBitslipWString, asynParamInt32, &p_ConfigBitslipW);
    createParam(ConfigClkStatusWeRString, asynParamInt32, &p_ConfigClkStatusWeR);
    createParam(ConfigClkStatusWeWString, asynParamInt32, &p_ConfigClkStatusWeW);
    createParam(ConfigIdelayctrlResetRRString, asynParamInt32, &p_ConfigIdelayctrlResetRR);
    createParam(ConfigIdelayctrlResetRWString, asynParamInt32, &p_ConfigIdelayctrlResetRW);
    createParam(ConfigLlspiWeRString, asynParamInt32, &p_ConfigLlspiWeR);
    createParam(ConfigLlspiWeWString, asynParamInt32, &p_ConfigLlspiWeW);
    createParam(ConfigMmcmResetRRString, asynParamInt32, &p_ConfigMmcmResetRR);
    createParam(ConfigMmcmResetRWString, asynParamInt32, &p_ConfigMmcmResetRW);
    createParam(ConfigPeriphConfigRString, asynParamInt32, &p_ConfigPeriphConfigR);
    createParam(ConfigPeriphConfigWString, asynParamInt32, &p_ConfigPeriphConfigW);
    createParam(ConfigPhasexTrigRString, asynParamInt32, &p_ConfigPhasexTrigR);
    createParam(ConfigPhasexTrigWString, asynParamInt32, &p_ConfigPhasexTrigW);
    createParam(ConfigRawadcTrigRString, asynParamInt32, &p_ConfigRawadcTrigR);
    createParam(ConfigRawadcTrigWString, asynParamInt32, &p_ConfigRawadcTrigW);
    createParam(ConfigScanTriggerWeRString, asynParamInt32, &p_ConfigScanTriggerWeR);
    createParam(ConfigScanTriggerWeWString, asynParamInt32, &p_ConfigScanTriggerWeW);
    createParam(ConfigScannerDebugRString, asynParamInt32, &p_ConfigScannerDebugR);
    createParam(ConfigScannerDebugWString, asynParamInt32, &p_ConfigScannerDebugW);
    createParam(ConfigSyncAd7794CsetRString, asynParamInt32, &p_ConfigSyncAd7794CsetR);
    createParam(ConfigSyncAd7794CsetWString, asynParamInt32, &p_ConfigSyncAd7794CsetW);
    createParam(ConfigSyncTps62210CsetRString, asynParamInt32, &p_ConfigSyncTps62210CsetR);
    createParam(ConfigSyncTps62210CsetWString, asynParamInt32, &p_ConfigSyncTps62210CsetW);
    createParam(CrcErrorsRString, asynParamInt32, &p_CrcErrorsR);
    createParam(CtraceRunningRString, asynParamInt32, &p_CtraceRunningR);
    createParam(DacDdsResetRString, asynParamInt32, &p_DacDdsResetR);
    createParam(DacDdsResetWString, asynParamInt32, &p_DacDdsResetW);
    createParam(DacIqPhaseRString, asynParamInt32, &p_DacIqPhaseR);
    createParam(DacIqPhaseWString, asynParamInt32, &p_DacIqPhaseW);
    createParam(DacModeRString, asynParamInt32, &p_DacModeR);
    createParam(DacModeWString, asynParamInt32, &p_DacModeW);
    createParam(DdsaModuloRString, asynParamInt32, &p_DdsaModuloR);
    createParam(DdsaModuloWString, asynParamInt32, &p_DdsaModuloW);
    createParam(DdsaPhstepHRString, asynParamInt32, &p_DdsaPhstepHR);
    createParam(DdsaPhstepHWString, asynParamInt32, &p_DdsaPhstepHW);
    createParam(DdsaPhstepLRString, asynParamInt32, &p_DdsaPhstepLR);
    createParam(DdsaPhstepLWString, asynParamInt32, &p_DdsaPhstepLW);
    createParam(DomainJumpRealignRString, asynParamInt32, &p_DomainJumpRealignR);
    createParam(DomainJumpRealignWString, asynParamInt32, &p_DomainJumpRealignW);
    createParam(FfffffffRString, asynParamInt32, &p_FfffffffR);
    createParam(Frequency4XoutRString, asynParamInt32, &p_Frequency4XoutR);
    createParam(FrequencyAdcRString, asynParamInt32, &p_FrequencyAdcR);
    createParam(FrequencyClkout3RString, asynParamInt32, &p_FrequencyClkout3R);
    createParam(FrequencyDcoRString, asynParamInt32, &p_FrequencyDcoR);
    createParam(FrequencyGtxRxRString, asynParamInt32, &p_FrequencyGtxRxR);
    createParam(FrequencyGtxTxRString, asynParamInt32, &p_FrequencyGtxTxR);
    createParam(Hello0RString, asynParamInt32, &p_Hello0R);
    createParam(Hello1RString, asynParamInt32, &p_Hello1R);
    createParam(Hello2RString, asynParamInt32, &p_Hello2R);
    createParam(Hello3RString, asynParamInt32, &p_Hello3R);
    createParam(HistCountWStrobeRString, asynParamInt32, &p_HistCountWStrobeR);
    createParam(HistCountWStrobeWString, asynParamInt32, &p_HistCountWStrobeW);
    createParam(HistDoutRString, asynParamInt32Array, &p_HistDoutR);
    createParam(HistStatusRString, asynParamInt32, &p_HistStatusR);
    createParam(IccCfgRString, asynParamInt32, &p_IccCfgR);
    createParam(IccCfgWString, asynParamInt32, &p_IccCfgW);
    createParam(IdelayBaseRString, asynParamInt32, &p_IdelayBaseR);
    createParam(IdelayValueOutU2LsbRString, asynParamInt32, &p_IdelayValueOutU2LsbR);
    createParam(IdelayValueOutU2MsbRString, asynParamInt32, &p_IdelayValueOutU2MsbR);
    createParam(IdelayValueOutU3LsbRString, asynParamInt32, &p_IdelayValueOutU3LsbR);
    createParam(IdelayValueOutU3MsbRString, asynParamInt32, &p_IdelayValueOutU3MsbR);
    createParam(LlrfCircleDataRString, asynParamInt32Array, &p_LlrfCircleDataR);
    createParam(LlrfCircleReadyRString, asynParamUInt32Digital, &p_LlrfCircleReadyR);
    createParam(LlrfDspDacEnRString, asynParamInt32, &p_LlrfDspDacEnR);
    createParam(LlrfDspDacEnWString, asynParamInt32, &p_LlrfDspDacEnW);
    createParam(LlspiResultRString, asynParamInt32, &p_LlspiResultR);
    createParam(LlspiStatusRString, asynParamInt32, &p_LlspiStatusR);
    createParam(LoAmpRString, asynParamInt32, &p_LoAmpR);
    createParam(LoAmpWString, asynParamInt32, &p_LoAmpW);
    createParam(ModuloRString, asynParamInt32, &p_ModuloR);
    createParam(ModuloWString, asynParamInt32, &p_ModuloW);
    createParam(PhaseStepHRString, asynParamInt32, &p_PhaseStepHR);
    createParam(PhaseStepHWString, asynParamInt32, &p_PhaseStepHW);
    createParam(PhaseStepLRString, asynParamInt32, &p_PhaseStepLR);
    createParam(PhaseStepLWString, asynParamInt32, &p_PhaseStepLW);
    createParam(PhasexDoutRString, asynParamInt32Array, &p_PhasexDoutR);
    createParam(PhasexStatusRString, asynParamInt32, &p_PhasexStatusR);
    createParam(PrcDspCavSelRString, asynParamInt32, &p_PrcDspCavSelR);
    createParam(PrcDspCavSelWString, asynParamInt32, &p_PrcDspCavSelW);
    createParam(PrcDspPrlCfgRString, asynParamInt32, &p_PrcDspPrlCfgR);
    createParam(PrcDspPrlCfgWString, asynParamInt32, &p_PrcDspPrlCfgW);
    createParam(PrcDspPrlGainRString, asynParamInt32, &p_PrcDspPrlGainR);
    createParam(PrcDspPrlGainWString, asynParamInt32, &p_PrcDspPrlGainW);
    createParam(QsfpBufRString, asynParamInt32Array, &p_QsfpBufR);
    createParam(QsfpI2CRegRString, asynParamInt32, &p_QsfpI2CRegR);
    createParam(QsfpI2CRegWString, asynParamInt32, &p_QsfpI2CRegW);
    createParam(RewindRString, asynParamInt32, &p_RewindR);
    createParam(RewindWString, asynParamInt32, &p_RewindW);
    createParam(ScannerResultRString, asynParamInt32Array, &p_ScannerResultR);
    createParam(SfpAddressSetRString, asynParamInt32, &p_SfpAddressSetR);
    createParam(SfpAddressSetWString, asynParamInt32, &p_SfpAddressSetW);
    createParam(Shell0DspChanKeepRString, asynParamUInt32Digital, &p_Shell0DspChanKeepR);
    createParam(Shell0DspChanKeepWString, asynParamUInt32Digital, &p_Shell0DspChanKeepW);
    createParam(Shell0DspFdbkCoreCoarseScaleRString, asynParamInt32, &p_Shell0DspFdbkCoreCoarseScaleR);
    createParam(Shell0DspFdbkCoreCoarseScaleWString, asynParamInt32, &p_Shell0DspFdbkCoreCoarseScaleW);
    createParam(Shell0DspFdbkCoreMpProcCoeffRString, asynParamInt32, &p_Shell0DspFdbkCoreMpProcCoeffR);
    createParam(Shell0DspFdbkCoreMpProcCoeffWString, asynParamInt32, &p_Shell0DspFdbkCoreMpProcCoeffW);
    createParam(Shell0DspFdbkCoreMpProcLimRString, asynParamInt32, &p_Shell0DspFdbkCoreMpProcLimR);
    createParam(Shell0DspFdbkCoreMpProcLimWString, asynParamInt32, &p_Shell0DspFdbkCoreMpProcLimW);
    createParam(Shell0DspFdbkCoreMpProcPhOffsetRString, asynParamInt32, &p_Shell0DspFdbkCoreMpProcPhOffsetR);
    createParam(Shell0DspFdbkCoreMpProcPhOffsetWString, asynParamInt32, &p_Shell0DspFdbkCoreMpProcPhOffsetW);
    createParam(Shell0DspFdbkCoreMpProcSelEnRString, asynParamInt32, &p_Shell0DspFdbkCoreMpProcSelEnR);
    createParam(Shell0DspFdbkCoreMpProcSelEnWString, asynParamInt32, &p_Shell0DspFdbkCoreMpProcSelEnW);
    createParam(Shell0DspFdbkCoreMpProcSelThreshRString, asynParamInt32, &p_Shell0DspFdbkCoreMpProcSelThreshR);
    createParam(Shell0DspFdbkCoreMpProcSelThreshWString, asynParamInt32, &p_Shell0DspFdbkCoreMpProcSelThreshW);
    createParam(Shell0DspFdbkCoreMpProcSetmpRString, asynParamInt32, &p_Shell0DspFdbkCoreMpProcSetmpR);
    createParam(Shell0DspFdbkCoreMpProcSetmpWString, asynParamInt32, &p_Shell0DspFdbkCoreMpProcSetmpW);
    createParam(Shell0DspLpNotchLp1AKxRString, asynParamInt32, &p_Shell0DspLpNotchLp1AKxR);
    createParam(Shell0DspLpNotchLp1AKxWString, asynParamInt32, &p_Shell0DspLpNotchLp1AKxW);
    createParam(Shell0DspLpNotchLp1AKyRString, asynParamInt32, &p_Shell0DspLpNotchLp1AKyR);
    createParam(Shell0DspLpNotchLp1AKyWString, asynParamInt32, &p_Shell0DspLpNotchLp1AKyW);
    createParam(Shell0DspLpNotchLp1BKxRString, asynParamInt32, &p_Shell0DspLpNotchLp1BKxR);
    createParam(Shell0DspLpNotchLp1BKxWString, asynParamInt32, &p_Shell0DspLpNotchLp1BKxW);
    createParam(Shell0DspLpNotchLp1BKyRString, asynParamInt32, &p_Shell0DspLpNotchLp1BKyR);
    createParam(Shell0DspLpNotchLp1BKyWString, asynParamInt32, &p_Shell0DspLpNotchLp1BKyW);
    createParam(Shell0DspModuloRString, asynParamInt32, &p_Shell0DspModuloR);
    createParam(Shell0DspModuloWString, asynParamInt32, &p_Shell0DspModuloW);
    createParam(Shell0DspPhaseStepRString, asynParamInt32, &p_Shell0DspPhaseStepR);
    createParam(Shell0DspPhaseStepWString, asynParamInt32, &p_Shell0DspPhaseStepW);
    createParam(Shell0DspPiezoPiezoDcRString, asynParamInt32, &p_Shell0DspPiezoPiezoDcR);
    createParam(Shell0DspPiezoPiezoDcWString, asynParamInt32, &p_Shell0DspPiezoPiezoDcW);
    createParam(Shell0DspPiezoSfConstsRString, asynParamInt32, &p_Shell0DspPiezoSfConstsR);
    createParam(Shell0DspPiezoSfConstsWString, asynParamInt32, &p_Shell0DspPiezoSfConstsW);
    createParam(Shell0DspTagRString, asynParamInt32, &p_Shell0DspTagR);
    createParam(Shell0DspTagWString, asynParamInt32, &p_Shell0DspTagW);
    createParam(Shell0DspUseFiberIqRString, asynParamInt32, &p_Shell0DspUseFiberIqR);
    createParam(Shell0DspUseFiberIqWString, asynParamInt32, &p_Shell0DspUseFiberIqW);
    createParam(Shell0DspWaveSampPerRString, asynParamInt32, &p_Shell0DspWaveSampPerR);
    createParam(Shell0DspWaveSampPerWString, asynParamInt32, &p_Shell0DspWaveSampPerW);
    createParam(Shell0DspWaveShiftRString, asynParamInt32, &p_Shell0DspWaveShiftR);
    createParam(Shell0DspWaveShiftWString, asynParamInt32, &p_Shell0DspWaveShiftW);
    createParam(Shell0SlowDataRString, asynParamInt32Array, &p_Shell0SlowDataR);
    createParam(Shell1DspChanKeepRString, asynParamUInt32Digital, &p_Shell1DspChanKeepR);
    createParam(Shell1DspChanKeepWString, asynParamUInt32Digital, &p_Shell1DspChanKeepW);
    createParam(Shell1DspFdbkCoreCoarseScaleRString, asynParamInt32, &p_Shell1DspFdbkCoreCoarseScaleR);
    createParam(Shell1DspFdbkCoreCoarseScaleWString, asynParamInt32, &p_Shell1DspFdbkCoreCoarseScaleW);
    createParam(Shell1DspFdbkCoreMpProcCoeffRString, asynParamInt32, &p_Shell1DspFdbkCoreMpProcCoeffR);
    createParam(Shell1DspFdbkCoreMpProcCoeffWString, asynParamInt32, &p_Shell1DspFdbkCoreMpProcCoeffW);
    createParam(Shell1DspFdbkCoreMpProcLimRString, asynParamInt32, &p_Shell1DspFdbkCoreMpProcLimR);
    createParam(Shell1DspFdbkCoreMpProcLimWString, asynParamInt32, &p_Shell1DspFdbkCoreMpProcLimW);
    createParam(Shell1DspFdbkCoreMpProcPhOffsetRString, asynParamInt32, &p_Shell1DspFdbkCoreMpProcPhOffsetR);
    createParam(Shell1DspFdbkCoreMpProcPhOffsetWString, asynParamInt32, &p_Shell1DspFdbkCoreMpProcPhOffsetW);
    createParam(Shell1DspFdbkCoreMpProcSelEnRString, asynParamInt32, &p_Shell1DspFdbkCoreMpProcSelEnR);
    createParam(Shell1DspFdbkCoreMpProcSelEnWString, asynParamInt32, &p_Shell1DspFdbkCoreMpProcSelEnW);
    createParam(Shell1DspFdbkCoreMpProcSelThreshRString, asynParamInt32, &p_Shell1DspFdbkCoreMpProcSelThreshR);
    createParam(Shell1DspFdbkCoreMpProcSelThreshWString, asynParamInt32, &p_Shell1DspFdbkCoreMpProcSelThreshW);
    createParam(Shell1DspFdbkCoreMpProcSetmpRString, asynParamInt32, &p_Shell1DspFdbkCoreMpProcSetmpR);
    createParam(Shell1DspFdbkCoreMpProcSetmpWString, asynParamInt32, &p_Shell1DspFdbkCoreMpProcSetmpW);
    createParam(Shell1DspLpNotchLp1AKxRString, asynParamInt32, &p_Shell1DspLpNotchLp1AKxR);
    createParam(Shell1DspLpNotchLp1AKxWString, asynParamInt32, &p_Shell1DspLpNotchLp1AKxW);
    createParam(Shell1DspLpNotchLp1AKyRString, asynParamInt32, &p_Shell1DspLpNotchLp1AKyR);
    createParam(Shell1DspLpNotchLp1AKyWString, asynParamInt32, &p_Shell1DspLpNotchLp1AKyW);
    createParam(Shell1DspLpNotchLp1BKxRString, asynParamInt32, &p_Shell1DspLpNotchLp1BKxR);
    createParam(Shell1DspLpNotchLp1BKxWString, asynParamInt32, &p_Shell1DspLpNotchLp1BKxW);
    createParam(Shell1DspLpNotchLp1BKyRString, asynParamInt32, &p_Shell1DspLpNotchLp1BKyR);
    createParam(Shell1DspLpNotchLp1BKyWString, asynParamInt32, &p_Shell1DspLpNotchLp1BKyW);
    createParam(Shell1DspModuloRString, asynParamInt32, &p_Shell1DspModuloR);
    createParam(Shell1DspModuloWString, asynParamInt32, &p_Shell1DspModuloW);
    createParam(Shell1DspPhaseStepRString, asynParamInt32, &p_Shell1DspPhaseStepR);
    createParam(Shell1DspPhaseStepWString, asynParamInt32, &p_Shell1DspPhaseStepW);
    createParam(Shell1DspPiezoPiezoDcRString, asynParamInt32, &p_Shell1DspPiezoPiezoDcR);
    createParam(Shell1DspPiezoPiezoDcWString, asynParamInt32, &p_Shell1DspPiezoPiezoDcW);
    createParam(Shell1DspPiezoSfConstsRString, asynParamInt32, &p_Shell1DspPiezoSfConstsR);
    createParam(Shell1DspPiezoSfConstsWString, asynParamInt32, &p_Shell1DspPiezoSfConstsW);
    createParam(Shell1DspTagRString, asynParamInt32, &p_Shell1DspTagR);
    createParam(Shell1DspTagWString, asynParamInt32, &p_Shell1DspTagW);
    createParam(Shell1DspUseFiberIqRString, asynParamInt32, &p_Shell1DspUseFiberIqR);
    createParam(Shell1DspUseFiberIqWString, asynParamInt32, &p_Shell1DspUseFiberIqW);
    createParam(Shell1DspWaveSampPerRString, asynParamInt32, &p_Shell1DspWaveSampPerR);
    createParam(Shell1DspWaveSampPerWString, asynParamInt32, &p_Shell1DspWaveSampPerW);
    createParam(Shell1DspWaveShiftRString, asynParamInt32, &p_Shell1DspWaveShiftR);
    createParam(Shell1DspWaveShiftWString, asynParamInt32, &p_Shell1DspWaveShiftW);
    createParam(Shell1SlowDataRString, asynParamInt32Array, &p_Shell1SlowDataR);
    createParam(SlowChainOutRString, asynParamInt32, &p_SlowChainOutR);
    createParam(SsaStimAmpstepRString, asynParamInt32, &p_SsaStimAmpstepR);
    createParam(SsaStimAmpstepWString, asynParamInt32, &p_SsaStimAmpstepW);
    createParam(SsaStimEnRString, asynParamInt32, &p_SsaStimEnR);
    createParam(SsaStimEnWString, asynParamInt32, &p_SsaStimEnW);
    createParam(SsaStimGPeriodRString, asynParamInt32, &p_SsaStimGPeriodR);
    createParam(SsaStimGPeriodWString, asynParamInt32, &p_SsaStimGPeriodW);
    createParam(SsaStimPertstepRString, asynParamInt32, &p_SsaStimPertstepR);
    createParam(SsaStimPertstepWString, asynParamInt32, &p_SsaStimPertstepW);
    createParam(TagNowRString, asynParamInt32, &p_TagNowR);
    createParam(TagNowWString, asynParamInt32, &p_TagNowW);
    createParam(Tgen0DelayPcXxxWString, asynParamInt32Array, &p_Tgen0DelayPcXxxW);
    createParam(Tgen1DelayPcXxxWString, asynParamInt32Array, &p_Tgen1DelayPcXxxW);
    createParam(TraceIBufRString, asynParamInt32Array, &p_TraceIBufR);
    createParam(TraceIqBufRString, asynParamInt32Array, &p_TraceIqBufR);
    createParam(TraceKeepRString, asynParamUInt32Digital, &p_TraceKeepR);
    createParam(TraceKeepWString, asynParamUInt32Digital, &p_TraceKeepW);
    createParam(TraceQBufRString, asynParamInt32Array, &p_TraceQBufR);
    createParam(TraceResetWeRString, asynParamUInt32Digital, &p_TraceResetWeR);
    createParam(TraceResetWeWString, asynParamUInt32Digital, &p_TraceResetWeW);
    createParam(TraceStatus1RString, asynParamInt32, &p_TraceStatus1R);
    createParam(TraceStatus2RString, asynParamInt32, &p_TraceStatus2R);
    createParam(TrigInternalRString, asynParamInt32, &p_TrigInternalR);
    createParam(TrigInternalWString, asynParamInt32, &p_TrigInternalW);
    createParam(TrigModeRString, asynParamInt32, &p_TrigModeR);
    createParam(TrigModeWString, asynParamInt32, &p_TrigModeW);
    createParam(Wave0OutRString, asynParamInt32, &p_Wave0OutR);
    createParam(Wave0SrcRString, asynParamInt32, &p_Wave0SrcR);
    createParam(Wave0SrcWString, asynParamInt32, &p_Wave0SrcW);
    createParam(Wave1OutRString, asynParamInt32, &p_Wave1OutR);
    createParam(Wave1SrcRString, asynParamInt32, &p_Wave1SrcR);
    createParam(Wave1SrcWString, asynParamInt32, &p_Wave1SrcW);
    createParam(WaveformsAvailableRString, asynParamInt32, &p_WaveformsAvailableR);

    // Message size is the number of read registers, plus 1 nonce for every 175 read registers
    PolledRegMsgSize_ = scllrfPRCPolledRegCount + (scllrfPRCPolledRegCount / 175) + 1;
	// A canned request to read all registers
    pPolledRegMsg_ = new FpgaReg[PolledRegMsgSize_]
	{
		{ 0, 0 },
		{ (flagReadMask | Hello0RAdr), blankData },
		{ (flagReadMask | Hello1RAdr), blankData },
		{ (flagReadMask | Hello2RAdr), blankData },
		{ (flagReadMask | Hello3RAdr), blankData },
		{ (flagReadMask | ClkStatusOutRAdr), blankData },
		{ (flagReadMask | FfffffffRAdr), blankData },
		{ (flagReadMask | FrequencyAdcRAdr), blankData },
		{ (flagReadMask | Frequency4XoutRAdr), blankData },
		{ (flagReadMask | FrequencyClkout3RAdr), blankData },
		{ (flagReadMask | FrequencyDcoRAdr), blankData },
		{ (flagReadMask | Wave0OutRAdr), blankData },
		{ (flagReadMask | Wave1OutRAdr), blankData },
		{ (flagReadMask | AdcTestWave1OutRAdr), blankData },
		{ (flagReadMask | AdcTestWave2OutRAdr), blankData },
		{ (flagReadMask | AdcTestWave3OutRAdr), blankData },
		{ (flagReadMask | AdcTestWave4OutRAdr), blankData },
		{ (flagReadMask | CtraceRunningRAdr), blankData },
		{ (flagReadMask | FrequencyGtxTxRAdr), blankData },
		{ (flagReadMask | FrequencyGtxRxRAdr), blankData },
		{ (flagReadMask | HistStatusRAdr), blankData },
		{ (flagReadMask | PhasexStatusRAdr), blankData },
		{ (flagReadMask | CrcErrorsRAdr), blankData },
		{ (flagReadMask | Cavity0DetuneRAdr), blankData },
		{ (flagReadMask | Cavity1DetuneRAdr), blankData },
		{ (flagReadMask | AdcTestTrigCntRAdr), blankData },
		{ (flagReadMask | WaveformsAvailableRAdr), blankData },
		{ (flagReadMask | BanyanStatusRAdr), blankData },
		{ (flagReadMask | SlowChainOutRAdr), blankData },
		{ (flagReadMask | TraceStatus1RAdr), blankData },
		{ (flagReadMask | TraceStatus2RAdr), blankData },
		{ (flagReadMask | LlrfCircleReadyRAdr), blankData },
		{ (flagReadMask | IdelayBaseRAdr), blankData },
		{ (flagReadMask | IdelayBaseRAdr) + 1, blankData },
		{ (flagReadMask | IdelayBaseRAdr) + 2, blankData },
		{ (flagReadMask | IdelayBaseRAdr) + 3, blankData },
		{ (flagReadMask | IdelayBaseRAdr) + 4, blankData },
		{ (flagReadMask | IdelayBaseRAdr) + 5, blankData },
		{ (flagReadMask | IdelayBaseRAdr) + 6, blankData },
		{ (flagReadMask | IdelayBaseRAdr) + 7, blankData },
		{ (flagReadMask | IdelayBaseRAdr) + 8, blankData },
		{ (flagReadMask | IdelayBaseRAdr) + 9, blankData },
		{ (flagReadMask | IdelayBaseRAdr) + 10, blankData },
		{ (flagReadMask | IdelayBaseRAdr) + 11, blankData },
		{ (flagReadMask | IdelayBaseRAdr) + 12, blankData },
		{ (flagReadMask | IdelayBaseRAdr) + 13, blankData },
		{ (flagReadMask | IdelayBaseRAdr) + 14, blankData },
		{ (flagReadMask | IdelayBaseRAdr) + 15, blankData },
		{ (flagReadMask | Shell0DspPiezoSfConstsRAdr), blankData },
		{ (flagReadMask | Shell0DspPiezoSfConstsRAdr) + 1, blankData },
		{ (flagReadMask | Shell0DspPiezoSfConstsRAdr) + 2, blankData },
		{ (flagReadMask | Shell0DspPiezoSfConstsRAdr) + 3, blankData },
		{ (flagReadMask | Shell0DspPiezoSfConstsRAdr) + 4, blankData },
		{ (flagReadMask | Shell0DspPiezoSfConstsRAdr) + 5, blankData },
		{ (flagReadMask | Shell0DspPiezoSfConstsRAdr) + 6, blankData },
		{ (flagReadMask | Shell0DspPiezoSfConstsRAdr) + 7, blankData },
		{ (flagReadMask | Shell1DspPiezoSfConstsRAdr), blankData },
		{ (flagReadMask | Shell1DspPiezoSfConstsRAdr) + 1, blankData },
		{ (flagReadMask | Shell1DspPiezoSfConstsRAdr) + 2, blankData },
		{ (flagReadMask | Shell1DspPiezoSfConstsRAdr) + 3, blankData },
		{ (flagReadMask | Shell1DspPiezoSfConstsRAdr) + 4, blankData },
		{ (flagReadMask | Shell1DspPiezoSfConstsRAdr) + 5, blankData },
		{ (flagReadMask | Shell1DspPiezoSfConstsRAdr) + 6, blankData },
		{ (flagReadMask | Shell1DspPiezoSfConstsRAdr) + 7, blankData },
		{ (flagReadMask | Shell0DspFdbkCoreMpProcCoeffRAdr), blankData },
		{ (flagReadMask | Shell0DspFdbkCoreMpProcCoeffRAdr) + 1, blankData },
		{ (flagReadMask | Shell0DspFdbkCoreMpProcCoeffRAdr) + 2, blankData },
		{ (flagReadMask | Shell0DspFdbkCoreMpProcCoeffRAdr) + 3, blankData },
		{ (flagReadMask | Shell0DspFdbkCoreMpProcLimRAdr), blankData },
		{ (flagReadMask | Shell0DspFdbkCoreMpProcLimRAdr) + 1, blankData },
		{ (flagReadMask | Shell0DspFdbkCoreMpProcLimRAdr) + 2, blankData },
		{ (flagReadMask | Shell0DspFdbkCoreMpProcLimRAdr) + 3, blankData },
		{ (flagReadMask | Shell0DspFdbkCoreMpProcSetmpRAdr), blankData },
		{ (flagReadMask | Shell0DspFdbkCoreMpProcSetmpRAdr) + 1, blankData },
		{ (flagReadMask | Shell0DspFdbkCoreMpProcSetmpRAdr) + 2, blankData },
		{ (flagReadMask | Shell0DspFdbkCoreMpProcSetmpRAdr) + 3, blankData },
		{ (flagReadMask | Shell1DspFdbkCoreMpProcCoeffRAdr), blankData },
		{ (flagReadMask | Shell1DspFdbkCoreMpProcCoeffRAdr) + 1, blankData },
		{ (flagReadMask | Shell1DspFdbkCoreMpProcCoeffRAdr) + 2, blankData },
		{ (flagReadMask | Shell1DspFdbkCoreMpProcCoeffRAdr) + 3, blankData },
		{ (flagReadMask | Shell1DspFdbkCoreMpProcLimRAdr), blankData },
		{ (flagReadMask | Shell1DspFdbkCoreMpProcLimRAdr) + 1, blankData },
		{ (flagReadMask | Shell1DspFdbkCoreMpProcLimRAdr) + 2, blankData },
		{ (flagReadMask | Shell1DspFdbkCoreMpProcLimRAdr) + 3, blankData },
		{ (flagReadMask | Shell1DspFdbkCoreMpProcSetmpRAdr), blankData },
		{ (flagReadMask | Shell1DspFdbkCoreMpProcSetmpRAdr) + 1, blankData },
		{ (flagReadMask | Shell1DspFdbkCoreMpProcSetmpRAdr) + 2, blankData },
		{ (flagReadMask | Shell1DspFdbkCoreMpProcSetmpRAdr) + 3, blankData },
		{ (flagReadMask | Cavity0DriveCoupleOutCouplingRAdr), blankData },
		{ (flagReadMask | Cavity0DriveCoupleOutCouplingRAdr) + 1, blankData },
		{ (flagReadMask | Cavity0DriveCoupleOutPhaseOffsetRAdr), blankData },
		{ (flagReadMask | Cavity0DriveCoupleOutPhaseOffsetRAdr) + 1, blankData },
		{ (flagReadMask | Cavity0Mode0CoupleOutCouplingRAdr), blankData },
		{ (flagReadMask | Cavity0Mode0CoupleOutCouplingRAdr) + 1, blankData },
		{ (flagReadMask | Cavity0Mode0CoupleOutPhaseOffsetRAdr), blankData },
		{ (flagReadMask | Cavity0Mode0CoupleOutPhaseOffsetRAdr) + 1, blankData },
		{ (flagReadMask | Cavity0Mode1CoupleOutCouplingRAdr), blankData },
		{ (flagReadMask | Cavity0Mode1CoupleOutCouplingRAdr) + 1, blankData },
		{ (flagReadMask | Cavity0Mode1CoupleOutPhaseOffsetRAdr), blankData },
		{ (flagReadMask | Cavity0Mode1CoupleOutPhaseOffsetRAdr) + 1, blankData },
		{ (flagReadMask | Cavity0Mode2CoupleOutCouplingRAdr), blankData },
		{ (flagReadMask | Cavity0Mode2CoupleOutCouplingRAdr) + 1, blankData },
		{ (flagReadMask | Cavity0Mode2CoupleOutPhaseOffsetRAdr), blankData },
		{ (flagReadMask | Cavity0Mode2CoupleOutPhaseOffsetRAdr) + 1, blankData },
		{ (flagReadMask | Cavity1DriveCoupleOutCouplingRAdr), blankData },
		{ (flagReadMask | Cavity1DriveCoupleOutCouplingRAdr) + 1, blankData },
		{ (flagReadMask | Cavity1DriveCoupleOutPhaseOffsetRAdr), blankData },
		{ (flagReadMask | Cavity1DriveCoupleOutPhaseOffsetRAdr) + 1, blankData },
		{ (flagReadMask | Cavity1Mode0CoupleOutCouplingRAdr), blankData },
		{ (flagReadMask | Cavity1Mode0CoupleOutCouplingRAdr) + 1, blankData },
		{ (flagReadMask | Cavity1Mode0CoupleOutPhaseOffsetRAdr), blankData },
		{ (flagReadMask | Cavity1Mode0CoupleOutPhaseOffsetRAdr) + 1, blankData },
		{ (flagReadMask | Cavity1Mode1CoupleOutCouplingRAdr), blankData },
		{ (flagReadMask | Cavity1Mode1CoupleOutCouplingRAdr) + 1, blankData },
		{ (flagReadMask | Cavity1Mode1CoupleOutPhaseOffsetRAdr), blankData },
		{ (flagReadMask | Cavity1Mode1CoupleOutPhaseOffsetRAdr) + 1, blankData },
		{ (flagReadMask | Cavity1Mode2CoupleOutCouplingRAdr), blankData },
		{ (flagReadMask | Cavity1Mode2CoupleOutCouplingRAdr) + 1, blankData },
		{ (flagReadMask | Cavity1Mode2CoupleOutPhaseOffsetRAdr), blankData },
		{ (flagReadMask | Cavity1Mode2CoupleOutPhaseOffsetRAdr) + 1, blankData },
		{ (flagReadMask | Shell0DspLpNotchLp1AKxRAdr), blankData },
		{ (flagReadMask | Shell0DspLpNotchLp1AKxRAdr) + 1, blankData },
		{ (flagReadMask | Shell0DspLpNotchLp1AKyRAdr), blankData },
		{ (flagReadMask | Shell0DspLpNotchLp1AKyRAdr) + 1, blankData },
		{ (flagReadMask | Shell0DspLpNotchLp1BKxRAdr), blankData },
		{ (flagReadMask | Shell0DspLpNotchLp1BKxRAdr) + 1, blankData },
		{ (flagReadMask | Shell0DspLpNotchLp1BKyRAdr), blankData },
		{ (flagReadMask | Shell0DspLpNotchLp1BKyRAdr) + 1, blankData },
		{ (flagReadMask | Shell1DspLpNotchLp1AKxRAdr), blankData },
		{ (flagReadMask | Shell1DspLpNotchLp1AKxRAdr) + 1, blankData },
		{ (flagReadMask | Shell1DspLpNotchLp1AKyRAdr), blankData },
		{ (flagReadMask | Shell1DspLpNotchLp1AKyRAdr) + 1, blankData },
		{ (flagReadMask | Shell1DspLpNotchLp1BKxRAdr), blankData },
		{ (flagReadMask | Shell1DspLpNotchLp1BKxRAdr) + 1, blankData },
		{ (flagReadMask | Shell1DspLpNotchLp1BKyRAdr), blankData },
		{ (flagReadMask | Shell1DspLpNotchLp1BKyRAdr) + 1, blankData },
		{ (flagReadMask | AdcMmcmRAdr), blankData },
		{ (flagReadMask | CcErrorClearRAdr), blankData },
		{ (flagReadMask | CcLoc1RAdr), blankData },
		{ (flagReadMask | Cct1Cavity0StatusAuxRAdr), blankData },
		{ (flagReadMask | Cct1Cavity1StatusAuxRAdr), blankData },
		{ (flagReadMask | ConfigBanyanMaskRAdr), blankData },
		{ (flagReadMask | ConfigBitslipRAdr), blankData },
		{ (flagReadMask | ConfigClkStatusWeRAdr), blankData },
		{ (flagReadMask | ConfigIdelayctrlResetRRAdr), blankData },
		{ (flagReadMask | ConfigMmcmResetRRAdr), blankData },
		{ (flagReadMask | ConfigPeriphConfigRAdr), blankData },
		{ (flagReadMask | ConfigPhasexTrigRAdr), blankData },
		{ (flagReadMask | ConfigRawadcTrigRAdr), blankData },
		{ (flagReadMask | ConfigScanTriggerWeRAdr), blankData },
		{ (flagReadMask | ConfigScannerDebugRAdr), blankData },
		{ (flagReadMask | ConfigSyncAd7794CsetRAdr), blankData },
		{ (flagReadMask | ConfigSyncTps62210CsetRAdr), blankData },
		{ (flagReadMask | AdcTestModeRAdr), blankData },
		{ (flagReadMask | AdcTestResetRAdr), blankData },
		{ (flagReadMask | AmplitudeRAdr), blankData },
		{ (flagReadMask | AverageLenRAdr), blankData },
		{ (flagReadMask | BufTrigRAdr), blankData },
		{ (flagReadMask | CicPeriodRAdr), blankData },
		{ (flagReadMask | CicShiftRAdr), blankData },
		{ (flagReadMask | CircleBufFlipRAdr), blankData },
		{ (flagReadMask | DacDdsResetRAdr), blankData },
		{ (flagReadMask | DacModeRAdr), blankData },
		{ (flagReadMask | DdsaModuloRAdr), blankData },
		{ (flagReadMask | DdsaPhstepHRAdr), blankData },
		{ (flagReadMask | DdsaPhstepLRAdr), blankData },
		{ (flagReadMask | HistCountWStrobeRAdr), blankData },
		{ (flagReadMask | LlrfDspDacEnRAdr), blankData },
		{ (flagReadMask | LoAmpRAdr), blankData },
		{ (flagReadMask | ModuloRAdr), blankData },
		{ (flagReadMask | PhaseStepHRAdr), blankData },
		{ (flagReadMask | PhaseStepLRAdr), blankData },
		{ (flagReadMask | PrcDspCavSelRAdr), blankData },
		{ (flagReadMask | PrcDspPrlCfgRAdr), blankData },
		{ (flagReadMask | PrcDspPrlGainRAdr), blankData },
		{ 0, 0 },
		{ (flagReadMask | Beam0ModuloRAdr), blankData },
		{ (flagReadMask | Beam0PhaseInitRAdr), blankData },
		{ (flagReadMask | Beam0PhaseStepRAdr), blankData },
		{ (flagReadMask | Beam1ModuloRAdr), blankData },
		{ (flagReadMask | Beam1PhaseInitRAdr), blankData },
		{ (flagReadMask | Beam1PhaseStepRAdr), blankData },
		{ (flagReadMask | Cav4MechPrngIvaRAdr), blankData },
		{ (flagReadMask | Cav4MechPrngIvbRAdr), blankData },
		{ (flagReadMask | Cav4MechPrngRandomRunRAdr), blankData },
		{ (flagReadMask | Cavity0ACavOffsetRAdr), blankData },
		{ (flagReadMask | Cavity0AForOffsetRAdr), blankData },
		{ (flagReadMask | Cavity0ARflOffsetRAdr), blankData },
		{ (flagReadMask | Cavity0AmpLpBwRAdr), blankData },
		{ (flagReadMask | Cavity0Freq0CoarseFreqRAdr), blankData },
		{ (flagReadMask | Cavity0Freq1CoarseFreqRAdr), blankData },
		{ (flagReadMask | Cavity0Freq2CoarseFreqRAdr), blankData },
		{ (flagReadMask | Cavity0Mode0BeamCouplingRAdr), blankData },
		{ (flagReadMask | Cavity0Mode0BwRAdr), blankData },
		{ (flagReadMask | Cavity0Mode0DriveCouplingRAdr), blankData },
		{ (flagReadMask | Cavity0Mode1BeamCouplingRAdr), blankData },
		{ (flagReadMask | Cavity0Mode1BwRAdr), blankData },
		{ (flagReadMask | Cavity0Mode1DriveCouplingRAdr), blankData },
		{ (flagReadMask | Cavity0Mode2BeamCouplingRAdr), blankData },
		{ (flagReadMask | Cavity0Mode2BwRAdr), blankData },
		{ (flagReadMask | Cavity0Mode2DriveCouplingRAdr), blankData },
		{ (flagReadMask | Cavity0ModuloRAdr), blankData },
		{ (flagReadMask | Cavity0PhaseStepRAdr), blankData },
		{ (flagReadMask | Cavity0ComprSatCtlRAdr), blankData },
		{ (flagReadMask | Cavity0PrngIvaRAdr), blankData },
		{ (flagReadMask | Cavity0PrngIvbRAdr), blankData },
		{ (flagReadMask | Cavity0PrngRandomRunRAdr), blankData },
		{ (flagReadMask | Cavity1ACavOffsetRAdr), blankData },
		{ (flagReadMask | Cavity1AForOffsetRAdr), blankData },
		{ (flagReadMask | Cavity1ARflOffsetRAdr), blankData },
		{ (flagReadMask | Cavity1AmpLpBwRAdr), blankData },
		{ (flagReadMask | Cavity1Freq0CoarseFreqRAdr), blankData },
		{ (flagReadMask | Cavity1Freq1CoarseFreqRAdr), blankData },
		{ (flagReadMask | Cavity1Freq2CoarseFreqRAdr), blankData },
		{ (flagReadMask | Cavity1Mode0BeamCouplingRAdr), blankData },
		{ (flagReadMask | Cavity1Mode0BwRAdr), blankData },
		{ (flagReadMask | Cavity1Mode0DriveCouplingRAdr), blankData },
		{ (flagReadMask | Cavity1Mode1BeamCouplingRAdr), blankData },
		{ (flagReadMask | Cavity1Mode1BwRAdr), blankData },
		{ (flagReadMask | Cavity1Mode1DriveCouplingRAdr), blankData },
		{ (flagReadMask | Cavity1Mode2BeamCouplingRAdr), blankData },
		{ (flagReadMask | Cavity1Mode2BwRAdr), blankData },
		{ (flagReadMask | Cavity1Mode2DriveCouplingRAdr), blankData },
		{ (flagReadMask | Cavity1ModuloRAdr), blankData },
		{ (flagReadMask | Cavity1PhaseStepRAdr), blankData },
		{ (flagReadMask | Cavity1ComprSatCtlRAdr), blankData },
		{ (flagReadMask | Cavity1PrngIvaRAdr), blankData },
		{ (flagReadMask | Cavity1PrngIvbRAdr), blankData },
		{ (flagReadMask | Cavity1PrngRandomRunRAdr), blankData },
		{ (flagReadMask | DacIqPhaseRAdr), blankData },
		{ (flagReadMask | Shell0DspChanKeepRAdr), blankData },
		{ (flagReadMask | Shell0DspFdbkCoreCoarseScaleRAdr), blankData },
		{ (flagReadMask | Shell0DspFdbkCoreMpProcPhOffsetRAdr), blankData },
		{ (flagReadMask | Shell0DspFdbkCoreMpProcSelEnRAdr), blankData },
		{ (flagReadMask | Shell0DspFdbkCoreMpProcSelThreshRAdr), blankData },
		{ (flagReadMask | Shell0DspModuloRAdr), blankData },
		{ (flagReadMask | Shell0DspPhaseStepRAdr), blankData },
		{ (flagReadMask | Shell0DspPiezoPiezoDcRAdr), blankData },
		{ (flagReadMask | Shell0DspTagRAdr), blankData },
		{ (flagReadMask | Shell0DspUseFiberIqRAdr), blankData },
		{ (flagReadMask | Shell0DspWaveSampPerRAdr), blankData },
		{ (flagReadMask | Shell0DspWaveShiftRAdr), blankData },
		{ (flagReadMask | Shell1DspChanKeepRAdr), blankData },
		{ (flagReadMask | Shell1DspFdbkCoreCoarseScaleRAdr), blankData },
		{ (flagReadMask | Shell1DspFdbkCoreMpProcPhOffsetRAdr), blankData },
		{ (flagReadMask | Shell1DspFdbkCoreMpProcSelEnRAdr), blankData },
		{ (flagReadMask | Shell1DspFdbkCoreMpProcSelThreshRAdr), blankData },
		{ (flagReadMask | Shell1DspModuloRAdr), blankData },
		{ (flagReadMask | Shell1DspPhaseStepRAdr), blankData },
		{ (flagReadMask | Shell1DspPiezoPiezoDcRAdr), blankData },
		{ (flagReadMask | Shell1DspTagRAdr), blankData },
		{ (flagReadMask | Shell1DspUseFiberIqRAdr), blankData },
		{ (flagReadMask | Shell1DspWaveSampPerRAdr), blankData },
		{ (flagReadMask | Shell1DspWaveShiftRAdr), blankData },
		{ (flagReadMask | RewindRAdr), blankData },
		{ (flagReadMask | SsaStimAmpstepRAdr), blankData },
		{ (flagReadMask | SsaStimEnRAdr), blankData },
		{ (flagReadMask | SsaStimGPeriodRAdr), blankData },
		{ (flagReadMask | SsaStimPertstepRAdr), blankData },
		{ (flagReadMask | TraceKeepRAdr), blankData },
		{ (flagReadMask | TraceResetWeRAdr), blankData },
		{ (flagReadMask | TrigInternalRAdr), blankData },
		{ (flagReadMask | TrigModeRAdr), blankData },
		{ (flagReadMask | Wave0SrcRAdr), blankData },
		{ (flagReadMask | Wave1SrcRAdr), blankData },
		{ (flagReadMask | DomainJumpRealignRAdr), blankData },
		{ (flagReadMask | IccCfgRAdr), blankData },
		{ (flagReadMask | QsfpI2CRegRAdr), blankData },
		{ (flagReadMask | SfpAddressSetRAdr), blankData },
		{ (flagReadMask | TagNowRAdr), blankData },
	};

	htonFpgaRegArray(pPolledRegMsg_, PolledRegMsgSize_);

    epicsThreadSleep(defaultPollPeriod);
    printf("%s created %ld of %ld parameters.\n",__PRETTY_FUNCTION__,NUM_SCLLRFPRC_PARAMS, paramTableAdds+NUM_SCLLRFPRC_PARAMS);

    wakeupPoller();
    wakeupReader();
}

scllrfPRCDriver::~scllrfPRCDriver()
{
	isShuttingDown_ = true;
	epicsThreadSleep(0.1); // Allow threads to run and exit
	wakeupPoller();
	wakeupReader();
	epicsThreadSleep(0.1); // Allow threads to run and exit
	wakeupPoller(); // call this twice in case the poller was never set to run
	wakeupReader();
	epicsThreadSleep(0.1); // Allow threads to run and exit
	wakeupReader();
	pasynOctetSyncIO->disconnect(pOctetAsynUser_);
	pasynCommonSyncIO->disconnectDevice(pCommonAsynUser_);
	pasynCommonSyncIO->disconnect(pCommonAsynUser_);
}

/** Called when you have the asyn parameter name and want the corresponding
 * register address.
  * \param[in] function From pAsynUser->reason, corresponding to a registered parameter.
  * \param[in] pToFpga Pointer to the {Address, Data} structure where the register address will be written
  * \param[in] nElements Number of elements to read. */
asynStatus scllrfPRCDriver::functionToRegister(const int function, FpgaReg *pToFpga)
{
	asynStatus status = asynSuccess;

    if( function == p_U15SpiRdbkR )
    {
		pToFpga->addr = U15SpiRdbkRAdr|flagReadMask;
    }
    else
    if( function == p_U15SpiStatusR )
    {
		pToFpga->addr = U15SpiStatusRAdr|flagReadMask;
    }
    else
    if( function == p_U18SpiRdbkR )
    {
		pToFpga->addr = U18SpiRdbkRAdr|flagReadMask;
    }
    else
    if( function == p_U18SpiStatusR )
    {
		pToFpga->addr = U18SpiStatusRAdr|flagReadMask;
    }
    else
    if( function == p_U2DoutLsbR )
    {
		pToFpga->addr = U2DoutLsbRAdr|flagReadMask;
    }
    else
    if( function == p_U2DoutMsbR )
    {
		pToFpga->addr = U2DoutMsbRAdr|flagReadMask;
    }
    else
    if( function == p_U3DoutLsbR )
    {
		pToFpga->addr = U3DoutLsbRAdr|flagReadMask;
    }
    else
    if( function == p_U3DoutMsbR )
    {
		pToFpga->addr = U3DoutMsbRAdr|flagReadMask;
    }
    else
    if( function == p_AdcMmcmR )
    {
		pToFpga->addr = AdcMmcmRAdr|flagReadMask;
    }
    else
    if( function == p_AdcMmcmW )
    {
		pToFpga->addr = AdcMmcmWAdr;
    }
    else
    if( function == p_AdcTestModeR )
    {
		pToFpga->addr = AdcTestModeRAdr|flagReadMask;
    }
    else
    if( function == p_AdcTestModeW )
    {
		pToFpga->addr = AdcTestModeWAdr;
    }
    else
    if( function == p_AdcTestResetR )
    {
		pToFpga->addr = AdcTestResetRAdr|flagReadMask;
    }
    else
    if( function == p_AdcTestResetW )
    {
		pToFpga->addr = AdcTestResetWAdr;
    }
    else
    if( function == p_AdcTestTrigCntR )
    {
		pToFpga->addr = AdcTestTrigCntRAdr|flagReadMask;
    }
    else
    if( function == p_AdcTestWave1OutR )
    {
		pToFpga->addr = AdcTestWave1OutRAdr|flagReadMask;
    }
    else
    if( function == p_AdcTestWave2OutR )
    {
		pToFpga->addr = AdcTestWave2OutRAdr|flagReadMask;
    }
    else
    if( function == p_AdcTestWave3OutR )
    {
		pToFpga->addr = AdcTestWave3OutRAdr|flagReadMask;
    }
    else
    if( function == p_AdcTestWave4OutR )
    {
		pToFpga->addr = AdcTestWave4OutRAdr|flagReadMask;
    }
    else
    if( function == p_AmplitudeR )
    {
		pToFpga->addr = AmplitudeRAdr|flagReadMask;
    }
    else
    if( function == p_AmplitudeW )
    {
		pToFpga->addr = AmplitudeWAdr;
    }
    else
    if( function == p_AverageLenR )
    {
		pToFpga->addr = AverageLenRAdr|flagReadMask;
    }
    else
    if( function == p_AverageLenW )
    {
		pToFpga->addr = AverageLenWAdr;
    }
    else
    if( function == p_BanyanBufR )
    {
		pToFpga->addr = BanyanBufRAdr|flagReadMask;
    }
    else
    if( function == p_BanyanStatusR )
    {
		pToFpga->addr = BanyanStatusRAdr|flagReadMask;
    }
    else
    if( function == p_Beam0ModuloR )
    {
		pToFpga->addr = Beam0ModuloRAdr|flagReadMask;
    }
    else
    if( function == p_Beam0ModuloW )
    {
		pToFpga->addr = Beam0ModuloWAdr;
    }
    else
    if( function == p_Beam0PhaseInitR )
    {
		pToFpga->addr = Beam0PhaseInitRAdr|flagReadMask;
    }
    else
    if( function == p_Beam0PhaseInitW )
    {
		pToFpga->addr = Beam0PhaseInitWAdr;
    }
    else
    if( function == p_Beam0PhaseStepR )
    {
		pToFpga->addr = Beam0PhaseStepRAdr|flagReadMask;
    }
    else
    if( function == p_Beam0PhaseStepW )
    {
		pToFpga->addr = Beam0PhaseStepWAdr;
    }
    else
    if( function == p_Beam1ModuloR )
    {
		pToFpga->addr = Beam1ModuloRAdr|flagReadMask;
    }
    else
    if( function == p_Beam1ModuloW )
    {
		pToFpga->addr = Beam1ModuloWAdr;
    }
    else
    if( function == p_Beam1PhaseInitR )
    {
		pToFpga->addr = Beam1PhaseInitRAdr|flagReadMask;
    }
    else
    if( function == p_Beam1PhaseInitW )
    {
		pToFpga->addr = Beam1PhaseInitWAdr;
    }
    else
    if( function == p_Beam1PhaseStepR )
    {
		pToFpga->addr = Beam1PhaseStepRAdr|flagReadMask;
    }
    else
    if( function == p_Beam1PhaseStepW )
    {
		pToFpga->addr = Beam1PhaseStepWAdr;
    }
    else
    if( function == p_BufTrigR )
    {
		pToFpga->addr = BufTrigRAdr|flagReadMask;
    }
    else
    if( function == p_BufTrigW )
    {
		pToFpga->addr = BufTrigWAdr;
    }
    else
    if( function == p_Cav4MechNoiseCoupleKOutW )
    {
		pToFpga->addr = Cav4MechNoiseCoupleKOutWAdr;
    }
    else
    if( function == p_Cav4MechPrngIvaR )
    {
		pToFpga->addr = Cav4MechPrngIvaRAdr|flagReadMask;
    }
    else
    if( function == p_Cav4MechPrngIvaW )
    {
		pToFpga->addr = Cav4MechPrngIvaWAdr;
    }
    else
    if( function == p_Cav4MechPrngIvbR )
    {
		pToFpga->addr = Cav4MechPrngIvbRAdr|flagReadMask;
    }
    else
    if( function == p_Cav4MechPrngIvbW )
    {
		pToFpga->addr = Cav4MechPrngIvbWAdr;
    }
    else
    if( function == p_Cav4MechPrngRandomRunR )
    {
		pToFpga->addr = Cav4MechPrngRandomRunRAdr|flagReadMask;
    }
    else
    if( function == p_Cav4MechPrngRandomRunW )
    {
		pToFpga->addr = Cav4MechPrngRandomRunWAdr;
    }
    else
    if( function == p_Cav4MechResonatorPropConstW )
    {
		pToFpga->addr = Cav4MechResonatorPropConstWAdr;
    }
    else
    if( function == p_Cavity0DetuneR )
    {
		pToFpga->addr = Cavity0DetuneRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity1DetuneR )
    {
		pToFpga->addr = Cavity1DetuneRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity0ACavOffsetR )
    {
		pToFpga->addr = Cavity0ACavOffsetRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity0ACavOffsetW )
    {
		pToFpga->addr = Cavity0ACavOffsetWAdr;
    }
    else
    if( function == p_Cavity0AForOffsetR )
    {
		pToFpga->addr = Cavity0AForOffsetRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity0AForOffsetW )
    {
		pToFpga->addr = Cavity0AForOffsetWAdr;
    }
    else
    if( function == p_Cavity0ARflOffsetR )
    {
		pToFpga->addr = Cavity0ARflOffsetRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity0ARflOffsetW )
    {
		pToFpga->addr = Cavity0ARflOffsetWAdr;
    }
    else
    if( function == p_Cavity0AmpLpBwR )
    {
		pToFpga->addr = Cavity0AmpLpBwRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity0AmpLpBwW )
    {
		pToFpga->addr = Cavity0AmpLpBwWAdr;
    }
    else
    if( function == p_Cavity0ComprSatCtlR )
    {
		pToFpga->addr = Cavity0ComprSatCtlRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity0ComprSatCtlW )
    {
		pToFpga->addr = Cavity0ComprSatCtlWAdr;
    }
    else
    if( function == p_Cavity0Dot0KOutW )
    {
		pToFpga->addr = Cavity0Dot0KOutWAdr;
    }
    else
    if( function == p_Cavity0Dot1KOutW )
    {
		pToFpga->addr = Cavity0Dot1KOutWAdr;
    }
    else
    if( function == p_Cavity0Dot2KOutW )
    {
		pToFpga->addr = Cavity0Dot2KOutWAdr;
    }
    else
    if( function == p_Cavity0DriveCoupleOutCouplingR )
    {
		pToFpga->addr = Cavity0DriveCoupleOutCouplingRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity0DriveCoupleOutCouplingW )
    {
		pToFpga->addr = Cavity0DriveCoupleOutCouplingWAdr;
    }
    else
    if( function == p_Cavity0DriveCoupleOutPhaseOffsetR )
    {
		pToFpga->addr = Cavity0DriveCoupleOutPhaseOffsetRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity0DriveCoupleOutPhaseOffsetW )
    {
		pToFpga->addr = Cavity0DriveCoupleOutPhaseOffsetWAdr;
    }
    else
    if( function == p_Cavity0Freq0CoarseFreqR )
    {
		pToFpga->addr = Cavity0Freq0CoarseFreqRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity0Freq0CoarseFreqW )
    {
		pToFpga->addr = Cavity0Freq0CoarseFreqWAdr;
    }
    else
    if( function == p_Cavity0Freq1CoarseFreqR )
    {
		pToFpga->addr = Cavity0Freq1CoarseFreqRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity0Freq1CoarseFreqW )
    {
		pToFpga->addr = Cavity0Freq1CoarseFreqWAdr;
    }
    else
    if( function == p_Cavity0Freq2CoarseFreqR )
    {
		pToFpga->addr = Cavity0Freq2CoarseFreqRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity0Freq2CoarseFreqW )
    {
		pToFpga->addr = Cavity0Freq2CoarseFreqWAdr;
    }
    else
    if( function == p_Cavity0Mode0BeamCouplingR )
    {
		pToFpga->addr = Cavity0Mode0BeamCouplingRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity0Mode0BeamCouplingW )
    {
		pToFpga->addr = Cavity0Mode0BeamCouplingWAdr;
    }
    else
    if( function == p_Cavity0Mode0BwR )
    {
		pToFpga->addr = Cavity0Mode0BwRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity0Mode0BwW )
    {
		pToFpga->addr = Cavity0Mode0BwWAdr;
    }
    else
    if( function == p_Cavity0Mode0CoupleOutCouplingR )
    {
		pToFpga->addr = Cavity0Mode0CoupleOutCouplingRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity0Mode0CoupleOutCouplingW )
    {
		pToFpga->addr = Cavity0Mode0CoupleOutCouplingWAdr;
    }
    else
    if( function == p_Cavity0Mode0CoupleOutPhaseOffsetR )
    {
		pToFpga->addr = Cavity0Mode0CoupleOutPhaseOffsetRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity0Mode0CoupleOutPhaseOffsetW )
    {
		pToFpga->addr = Cavity0Mode0CoupleOutPhaseOffsetWAdr;
    }
    else
    if( function == p_Cavity0Mode0DriveCouplingR )
    {
		pToFpga->addr = Cavity0Mode0DriveCouplingRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity0Mode0DriveCouplingW )
    {
		pToFpga->addr = Cavity0Mode0DriveCouplingWAdr;
    }
    else
    if( function == p_Cavity0Mode1BeamCouplingR )
    {
		pToFpga->addr = Cavity0Mode1BeamCouplingRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity0Mode1BeamCouplingW )
    {
		pToFpga->addr = Cavity0Mode1BeamCouplingWAdr;
    }
    else
    if( function == p_Cavity0Mode1BwR )
    {
		pToFpga->addr = Cavity0Mode1BwRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity0Mode1BwW )
    {
		pToFpga->addr = Cavity0Mode1BwWAdr;
    }
    else
    if( function == p_Cavity0Mode1CoupleOutCouplingR )
    {
		pToFpga->addr = Cavity0Mode1CoupleOutCouplingRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity0Mode1CoupleOutCouplingW )
    {
		pToFpga->addr = Cavity0Mode1CoupleOutCouplingWAdr;
    }
    else
    if( function == p_Cavity0Mode1CoupleOutPhaseOffsetR )
    {
		pToFpga->addr = Cavity0Mode1CoupleOutPhaseOffsetRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity0Mode1CoupleOutPhaseOffsetW )
    {
		pToFpga->addr = Cavity0Mode1CoupleOutPhaseOffsetWAdr;
    }
    else
    if( function == p_Cavity0Mode1DriveCouplingR )
    {
		pToFpga->addr = Cavity0Mode1DriveCouplingRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity0Mode1DriveCouplingW )
    {
		pToFpga->addr = Cavity0Mode1DriveCouplingWAdr;
    }
    else
    if( function == p_Cavity0Mode2BeamCouplingR )
    {
		pToFpga->addr = Cavity0Mode2BeamCouplingRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity0Mode2BeamCouplingW )
    {
		pToFpga->addr = Cavity0Mode2BeamCouplingWAdr;
    }
    else
    if( function == p_Cavity0Mode2BwR )
    {
		pToFpga->addr = Cavity0Mode2BwRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity0Mode2BwW )
    {
		pToFpga->addr = Cavity0Mode2BwWAdr;
    }
    else
    if( function == p_Cavity0Mode2CoupleOutCouplingR )
    {
		pToFpga->addr = Cavity0Mode2CoupleOutCouplingRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity0Mode2CoupleOutCouplingW )
    {
		pToFpga->addr = Cavity0Mode2CoupleOutCouplingWAdr;
    }
    else
    if( function == p_Cavity0Mode2CoupleOutPhaseOffsetR )
    {
		pToFpga->addr = Cavity0Mode2CoupleOutPhaseOffsetRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity0Mode2CoupleOutPhaseOffsetW )
    {
		pToFpga->addr = Cavity0Mode2CoupleOutPhaseOffsetWAdr;
    }
    else
    if( function == p_Cavity0Mode2DriveCouplingR )
    {
		pToFpga->addr = Cavity0Mode2DriveCouplingRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity0Mode2DriveCouplingW )
    {
		pToFpga->addr = Cavity0Mode2DriveCouplingWAdr;
    }
    else
    if( function == p_Cavity0ModuloR )
    {
		pToFpga->addr = Cavity0ModuloRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity0ModuloW )
    {
		pToFpga->addr = Cavity0ModuloWAdr;
    }
    else
    if( function == p_Cavity0OuterProd0KOutW )
    {
		pToFpga->addr = Cavity0OuterProd0KOutWAdr;
    }
    else
    if( function == p_Cavity0OuterProd1KOutW )
    {
		pToFpga->addr = Cavity0OuterProd1KOutWAdr;
    }
    else
    if( function == p_Cavity0OuterProd2KOutW )
    {
		pToFpga->addr = Cavity0OuterProd2KOutWAdr;
    }
    else
    if( function == p_Cavity0PhaseStepR )
    {
		pToFpga->addr = Cavity0PhaseStepRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity0PhaseStepW )
    {
		pToFpga->addr = Cavity0PhaseStepWAdr;
    }
    else
    if( function == p_Cavity0PiezoCoupleKOutW )
    {
		pToFpga->addr = Cavity0PiezoCoupleKOutWAdr;
    }
    else
    if( function == p_Cavity0PrngIvaR )
    {
		pToFpga->addr = Cavity0PrngIvaRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity0PrngIvaW )
    {
		pToFpga->addr = Cavity0PrngIvaWAdr;
    }
    else
    if( function == p_Cavity0PrngIvbR )
    {
		pToFpga->addr = Cavity0PrngIvbRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity0PrngIvbW )
    {
		pToFpga->addr = Cavity0PrngIvbWAdr;
    }
    else
    if( function == p_Cavity0PrngRandomRunR )
    {
		pToFpga->addr = Cavity0PrngRandomRunRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity0PrngRandomRunW )
    {
		pToFpga->addr = Cavity0PrngRandomRunWAdr;
    }
    else
    if( function == p_Cavity1ACavOffsetR )
    {
		pToFpga->addr = Cavity1ACavOffsetRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity1ACavOffsetW )
    {
		pToFpga->addr = Cavity1ACavOffsetWAdr;
    }
    else
    if( function == p_Cavity1AForOffsetR )
    {
		pToFpga->addr = Cavity1AForOffsetRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity1AForOffsetW )
    {
		pToFpga->addr = Cavity1AForOffsetWAdr;
    }
    else
    if( function == p_Cavity1ARflOffsetR )
    {
		pToFpga->addr = Cavity1ARflOffsetRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity1ARflOffsetW )
    {
		pToFpga->addr = Cavity1ARflOffsetWAdr;
    }
    else
    if( function == p_Cavity1AmpLpBwR )
    {
		pToFpga->addr = Cavity1AmpLpBwRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity1AmpLpBwW )
    {
		pToFpga->addr = Cavity1AmpLpBwWAdr;
    }
    else
    if( function == p_Cavity1ComprSatCtlR )
    {
		pToFpga->addr = Cavity1ComprSatCtlRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity1ComprSatCtlW )
    {
		pToFpga->addr = Cavity1ComprSatCtlWAdr;
    }
    else
    if( function == p_Cavity1Dot0KOutW )
    {
		pToFpga->addr = Cavity1Dot0KOutWAdr;
    }
    else
    if( function == p_Cavity1Dot1KOutW )
    {
		pToFpga->addr = Cavity1Dot1KOutWAdr;
    }
    else
    if( function == p_Cavity1Dot2KOutW )
    {
		pToFpga->addr = Cavity1Dot2KOutWAdr;
    }
    else
    if( function == p_Cavity1DriveCoupleOutCouplingR )
    {
		pToFpga->addr = Cavity1DriveCoupleOutCouplingRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity1DriveCoupleOutCouplingW )
    {
		pToFpga->addr = Cavity1DriveCoupleOutCouplingWAdr;
    }
    else
    if( function == p_Cavity1DriveCoupleOutPhaseOffsetR )
    {
		pToFpga->addr = Cavity1DriveCoupleOutPhaseOffsetRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity1DriveCoupleOutPhaseOffsetW )
    {
		pToFpga->addr = Cavity1DriveCoupleOutPhaseOffsetWAdr;
    }
    else
    if( function == p_Cavity1Freq0CoarseFreqR )
    {
		pToFpga->addr = Cavity1Freq0CoarseFreqRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity1Freq0CoarseFreqW )
    {
		pToFpga->addr = Cavity1Freq0CoarseFreqWAdr;
    }
    else
    if( function == p_Cavity1Freq1CoarseFreqR )
    {
		pToFpga->addr = Cavity1Freq1CoarseFreqRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity1Freq1CoarseFreqW )
    {
		pToFpga->addr = Cavity1Freq1CoarseFreqWAdr;
    }
    else
    if( function == p_Cavity1Freq2CoarseFreqR )
    {
		pToFpga->addr = Cavity1Freq2CoarseFreqRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity1Freq2CoarseFreqW )
    {
		pToFpga->addr = Cavity1Freq2CoarseFreqWAdr;
    }
    else
    if( function == p_Cavity1Mode0BeamCouplingR )
    {
		pToFpga->addr = Cavity1Mode0BeamCouplingRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity1Mode0BeamCouplingW )
    {
		pToFpga->addr = Cavity1Mode0BeamCouplingWAdr;
    }
    else
    if( function == p_Cavity1Mode0BwR )
    {
		pToFpga->addr = Cavity1Mode0BwRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity1Mode0BwW )
    {
		pToFpga->addr = Cavity1Mode0BwWAdr;
    }
    else
    if( function == p_Cavity1Mode0CoupleOutCouplingR )
    {
		pToFpga->addr = Cavity1Mode0CoupleOutCouplingRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity1Mode0CoupleOutCouplingW )
    {
		pToFpga->addr = Cavity1Mode0CoupleOutCouplingWAdr;
    }
    else
    if( function == p_Cavity1Mode0CoupleOutPhaseOffsetR )
    {
		pToFpga->addr = Cavity1Mode0CoupleOutPhaseOffsetRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity1Mode0CoupleOutPhaseOffsetW )
    {
		pToFpga->addr = Cavity1Mode0CoupleOutPhaseOffsetWAdr;
    }
    else
    if( function == p_Cavity1Mode0DriveCouplingR )
    {
		pToFpga->addr = Cavity1Mode0DriveCouplingRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity1Mode0DriveCouplingW )
    {
		pToFpga->addr = Cavity1Mode0DriveCouplingWAdr;
    }
    else
    if( function == p_Cavity1Mode1BeamCouplingR )
    {
		pToFpga->addr = Cavity1Mode1BeamCouplingRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity1Mode1BeamCouplingW )
    {
		pToFpga->addr = Cavity1Mode1BeamCouplingWAdr;
    }
    else
    if( function == p_Cavity1Mode1BwR )
    {
		pToFpga->addr = Cavity1Mode1BwRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity1Mode1BwW )
    {
		pToFpga->addr = Cavity1Mode1BwWAdr;
    }
    else
    if( function == p_Cavity1Mode1CoupleOutCouplingR )
    {
		pToFpga->addr = Cavity1Mode1CoupleOutCouplingRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity1Mode1CoupleOutCouplingW )
    {
		pToFpga->addr = Cavity1Mode1CoupleOutCouplingWAdr;
    }
    else
    if( function == p_Cavity1Mode1CoupleOutPhaseOffsetR )
    {
		pToFpga->addr = Cavity1Mode1CoupleOutPhaseOffsetRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity1Mode1CoupleOutPhaseOffsetW )
    {
		pToFpga->addr = Cavity1Mode1CoupleOutPhaseOffsetWAdr;
    }
    else
    if( function == p_Cavity1Mode1DriveCouplingR )
    {
		pToFpga->addr = Cavity1Mode1DriveCouplingRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity1Mode1DriveCouplingW )
    {
		pToFpga->addr = Cavity1Mode1DriveCouplingWAdr;
    }
    else
    if( function == p_Cavity1Mode2BeamCouplingR )
    {
		pToFpga->addr = Cavity1Mode2BeamCouplingRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity1Mode2BeamCouplingW )
    {
		pToFpga->addr = Cavity1Mode2BeamCouplingWAdr;
    }
    else
    if( function == p_Cavity1Mode2BwR )
    {
		pToFpga->addr = Cavity1Mode2BwRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity1Mode2BwW )
    {
		pToFpga->addr = Cavity1Mode2BwWAdr;
    }
    else
    if( function == p_Cavity1Mode2CoupleOutCouplingR )
    {
		pToFpga->addr = Cavity1Mode2CoupleOutCouplingRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity1Mode2CoupleOutCouplingW )
    {
		pToFpga->addr = Cavity1Mode2CoupleOutCouplingWAdr;
    }
    else
    if( function == p_Cavity1Mode2CoupleOutPhaseOffsetR )
    {
		pToFpga->addr = Cavity1Mode2CoupleOutPhaseOffsetRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity1Mode2CoupleOutPhaseOffsetW )
    {
		pToFpga->addr = Cavity1Mode2CoupleOutPhaseOffsetWAdr;
    }
    else
    if( function == p_Cavity1Mode2DriveCouplingR )
    {
		pToFpga->addr = Cavity1Mode2DriveCouplingRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity1Mode2DriveCouplingW )
    {
		pToFpga->addr = Cavity1Mode2DriveCouplingWAdr;
    }
    else
    if( function == p_Cavity1ModuloR )
    {
		pToFpga->addr = Cavity1ModuloRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity1ModuloW )
    {
		pToFpga->addr = Cavity1ModuloWAdr;
    }
    else
    if( function == p_Cavity1OuterProd0KOutW )
    {
		pToFpga->addr = Cavity1OuterProd0KOutWAdr;
    }
    else
    if( function == p_Cavity1OuterProd1KOutW )
    {
		pToFpga->addr = Cavity1OuterProd1KOutWAdr;
    }
    else
    if( function == p_Cavity1OuterProd2KOutW )
    {
		pToFpga->addr = Cavity1OuterProd2KOutWAdr;
    }
    else
    if( function == p_Cavity1PhaseStepR )
    {
		pToFpga->addr = Cavity1PhaseStepRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity1PhaseStepW )
    {
		pToFpga->addr = Cavity1PhaseStepWAdr;
    }
    else
    if( function == p_Cavity1PiezoCoupleKOutW )
    {
		pToFpga->addr = Cavity1PiezoCoupleKOutWAdr;
    }
    else
    if( function == p_Cavity1PrngIvaR )
    {
		pToFpga->addr = Cavity1PrngIvaRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity1PrngIvaW )
    {
		pToFpga->addr = Cavity1PrngIvaWAdr;
    }
    else
    if( function == p_Cavity1PrngIvbR )
    {
		pToFpga->addr = Cavity1PrngIvbRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity1PrngIvbW )
    {
		pToFpga->addr = Cavity1PrngIvbWAdr;
    }
    else
    if( function == p_Cavity1PrngRandomRunR )
    {
		pToFpga->addr = Cavity1PrngRandomRunRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity1PrngRandomRunW )
    {
		pToFpga->addr = Cavity1PrngRandomRunWAdr;
    }
    else
    if( function == p_CcErrorClearR )
    {
		pToFpga->addr = CcErrorClearRAdr|flagReadMask;
    }
    else
    if( function == p_CcErrorClearW )
    {
		pToFpga->addr = CcErrorClearWAdr;
    }
    else
    if( function == p_CcLoc1R )
    {
		pToFpga->addr = CcLoc1RAdr|flagReadMask;
    }
    else
    if( function == p_CcLoc1W )
    {
		pToFpga->addr = CcLoc1WAdr;
    }
    else
    if( function == p_Cct1Cavity0StatusAuxR )
    {
		pToFpga->addr = Cct1Cavity0StatusAuxRAdr|flagReadMask;
    }
    else
    if( function == p_Cct1Cavity0StatusAuxW )
    {
		pToFpga->addr = Cct1Cavity0StatusAuxWAdr;
    }
    else
    if( function == p_Cct1Cavity1StatusAuxR )
    {
		pToFpga->addr = Cct1Cavity1StatusAuxRAdr|flagReadMask;
    }
    else
    if( function == p_Cct1Cavity1StatusAuxW )
    {
		pToFpga->addr = Cct1Cavity1StatusAuxWAdr;
    }
    else
    if( function == p_CicPeriodR )
    {
		pToFpga->addr = CicPeriodRAdr|flagReadMask;
    }
    else
    if( function == p_CicPeriodW )
    {
		pToFpga->addr = CicPeriodWAdr;
    }
    else
    if( function == p_CicShiftR )
    {
		pToFpga->addr = CicShiftRAdr|flagReadMask;
    }
    else
    if( function == p_CicShiftW )
    {
		pToFpga->addr = CicShiftWAdr;
    }
    else
    if( function == p_CircleBufFlipR )
    {
		pToFpga->addr = CircleBufFlipRAdr|flagReadMask;
    }
    else
    if( function == p_CircleBufFlipW )
    {
		pToFpga->addr = CircleBufFlipWAdr;
    }
    else
    if( function == p_ClkPhaseDiffOutU2R )
    {
		pToFpga->addr = ClkPhaseDiffOutU2RAdr|flagReadMask;
    }
    else
    if( function == p_ClkPhaseDiffOutU3R )
    {
		pToFpga->addr = ClkPhaseDiffOutU3RAdr|flagReadMask;
    }
    else
    if( function == p_ClkStatusOutR )
    {
		pToFpga->addr = ClkStatusOutRAdr|flagReadMask;
    }
    else
    if( function == p_ConfigU15SpiDataAddrRR )
    {
		pToFpga->addr = ConfigU15SpiDataAddrRRAdr|flagReadMask;
    }
    else
    if( function == p_ConfigU15SpiDataAddrRW )
    {
		pToFpga->addr = ConfigU15SpiDataAddrRWAdr;
    }
    else
    if( function == p_ConfigU15SpiReadAndStartRR )
    {
		pToFpga->addr = ConfigU15SpiReadAndStartRRAdr|flagReadMask;
    }
    else
    if( function == p_ConfigU15SpiReadAndStartRW )
    {
		pToFpga->addr = ConfigU15SpiReadAndStartRWAdr;
    }
    else
    if( function == p_ConfigU18SpiDataAddrRR )
    {
		pToFpga->addr = ConfigU18SpiDataAddrRRAdr|flagReadMask;
    }
    else
    if( function == p_ConfigU18SpiDataAddrRW )
    {
		pToFpga->addr = ConfigU18SpiDataAddrRWAdr;
    }
    else
    if( function == p_ConfigU18SpiReadAndStartRR )
    {
		pToFpga->addr = ConfigU18SpiReadAndStartRRAdr|flagReadMask;
    }
    else
    if( function == p_ConfigU18SpiReadAndStartRW )
    {
		pToFpga->addr = ConfigU18SpiReadAndStartRWAdr;
    }
    else
    if( function == p_ConfigU2ClkResetRR )
    {
		pToFpga->addr = ConfigU2ClkResetRRAdr|flagReadMask;
    }
    else
    if( function == p_ConfigU2ClkResetRW )
    {
		pToFpga->addr = ConfigU2ClkResetRWAdr;
    }
    else
    if( function == p_ConfigU2IserdesResetRR )
    {
		pToFpga->addr = ConfigU2IserdesResetRRAdr|flagReadMask;
    }
    else
    if( function == p_ConfigU2IserdesResetRW )
    {
		pToFpga->addr = ConfigU2IserdesResetRWAdr;
    }
    else
    if( function == p_ConfigU3ClkResetRR )
    {
		pToFpga->addr = ConfigU3ClkResetRRAdr|flagReadMask;
    }
    else
    if( function == p_ConfigU3ClkResetRW )
    {
		pToFpga->addr = ConfigU3ClkResetRWAdr;
    }
    else
    if( function == p_ConfigU3IserdesResetRR )
    {
		pToFpga->addr = ConfigU3IserdesResetRRAdr|flagReadMask;
    }
    else
    if( function == p_ConfigU3IserdesResetRW )
    {
		pToFpga->addr = ConfigU3IserdesResetRWAdr;
    }
    else
    if( function == p_ConfigU4ResetRR )
    {
		pToFpga->addr = ConfigU4ResetRRAdr|flagReadMask;
    }
    else
    if( function == p_ConfigU4ResetRW )
    {
		pToFpga->addr = ConfigU4ResetRWAdr;
    }
    else
    if( function == p_ConfigBanyanMaskR )
    {
		pToFpga->addr = ConfigBanyanMaskRAdr|flagReadMask;
    }
    else
    if( function == p_ConfigBanyanMaskW )
    {
		pToFpga->addr = ConfigBanyanMaskWAdr;
    }
    else
    if( function == p_ConfigBitslipR )
    {
		pToFpga->addr = ConfigBitslipRAdr|flagReadMask;
    }
    else
    if( function == p_ConfigBitslipW )
    {
		pToFpga->addr = ConfigBitslipWAdr;
    }
    else
    if( function == p_ConfigClkStatusWeR )
    {
		pToFpga->addr = ConfigClkStatusWeRAdr|flagReadMask;
    }
    else
    if( function == p_ConfigClkStatusWeW )
    {
		pToFpga->addr = ConfigClkStatusWeWAdr;
    }
    else
    if( function == p_ConfigIdelayctrlResetRR )
    {
		pToFpga->addr = ConfigIdelayctrlResetRRAdr|flagReadMask;
    }
    else
    if( function == p_ConfigIdelayctrlResetRW )
    {
		pToFpga->addr = ConfigIdelayctrlResetRWAdr;
    }
    else
    if( function == p_ConfigLlspiWeR )
    {
		pToFpga->addr = ConfigLlspiWeRAdr|flagReadMask;
    }
    else
    if( function == p_ConfigLlspiWeW )
    {
		pToFpga->addr = ConfigLlspiWeWAdr;
    }
    else
    if( function == p_ConfigMmcmResetRR )
    {
		pToFpga->addr = ConfigMmcmResetRRAdr|flagReadMask;
    }
    else
    if( function == p_ConfigMmcmResetRW )
    {
		pToFpga->addr = ConfigMmcmResetRWAdr;
    }
    else
    if( function == p_ConfigPeriphConfigR )
    {
		pToFpga->addr = ConfigPeriphConfigRAdr|flagReadMask;
    }
    else
    if( function == p_ConfigPeriphConfigW )
    {
		pToFpga->addr = ConfigPeriphConfigWAdr;
    }
    else
    if( function == p_ConfigPhasexTrigR )
    {
		pToFpga->addr = ConfigPhasexTrigRAdr|flagReadMask;
    }
    else
    if( function == p_ConfigPhasexTrigW )
    {
		pToFpga->addr = ConfigPhasexTrigWAdr;
    }
    else
    if( function == p_ConfigRawadcTrigR )
    {
		pToFpga->addr = ConfigRawadcTrigRAdr|flagReadMask;
    }
    else
    if( function == p_ConfigRawadcTrigW )
    {
		pToFpga->addr = ConfigRawadcTrigWAdr;
    }
    else
    if( function == p_ConfigScanTriggerWeR )
    {
		pToFpga->addr = ConfigScanTriggerWeRAdr|flagReadMask;
    }
    else
    if( function == p_ConfigScanTriggerWeW )
    {
		pToFpga->addr = ConfigScanTriggerWeWAdr;
    }
    else
    if( function == p_ConfigScannerDebugR )
    {
		pToFpga->addr = ConfigScannerDebugRAdr|flagReadMask;
    }
    else
    if( function == p_ConfigScannerDebugW )
    {
		pToFpga->addr = ConfigScannerDebugWAdr;
    }
    else
    if( function == p_ConfigSyncAd7794CsetR )
    {
		pToFpga->addr = ConfigSyncAd7794CsetRAdr|flagReadMask;
    }
    else
    if( function == p_ConfigSyncAd7794CsetW )
    {
		pToFpga->addr = ConfigSyncAd7794CsetWAdr;
    }
    else
    if( function == p_ConfigSyncTps62210CsetR )
    {
		pToFpga->addr = ConfigSyncTps62210CsetRAdr|flagReadMask;
    }
    else
    if( function == p_ConfigSyncTps62210CsetW )
    {
		pToFpga->addr = ConfigSyncTps62210CsetWAdr;
    }
    else
    if( function == p_CrcErrorsR )
    {
		pToFpga->addr = CrcErrorsRAdr|flagReadMask;
    }
    else
    if( function == p_CtraceRunningR )
    {
		pToFpga->addr = CtraceRunningRAdr|flagReadMask;
    }
    else
    if( function == p_DacDdsResetR )
    {
		pToFpga->addr = DacDdsResetRAdr|flagReadMask;
    }
    else
    if( function == p_DacDdsResetW )
    {
		pToFpga->addr = DacDdsResetWAdr;
    }
    else
    if( function == p_DacIqPhaseR )
    {
		pToFpga->addr = DacIqPhaseRAdr|flagReadMask;
    }
    else
    if( function == p_DacIqPhaseW )
    {
		pToFpga->addr = DacIqPhaseWAdr;
    }
    else
    if( function == p_DacModeR )
    {
		pToFpga->addr = DacModeRAdr|flagReadMask;
    }
    else
    if( function == p_DacModeW )
    {
		pToFpga->addr = DacModeWAdr;
    }
    else
    if( function == p_DdsaModuloR )
    {
		pToFpga->addr = DdsaModuloRAdr|flagReadMask;
    }
    else
    if( function == p_DdsaModuloW )
    {
		pToFpga->addr = DdsaModuloWAdr;
    }
    else
    if( function == p_DdsaPhstepHR )
    {
		pToFpga->addr = DdsaPhstepHRAdr|flagReadMask;
    }
    else
    if( function == p_DdsaPhstepHW )
    {
		pToFpga->addr = DdsaPhstepHWAdr;
    }
    else
    if( function == p_DdsaPhstepLR )
    {
		pToFpga->addr = DdsaPhstepLRAdr|flagReadMask;
    }
    else
    if( function == p_DdsaPhstepLW )
    {
		pToFpga->addr = DdsaPhstepLWAdr;
    }
    else
    if( function == p_DomainJumpRealignR )
    {
		pToFpga->addr = DomainJumpRealignRAdr|flagReadMask;
    }
    else
    if( function == p_DomainJumpRealignW )
    {
		pToFpga->addr = DomainJumpRealignWAdr;
    }
    else
    if( function == p_FfffffffR )
    {
		pToFpga->addr = FfffffffRAdr|flagReadMask;
    }
    else
    if( function == p_Frequency4XoutR )
    {
		pToFpga->addr = Frequency4XoutRAdr|flagReadMask;
    }
    else
    if( function == p_FrequencyAdcR )
    {
		pToFpga->addr = FrequencyAdcRAdr|flagReadMask;
    }
    else
    if( function == p_FrequencyClkout3R )
    {
		pToFpga->addr = FrequencyClkout3RAdr|flagReadMask;
    }
    else
    if( function == p_FrequencyDcoR )
    {
		pToFpga->addr = FrequencyDcoRAdr|flagReadMask;
    }
    else
    if( function == p_FrequencyGtxRxR )
    {
		pToFpga->addr = FrequencyGtxRxRAdr|flagReadMask;
    }
    else
    if( function == p_FrequencyGtxTxR )
    {
		pToFpga->addr = FrequencyGtxTxRAdr|flagReadMask;
    }
    else
    if( function == p_Hello0R )
    {
		pToFpga->addr = Hello0RAdr|flagReadMask;
    }
    else
    if( function == p_Hello1R )
    {
		pToFpga->addr = Hello1RAdr|flagReadMask;
    }
    else
    if( function == p_Hello2R )
    {
		pToFpga->addr = Hello2RAdr|flagReadMask;
    }
    else
    if( function == p_Hello3R )
    {
		pToFpga->addr = Hello3RAdr|flagReadMask;
    }
    else
    if( function == p_HistCountWStrobeR )
    {
		pToFpga->addr = HistCountWStrobeRAdr|flagReadMask;
    }
    else
    if( function == p_HistCountWStrobeW )
    {
		pToFpga->addr = HistCountWStrobeWAdr;
    }
    else
    if( function == p_HistDoutR )
    {
		pToFpga->addr = HistDoutRAdr|flagReadMask;
    }
    else
    if( function == p_HistStatusR )
    {
		pToFpga->addr = HistStatusRAdr|flagReadMask;
    }
    else
    if( function == p_IccCfgR )
    {
		pToFpga->addr = IccCfgRAdr|flagReadMask;
    }
    else
    if( function == p_IccCfgW )
    {
		pToFpga->addr = IccCfgWAdr;
    }
    else
    if( function == p_IdelayBaseR )
    {
		pToFpga->addr = IdelayBaseRAdr|flagReadMask;
    }
    else
    if( function == p_IdelayValueOutU2LsbR )
    {
		pToFpga->addr = IdelayValueOutU2LsbRAdr|flagReadMask;
    }
    else
    if( function == p_IdelayValueOutU2MsbR )
    {
		pToFpga->addr = IdelayValueOutU2MsbRAdr|flagReadMask;
    }
    else
    if( function == p_IdelayValueOutU3LsbR )
    {
		pToFpga->addr = IdelayValueOutU3LsbRAdr|flagReadMask;
    }
    else
    if( function == p_IdelayValueOutU3MsbR )
    {
		pToFpga->addr = IdelayValueOutU3MsbRAdr|flagReadMask;
    }
    else
    if( function == p_LlrfCircleDataR )
    {
		pToFpga->addr = LlrfCircleDataRAdr|flagReadMask;
    }
    else
    if( function == p_LlrfCircleReadyR )
    {
		pToFpga->addr = LlrfCircleReadyRAdr|flagReadMask;
    }
    else
    if( function == p_LlrfDspDacEnR )
    {
		pToFpga->addr = LlrfDspDacEnRAdr|flagReadMask;
    }
    else
    if( function == p_LlrfDspDacEnW )
    {
		pToFpga->addr = LlrfDspDacEnWAdr;
    }
    else
    if( function == p_LlspiResultR )
    {
		pToFpga->addr = LlspiResultRAdr|flagReadMask;
    }
    else
    if( function == p_LlspiStatusR )
    {
		pToFpga->addr = LlspiStatusRAdr|flagReadMask;
    }
    else
    if( function == p_LoAmpR )
    {
		pToFpga->addr = LoAmpRAdr|flagReadMask;
    }
    else
    if( function == p_LoAmpW )
    {
		pToFpga->addr = LoAmpWAdr;
    }
    else
    if( function == p_ModuloR )
    {
		pToFpga->addr = ModuloRAdr|flagReadMask;
    }
    else
    if( function == p_ModuloW )
    {
		pToFpga->addr = ModuloWAdr;
    }
    else
    if( function == p_PhaseStepHR )
    {
		pToFpga->addr = PhaseStepHRAdr|flagReadMask;
    }
    else
    if( function == p_PhaseStepHW )
    {
		pToFpga->addr = PhaseStepHWAdr;
    }
    else
    if( function == p_PhaseStepLR )
    {
		pToFpga->addr = PhaseStepLRAdr|flagReadMask;
    }
    else
    if( function == p_PhaseStepLW )
    {
		pToFpga->addr = PhaseStepLWAdr;
    }
    else
    if( function == p_PhasexDoutR )
    {
		pToFpga->addr = PhasexDoutRAdr|flagReadMask;
    }
    else
    if( function == p_PhasexStatusR )
    {
		pToFpga->addr = PhasexStatusRAdr|flagReadMask;
    }
    else
    if( function == p_PrcDspCavSelR )
    {
		pToFpga->addr = PrcDspCavSelRAdr|flagReadMask;
    }
    else
    if( function == p_PrcDspCavSelW )
    {
		pToFpga->addr = PrcDspCavSelWAdr;
    }
    else
    if( function == p_PrcDspPrlCfgR )
    {
		pToFpga->addr = PrcDspPrlCfgRAdr|flagReadMask;
    }
    else
    if( function == p_PrcDspPrlCfgW )
    {
		pToFpga->addr = PrcDspPrlCfgWAdr;
    }
    else
    if( function == p_PrcDspPrlGainR )
    {
		pToFpga->addr = PrcDspPrlGainRAdr|flagReadMask;
    }
    else
    if( function == p_PrcDspPrlGainW )
    {
		pToFpga->addr = PrcDspPrlGainWAdr;
    }
    else
    if( function == p_QsfpBufR )
    {
		pToFpga->addr = QsfpBufRAdr|flagReadMask;
    }
    else
    if( function == p_QsfpI2CRegR )
    {
		pToFpga->addr = QsfpI2CRegRAdr|flagReadMask;
    }
    else
    if( function == p_QsfpI2CRegW )
    {
		pToFpga->addr = QsfpI2CRegWAdr;
    }
    else
    if( function == p_RewindR )
    {
		pToFpga->addr = RewindRAdr|flagReadMask;
    }
    else
    if( function == p_RewindW )
    {
		pToFpga->addr = RewindWAdr;
    }
    else
    if( function == p_ScannerResultR )
    {
		pToFpga->addr = ScannerResultRAdr|flagReadMask;
    }
    else
    if( function == p_SfpAddressSetR )
    {
		pToFpga->addr = SfpAddressSetRAdr|flagReadMask;
    }
    else
    if( function == p_SfpAddressSetW )
    {
		pToFpga->addr = SfpAddressSetWAdr;
    }
    else
    if( function == p_Shell0DspChanKeepR )
    {
		pToFpga->addr = Shell0DspChanKeepRAdr|flagReadMask;
    }
    else
    if( function == p_Shell0DspChanKeepW )
    {
		pToFpga->addr = Shell0DspChanKeepWAdr;
    }
    else
    if( function == p_Shell0DspFdbkCoreCoarseScaleR )
    {
		pToFpga->addr = Shell0DspFdbkCoreCoarseScaleRAdr|flagReadMask;
    }
    else
    if( function == p_Shell0DspFdbkCoreCoarseScaleW )
    {
		pToFpga->addr = Shell0DspFdbkCoreCoarseScaleWAdr;
    }
    else
    if( function == p_Shell0DspFdbkCoreMpProcCoeffR )
    {
		pToFpga->addr = Shell0DspFdbkCoreMpProcCoeffRAdr|flagReadMask;
    }
    else
    if( function == p_Shell0DspFdbkCoreMpProcCoeffW )
    {
		pToFpga->addr = Shell0DspFdbkCoreMpProcCoeffWAdr;
    }
    else
    if( function == p_Shell0DspFdbkCoreMpProcLimR )
    {
		pToFpga->addr = Shell0DspFdbkCoreMpProcLimRAdr|flagReadMask;
    }
    else
    if( function == p_Shell0DspFdbkCoreMpProcLimW )
    {
		pToFpga->addr = Shell0DspFdbkCoreMpProcLimWAdr;
    }
    else
    if( function == p_Shell0DspFdbkCoreMpProcPhOffsetR )
    {
		pToFpga->addr = Shell0DspFdbkCoreMpProcPhOffsetRAdr|flagReadMask;
    }
    else
    if( function == p_Shell0DspFdbkCoreMpProcPhOffsetW )
    {
		pToFpga->addr = Shell0DspFdbkCoreMpProcPhOffsetWAdr;
    }
    else
    if( function == p_Shell0DspFdbkCoreMpProcSelEnR )
    {
		pToFpga->addr = Shell0DspFdbkCoreMpProcSelEnRAdr|flagReadMask;
    }
    else
    if( function == p_Shell0DspFdbkCoreMpProcSelEnW )
    {
		pToFpga->addr = Shell0DspFdbkCoreMpProcSelEnWAdr;
    }
    else
    if( function == p_Shell0DspFdbkCoreMpProcSelThreshR )
    {
		pToFpga->addr = Shell0DspFdbkCoreMpProcSelThreshRAdr|flagReadMask;
    }
    else
    if( function == p_Shell0DspFdbkCoreMpProcSelThreshW )
    {
		pToFpga->addr = Shell0DspFdbkCoreMpProcSelThreshWAdr;
    }
    else
    if( function == p_Shell0DspFdbkCoreMpProcSetmpR )
    {
		pToFpga->addr = Shell0DspFdbkCoreMpProcSetmpRAdr|flagReadMask;
    }
    else
    if( function == p_Shell0DspFdbkCoreMpProcSetmpW )
    {
		pToFpga->addr = Shell0DspFdbkCoreMpProcSetmpWAdr;
    }
    else
    if( function == p_Shell0DspLpNotchLp1AKxR )
    {
		pToFpga->addr = Shell0DspLpNotchLp1AKxRAdr|flagReadMask;
    }
    else
    if( function == p_Shell0DspLpNotchLp1AKxW )
    {
		pToFpga->addr = Shell0DspLpNotchLp1AKxWAdr;
    }
    else
    if( function == p_Shell0DspLpNotchLp1AKyR )
    {
		pToFpga->addr = Shell0DspLpNotchLp1AKyRAdr|flagReadMask;
    }
    else
    if( function == p_Shell0DspLpNotchLp1AKyW )
    {
		pToFpga->addr = Shell0DspLpNotchLp1AKyWAdr;
    }
    else
    if( function == p_Shell0DspLpNotchLp1BKxR )
    {
		pToFpga->addr = Shell0DspLpNotchLp1BKxRAdr|flagReadMask;
    }
    else
    if( function == p_Shell0DspLpNotchLp1BKxW )
    {
		pToFpga->addr = Shell0DspLpNotchLp1BKxWAdr;
    }
    else
    if( function == p_Shell0DspLpNotchLp1BKyR )
    {
		pToFpga->addr = Shell0DspLpNotchLp1BKyRAdr|flagReadMask;
    }
    else
    if( function == p_Shell0DspLpNotchLp1BKyW )
    {
		pToFpga->addr = Shell0DspLpNotchLp1BKyWAdr;
    }
    else
    if( function == p_Shell0DspModuloR )
    {
		pToFpga->addr = Shell0DspModuloRAdr|flagReadMask;
    }
    else
    if( function == p_Shell0DspModuloW )
    {
		pToFpga->addr = Shell0DspModuloWAdr;
    }
    else
    if( function == p_Shell0DspPhaseStepR )
    {
		pToFpga->addr = Shell0DspPhaseStepRAdr|flagReadMask;
    }
    else
    if( function == p_Shell0DspPhaseStepW )
    {
		pToFpga->addr = Shell0DspPhaseStepWAdr;
    }
    else
    if( function == p_Shell0DspPiezoPiezoDcR )
    {
		pToFpga->addr = Shell0DspPiezoPiezoDcRAdr|flagReadMask;
    }
    else
    if( function == p_Shell0DspPiezoPiezoDcW )
    {
		pToFpga->addr = Shell0DspPiezoPiezoDcWAdr;
    }
    else
    if( function == p_Shell0DspPiezoSfConstsR )
    {
		pToFpga->addr = Shell0DspPiezoSfConstsRAdr|flagReadMask;
    }
    else
    if( function == p_Shell0DspPiezoSfConstsW )
    {
		pToFpga->addr = Shell0DspPiezoSfConstsWAdr;
    }
    else
    if( function == p_Shell0DspTagR )
    {
		pToFpga->addr = Shell0DspTagRAdr|flagReadMask;
    }
    else
    if( function == p_Shell0DspTagW )
    {
		pToFpga->addr = Shell0DspTagWAdr;
    }
    else
    if( function == p_Shell0DspUseFiberIqR )
    {
		pToFpga->addr = Shell0DspUseFiberIqRAdr|flagReadMask;
    }
    else
    if( function == p_Shell0DspUseFiberIqW )
    {
		pToFpga->addr = Shell0DspUseFiberIqWAdr;
    }
    else
    if( function == p_Shell0DspWaveSampPerR )
    {
		pToFpga->addr = Shell0DspWaveSampPerRAdr|flagReadMask;
    }
    else
    if( function == p_Shell0DspWaveSampPerW )
    {
		pToFpga->addr = Shell0DspWaveSampPerWAdr;
    }
    else
    if( function == p_Shell0DspWaveShiftR )
    {
		pToFpga->addr = Shell0DspWaveShiftRAdr|flagReadMask;
    }
    else
    if( function == p_Shell0DspWaveShiftW )
    {
		pToFpga->addr = Shell0DspWaveShiftWAdr;
    }
    else
    if( function == p_Shell0SlowDataR )
    {
		pToFpga->addr = Shell0SlowDataRAdr|flagReadMask;
    }
    else
    if( function == p_Shell1DspChanKeepR )
    {
		pToFpga->addr = Shell1DspChanKeepRAdr|flagReadMask;
    }
    else
    if( function == p_Shell1DspChanKeepW )
    {
		pToFpga->addr = Shell1DspChanKeepWAdr;
    }
    else
    if( function == p_Shell1DspFdbkCoreCoarseScaleR )
    {
		pToFpga->addr = Shell1DspFdbkCoreCoarseScaleRAdr|flagReadMask;
    }
    else
    if( function == p_Shell1DspFdbkCoreCoarseScaleW )
    {
		pToFpga->addr = Shell1DspFdbkCoreCoarseScaleWAdr;
    }
    else
    if( function == p_Shell1DspFdbkCoreMpProcCoeffR )
    {
		pToFpga->addr = Shell1DspFdbkCoreMpProcCoeffRAdr|flagReadMask;
    }
    else
    if( function == p_Shell1DspFdbkCoreMpProcCoeffW )
    {
		pToFpga->addr = Shell1DspFdbkCoreMpProcCoeffWAdr;
    }
    else
    if( function == p_Shell1DspFdbkCoreMpProcLimR )
    {
		pToFpga->addr = Shell1DspFdbkCoreMpProcLimRAdr|flagReadMask;
    }
    else
    if( function == p_Shell1DspFdbkCoreMpProcLimW )
    {
		pToFpga->addr = Shell1DspFdbkCoreMpProcLimWAdr;
    }
    else
    if( function == p_Shell1DspFdbkCoreMpProcPhOffsetR )
    {
		pToFpga->addr = Shell1DspFdbkCoreMpProcPhOffsetRAdr|flagReadMask;
    }
    else
    if( function == p_Shell1DspFdbkCoreMpProcPhOffsetW )
    {
		pToFpga->addr = Shell1DspFdbkCoreMpProcPhOffsetWAdr;
    }
    else
    if( function == p_Shell1DspFdbkCoreMpProcSelEnR )
    {
		pToFpga->addr = Shell1DspFdbkCoreMpProcSelEnRAdr|flagReadMask;
    }
    else
    if( function == p_Shell1DspFdbkCoreMpProcSelEnW )
    {
		pToFpga->addr = Shell1DspFdbkCoreMpProcSelEnWAdr;
    }
    else
    if( function == p_Shell1DspFdbkCoreMpProcSelThreshR )
    {
		pToFpga->addr = Shell1DspFdbkCoreMpProcSelThreshRAdr|flagReadMask;
    }
    else
    if( function == p_Shell1DspFdbkCoreMpProcSelThreshW )
    {
		pToFpga->addr = Shell1DspFdbkCoreMpProcSelThreshWAdr;
    }
    else
    if( function == p_Shell1DspFdbkCoreMpProcSetmpR )
    {
		pToFpga->addr = Shell1DspFdbkCoreMpProcSetmpRAdr|flagReadMask;
    }
    else
    if( function == p_Shell1DspFdbkCoreMpProcSetmpW )
    {
		pToFpga->addr = Shell1DspFdbkCoreMpProcSetmpWAdr;
    }
    else
    if( function == p_Shell1DspLpNotchLp1AKxR )
    {
		pToFpga->addr = Shell1DspLpNotchLp1AKxRAdr|flagReadMask;
    }
    else
    if( function == p_Shell1DspLpNotchLp1AKxW )
    {
		pToFpga->addr = Shell1DspLpNotchLp1AKxWAdr;
    }
    else
    if( function == p_Shell1DspLpNotchLp1AKyR )
    {
		pToFpga->addr = Shell1DspLpNotchLp1AKyRAdr|flagReadMask;
    }
    else
    if( function == p_Shell1DspLpNotchLp1AKyW )
    {
		pToFpga->addr = Shell1DspLpNotchLp1AKyWAdr;
    }
    else
    if( function == p_Shell1DspLpNotchLp1BKxR )
    {
		pToFpga->addr = Shell1DspLpNotchLp1BKxRAdr|flagReadMask;
    }
    else
    if( function == p_Shell1DspLpNotchLp1BKxW )
    {
		pToFpga->addr = Shell1DspLpNotchLp1BKxWAdr;
    }
    else
    if( function == p_Shell1DspLpNotchLp1BKyR )
    {
		pToFpga->addr = Shell1DspLpNotchLp1BKyRAdr|flagReadMask;
    }
    else
    if( function == p_Shell1DspLpNotchLp1BKyW )
    {
		pToFpga->addr = Shell1DspLpNotchLp1BKyWAdr;
    }
    else
    if( function == p_Shell1DspModuloR )
    {
		pToFpga->addr = Shell1DspModuloRAdr|flagReadMask;
    }
    else
    if( function == p_Shell1DspModuloW )
    {
		pToFpga->addr = Shell1DspModuloWAdr;
    }
    else
    if( function == p_Shell1DspPhaseStepR )
    {
		pToFpga->addr = Shell1DspPhaseStepRAdr|flagReadMask;
    }
    else
    if( function == p_Shell1DspPhaseStepW )
    {
		pToFpga->addr = Shell1DspPhaseStepWAdr;
    }
    else
    if( function == p_Shell1DspPiezoPiezoDcR )
    {
		pToFpga->addr = Shell1DspPiezoPiezoDcRAdr|flagReadMask;
    }
    else
    if( function == p_Shell1DspPiezoPiezoDcW )
    {
		pToFpga->addr = Shell1DspPiezoPiezoDcWAdr;
    }
    else
    if( function == p_Shell1DspPiezoSfConstsR )
    {
		pToFpga->addr = Shell1DspPiezoSfConstsRAdr|flagReadMask;
    }
    else
    if( function == p_Shell1DspPiezoSfConstsW )
    {
		pToFpga->addr = Shell1DspPiezoSfConstsWAdr;
    }
    else
    if( function == p_Shell1DspTagR )
    {
		pToFpga->addr = Shell1DspTagRAdr|flagReadMask;
    }
    else
    if( function == p_Shell1DspTagW )
    {
		pToFpga->addr = Shell1DspTagWAdr;
    }
    else
    if( function == p_Shell1DspUseFiberIqR )
    {
		pToFpga->addr = Shell1DspUseFiberIqRAdr|flagReadMask;
    }
    else
    if( function == p_Shell1DspUseFiberIqW )
    {
		pToFpga->addr = Shell1DspUseFiberIqWAdr;
    }
    else
    if( function == p_Shell1DspWaveSampPerR )
    {
		pToFpga->addr = Shell1DspWaveSampPerRAdr|flagReadMask;
    }
    else
    if( function == p_Shell1DspWaveSampPerW )
    {
		pToFpga->addr = Shell1DspWaveSampPerWAdr;
    }
    else
    if( function == p_Shell1DspWaveShiftR )
    {
		pToFpga->addr = Shell1DspWaveShiftRAdr|flagReadMask;
    }
    else
    if( function == p_Shell1DspWaveShiftW )
    {
		pToFpga->addr = Shell1DspWaveShiftWAdr;
    }
    else
    if( function == p_Shell1SlowDataR )
    {
		pToFpga->addr = Shell1SlowDataRAdr|flagReadMask;
    }
    else
    if( function == p_SlowChainOutR )
    {
		pToFpga->addr = SlowChainOutRAdr|flagReadMask;
    }
    else
    if( function == p_SsaStimAmpstepR )
    {
		pToFpga->addr = SsaStimAmpstepRAdr|flagReadMask;
    }
    else
    if( function == p_SsaStimAmpstepW )
    {
		pToFpga->addr = SsaStimAmpstepWAdr;
    }
    else
    if( function == p_SsaStimEnR )
    {
		pToFpga->addr = SsaStimEnRAdr|flagReadMask;
    }
    else
    if( function == p_SsaStimEnW )
    {
		pToFpga->addr = SsaStimEnWAdr;
    }
    else
    if( function == p_SsaStimGPeriodR )
    {
		pToFpga->addr = SsaStimGPeriodRAdr|flagReadMask;
    }
    else
    if( function == p_SsaStimGPeriodW )
    {
		pToFpga->addr = SsaStimGPeriodWAdr;
    }
    else
    if( function == p_SsaStimPertstepR )
    {
		pToFpga->addr = SsaStimPertstepRAdr|flagReadMask;
    }
    else
    if( function == p_SsaStimPertstepW )
    {
		pToFpga->addr = SsaStimPertstepWAdr;
    }
    else
    if( function == p_TagNowR )
    {
		pToFpga->addr = TagNowRAdr|flagReadMask;
    }
    else
    if( function == p_TagNowW )
    {
		pToFpga->addr = TagNowWAdr;
    }
    else
    if( function == p_Tgen0DelayPcXxxW )
    {
		pToFpga->addr = Tgen0DelayPcXxxWAdr;
    }
    else
    if( function == p_Tgen1DelayPcXxxW )
    {
		pToFpga->addr = Tgen1DelayPcXxxWAdr;
    }
    else
    if( function == p_TraceIBufR )
    {
		pToFpga->addr = TraceIBufRAdr|flagReadMask;
    }
    else
    if( function == p_TraceIqBufR )
    {
		pToFpga->addr = TraceIqBufRAdr|flagReadMask;
    }
    else
    if( function == p_TraceKeepR )
    {
		pToFpga->addr = TraceKeepRAdr|flagReadMask;
    }
    else
    if( function == p_TraceKeepW )
    {
		pToFpga->addr = TraceKeepWAdr;
    }
    else
    if( function == p_TraceQBufR )
    {
		pToFpga->addr = TraceQBufRAdr|flagReadMask;
    }
    else
    if( function == p_TraceResetWeR )
    {
		pToFpga->addr = TraceResetWeRAdr|flagReadMask;
    }
    else
    if( function == p_TraceResetWeW )
    {
		pToFpga->addr = TraceResetWeWAdr;
    }
    else
    if( function == p_TraceStatus1R )
    {
		pToFpga->addr = TraceStatus1RAdr|flagReadMask;
    }
    else
    if( function == p_TraceStatus2R )
    {
		pToFpga->addr = TraceStatus2RAdr|flagReadMask;
    }
    else
    if( function == p_TrigInternalR )
    {
		pToFpga->addr = TrigInternalRAdr|flagReadMask;
    }
    else
    if( function == p_TrigInternalW )
    {
		pToFpga->addr = TrigInternalWAdr;
    }
    else
    if( function == p_TrigModeR )
    {
		pToFpga->addr = TrigModeRAdr|flagReadMask;
    }
    else
    if( function == p_TrigModeW )
    {
		pToFpga->addr = TrigModeWAdr;
    }
    else
    if( function == p_Wave0OutR )
    {
		pToFpga->addr = Wave0OutRAdr|flagReadMask;
    }
    else
    if( function == p_Wave0SrcR )
    {
		pToFpga->addr = Wave0SrcRAdr|flagReadMask;
    }
    else
    if( function == p_Wave0SrcW )
    {
		pToFpga->addr = Wave0SrcWAdr;
    }
    else
    if( function == p_Wave1OutR )
    {
		pToFpga->addr = Wave1OutRAdr|flagReadMask;
    }
    else
    if( function == p_Wave1SrcR )
    {
		pToFpga->addr = Wave1SrcRAdr|flagReadMask;
    }
    else
    if( function == p_Wave1SrcW )
    {
		pToFpga->addr = Wave1SrcWAdr;
    }
    else
    if( function == p_WaveformsAvailableR )
    {
		pToFpga->addr = WaveformsAvailableRAdr|flagReadMask;
    }
    else
    	status = asynError;

    return status;
}

/**  Extract register address and data from the received message and set the appropriate
 * asyn parameter.
 * Some registers have a "new waveform data ready" flag. If they have this and it is set,
 * set weveIsReady to true.
 * Note: This function should not set waveIsReady to false. That is done by a loop in the
 * calling function.
* \param[in] pFromFpga Data returned from the FPGA for a single register
* \param[in] waveIsReady A flag that gets set to true if the appropriate bit was set by the FPGA
*/
asynStatus scllrfPRCDriver::processRegReadback(const FpgaReg *pFromFpga, bool &waveIsReady)
{
	asynStatus status = asynSuccess;
	assert(pFromFpga->addr&flagReadMask); // This function is only for read registers
	epicsInt32 errorCount;
	int32_t signExtBits = 0;
	int chan;

	/* Map address to parameter, set the parameter in the parameter library. */
	switch (pFromFpga->addr)
    {
	break;

    case Hello0RAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Hello0R,
				(pFromFpga->data & Hello0Mask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Hello0RString,
				(unsigned ) pFromFpga->data & Hello0Mask);
	break;

    case Hello1RAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Hello1R,
				(pFromFpga->data & Hello1Mask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Hello1RString,
				(unsigned ) pFromFpga->data & Hello1Mask);
	break;

    case Hello2RAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Hello2R,
				(pFromFpga->data & Hello2Mask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Hello2RString,
				(unsigned ) pFromFpga->data & Hello2Mask);
	break;

    case Hello3RAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Hello3R,
				(pFromFpga->data & Hello3Mask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Hello3RString,
				(unsigned ) pFromFpga->data & Hello3Mask);
	break;

    case LlspiStatusRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_LlspiStatusR,
				(pFromFpga->data & LlspiStatusMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				LlspiStatusRString,
				(unsigned ) pFromFpga->data & LlspiStatusMask);
	break;

    case LlspiResultRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_LlspiResultR,
				(pFromFpga->data & LlspiResultMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				LlspiResultRString,
				(unsigned ) pFromFpga->data & LlspiResultMask);
	break;

    case ClkStatusOutRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_ClkStatusOutR,
				(pFromFpga->data & ClkStatusOutMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				ClkStatusOutRString,
				(unsigned ) pFromFpga->data & ClkStatusOutMask);
	break;

    case FfffffffRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_FfffffffR,
				(pFromFpga->data & FfffffffMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				FfffffffRString,
				(unsigned ) pFromFpga->data & FfffffffMask);
	break;

    case FrequencyAdcRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_FrequencyAdcR,
				(pFromFpga->data & FrequencyAdcMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				FrequencyAdcRString,
				(unsigned ) pFromFpga->data & FrequencyAdcMask);
	break;

    case Frequency4XoutRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Frequency4XoutR,
				(pFromFpga->data & Frequency4XoutMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Frequency4XoutRString,
				(unsigned ) pFromFpga->data & Frequency4XoutMask);
	break;

    case FrequencyClkout3RAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_FrequencyClkout3R,
				(pFromFpga->data & FrequencyClkout3Mask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				FrequencyClkout3RString,
				(unsigned ) pFromFpga->data & FrequencyClkout3Mask);
	break;

    case FrequencyDcoRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_FrequencyDcoR,
				(pFromFpga->data & FrequencyDcoMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				FrequencyDcoRString,
				(unsigned ) pFromFpga->data & FrequencyDcoMask);
	break;

    case U2DoutLsbRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_U2DoutLsbR,
				(pFromFpga->data & U2DoutLsbMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				U2DoutLsbRString,
				(unsigned ) pFromFpga->data & U2DoutLsbMask);
	break;

    case U2DoutMsbRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_U2DoutMsbR,
				(pFromFpga->data & U2DoutMsbMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				U2DoutMsbRString,
				(unsigned ) pFromFpga->data & U2DoutMsbMask);
	break;

    case IdelayValueOutU2LsbRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_IdelayValueOutU2LsbR,
				(pFromFpga->data & IdelayValueOutU2LsbMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				IdelayValueOutU2LsbRString,
				(unsigned ) pFromFpga->data & IdelayValueOutU2LsbMask);
	break;

    case IdelayValueOutU2MsbRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_IdelayValueOutU2MsbR,
				(pFromFpga->data & IdelayValueOutU2MsbMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				IdelayValueOutU2MsbRString,
				(unsigned ) pFromFpga->data & IdelayValueOutU2MsbMask);
	break;

    case U3DoutLsbRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_U3DoutLsbR,
				(pFromFpga->data & U3DoutLsbMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				U3DoutLsbRString,
				(unsigned ) pFromFpga->data & U3DoutLsbMask);
	break;

    case U3DoutMsbRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_U3DoutMsbR,
				(pFromFpga->data & U3DoutMsbMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				U3DoutMsbRString,
				(unsigned ) pFromFpga->data & U3DoutMsbMask);
	break;

    case IdelayValueOutU3LsbRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_IdelayValueOutU3LsbR,
				(pFromFpga->data & IdelayValueOutU3LsbMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				IdelayValueOutU3LsbRString,
				(unsigned ) pFromFpga->data & IdelayValueOutU3LsbMask);
	break;

    case IdelayValueOutU3MsbRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_IdelayValueOutU3MsbR,
				(pFromFpga->data & IdelayValueOutU3MsbMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				IdelayValueOutU3MsbRString,
				(unsigned ) pFromFpga->data & IdelayValueOutU3MsbMask);
	break;

    case Wave0OutRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Wave0OutR,
				(pFromFpga->data & Wave0OutMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Wave0OutRString,
				(unsigned ) pFromFpga->data & Wave0OutMask);
	break;

    case Wave1OutRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Wave1OutR,
				(pFromFpga->data & Wave1OutMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Wave1OutRString,
				(unsigned ) pFromFpga->data & Wave1OutMask);
	break;

    case AdcTestWave1OutRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_AdcTestWave1OutR,
				(pFromFpga->data & AdcTestWave1OutMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				AdcTestWave1OutRString,
				(unsigned ) pFromFpga->data & AdcTestWave1OutMask);
	break;

    case AdcTestWave2OutRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_AdcTestWave2OutR,
				(pFromFpga->data & AdcTestWave2OutMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				AdcTestWave2OutRString,
				(unsigned ) pFromFpga->data & AdcTestWave2OutMask);
	break;

    case AdcTestWave3OutRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_AdcTestWave3OutR,
				(pFromFpga->data & AdcTestWave3OutMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				AdcTestWave3OutRString,
				(unsigned ) pFromFpga->data & AdcTestWave3OutMask);
	break;

    case AdcTestWave4OutRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_AdcTestWave4OutR,
				(pFromFpga->data & AdcTestWave4OutMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				AdcTestWave4OutRString,
				(unsigned ) pFromFpga->data & AdcTestWave4OutMask);
	break;

    case CtraceRunningRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_CtraceRunningR,
				(pFromFpga->data & CtraceRunningMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				CtraceRunningRString,
				(unsigned ) pFromFpga->data & CtraceRunningMask);
	break;

    case FrequencyGtxTxRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_FrequencyGtxTxR,
				(pFromFpga->data & FrequencyGtxTxMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				FrequencyGtxTxRString,
				(unsigned ) pFromFpga->data & FrequencyGtxTxMask);
	break;

    case FrequencyGtxRxRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_FrequencyGtxRxR,
				(pFromFpga->data & FrequencyGtxRxMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				FrequencyGtxRxRString,
				(unsigned ) pFromFpga->data & FrequencyGtxRxMask);
	break;

    case HistStatusRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_HistStatusR,
				(pFromFpga->data & HistStatusMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				HistStatusRString,
				(unsigned ) pFromFpga->data & HistStatusMask);
	break;

    case PhasexStatusRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_PhasexStatusR,
				(pFromFpga->data & PhasexStatusMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				PhasexStatusRString,
				(unsigned ) pFromFpga->data & PhasexStatusMask);
	break;

    case ClkPhaseDiffOutU2RAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_ClkPhaseDiffOutU2R,
				(pFromFpga->data & ClkPhaseDiffOutU2Mask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				ClkPhaseDiffOutU2RString,
				(unsigned ) pFromFpga->data & ClkPhaseDiffOutU2Mask);
	break;

    case ClkPhaseDiffOutU3RAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_ClkPhaseDiffOutU3R,
				(pFromFpga->data & ClkPhaseDiffOutU3Mask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				ClkPhaseDiffOutU3RString,
				(unsigned ) pFromFpga->data & ClkPhaseDiffOutU3Mask);
	break;

    case CrcErrorsRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_CrcErrorsR,
				(pFromFpga->data & CrcErrorsMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				CrcErrorsRString,
				(unsigned ) pFromFpga->data & CrcErrorsMask);
	break;

    case Cavity0DetuneRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Cavity0DetuneR,
				(pFromFpga->data & Cavity0DetuneMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0DetuneRString,
				(unsigned ) pFromFpga->data & Cavity0DetuneMask);
	break;

    case Cavity1DetuneRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Cavity1DetuneR,
				(pFromFpga->data & Cavity1DetuneMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1DetuneRString,
				(unsigned ) pFromFpga->data & Cavity1DetuneMask);
	break;

    case U15SpiRdbkRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_U15SpiRdbkR,
				(pFromFpga->data & U15SpiRdbkMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				U15SpiRdbkRString,
				(unsigned ) pFromFpga->data & U15SpiRdbkMask);
	break;

    case U15SpiStatusRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_U15SpiStatusR,
				(pFromFpga->data & U15SpiStatusMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				U15SpiStatusRString,
				(unsigned ) pFromFpga->data & U15SpiStatusMask);
	break;

    case U18SpiRdbkRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_U18SpiRdbkR,
				(pFromFpga->data & U18SpiRdbkMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				U18SpiRdbkRString,
				(unsigned ) pFromFpga->data & U18SpiRdbkMask);
	break;

    case U18SpiStatusRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_U18SpiStatusR,
				(pFromFpga->data & U18SpiStatusMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				U18SpiStatusRString,
				(unsigned ) pFromFpga->data & U18SpiStatusMask);
	break;

    case AdcTestTrigCntRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_AdcTestTrigCntR,
				(pFromFpga->data & AdcTestTrigCntMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				AdcTestTrigCntRString,
				(unsigned ) pFromFpga->data & AdcTestTrigCntMask);
	break;

    case WaveformsAvailableRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_WaveformsAvailableR,
				(pFromFpga->data & WaveformsAvailableMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				WaveformsAvailableRString,
				(unsigned ) pFromFpga->data & WaveformsAvailableMask);
	break;

    case BanyanStatusRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_BanyanStatusR,
				(pFromFpga->data & BanyanStatusMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				BanyanStatusRString,
				(unsigned ) pFromFpga->data & BanyanStatusMask);
	break;

    case SlowChainOutRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_SlowChainOutR,
				(pFromFpga->data & SlowChainOutMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				SlowChainOutRString,
				(unsigned ) pFromFpga->data & SlowChainOutMask);
	break;

    case TraceStatus1RAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_TraceStatus1R,
				(pFromFpga->data & TraceStatus1Mask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				TraceStatus1RString,
				(unsigned ) pFromFpga->data & TraceStatus1Mask);
	break;

    case TraceStatus2RAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_TraceStatus2R,
				(pFromFpga->data & TraceStatus2Mask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				TraceStatus2RString,
				(unsigned ) pFromFpga->data & TraceStatus2Mask);
	break;

    case LlrfCircleReadyRAdr|flagReadMask:

		status = (asynStatus) setUIntDigitalParam(p_LlrfCircleReadyR,
				(pFromFpga->data & LlrfCircleReadyMask) , LlrfCircleReadyMask);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				LlrfCircleReadyRString,
				(unsigned ) pFromFpga->data & LlrfCircleReadyMask);
	break;

    case AdcMmcmRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_AdcMmcmR,
				(pFromFpga->data & AdcMmcmMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				AdcMmcmRString,
				(unsigned ) pFromFpga->data & AdcMmcmMask);
	break;

    case CcErrorClearRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_CcErrorClearR,
				(pFromFpga->data & CcErrorClearMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				CcErrorClearRString,
				(unsigned ) pFromFpga->data & CcErrorClearMask);
	break;

    case CcLoc1RAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_CcLoc1R,
				(pFromFpga->data & CcLoc1Mask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				CcLoc1RString,
				(unsigned ) pFromFpga->data & CcLoc1Mask);
	break;

    case Cct1Cavity0StatusAuxRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Cct1Cavity0StatusAuxR,
				(pFromFpga->data & Cct1Cavity0StatusAuxMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cct1Cavity0StatusAuxRString,
				(unsigned ) pFromFpga->data & Cct1Cavity0StatusAuxMask);
	break;

    case Cct1Cavity1StatusAuxRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Cct1Cavity1StatusAuxR,
				(pFromFpga->data & Cct1Cavity1StatusAuxMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cct1Cavity1StatusAuxRString,
				(unsigned ) pFromFpga->data & Cct1Cavity1StatusAuxMask);
	break;

    case ConfigU15SpiDataAddrRRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_ConfigU15SpiDataAddrRR,
				(pFromFpga->data & ConfigU15SpiDataAddrRMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				ConfigU15SpiDataAddrRRString,
				(unsigned ) pFromFpga->data & ConfigU15SpiDataAddrRMask);
	break;

    case ConfigU15SpiReadAndStartRRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_ConfigU15SpiReadAndStartRR,
				(pFromFpga->data & ConfigU15SpiReadAndStartRMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				ConfigU15SpiReadAndStartRRString,
				(unsigned ) pFromFpga->data & ConfigU15SpiReadAndStartRMask);
	break;

    case ConfigU18SpiDataAddrRRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_ConfigU18SpiDataAddrRR,
				(pFromFpga->data & ConfigU18SpiDataAddrRMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				ConfigU18SpiDataAddrRRString,
				(unsigned ) pFromFpga->data & ConfigU18SpiDataAddrRMask);
	break;

    case ConfigU18SpiReadAndStartRRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_ConfigU18SpiReadAndStartRR,
				(pFromFpga->data & ConfigU18SpiReadAndStartRMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				ConfigU18SpiReadAndStartRRString,
				(unsigned ) pFromFpga->data & ConfigU18SpiReadAndStartRMask);
	break;

    case ConfigU2ClkResetRRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_ConfigU2ClkResetRR,
				(pFromFpga->data & ConfigU2ClkResetRMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				ConfigU2ClkResetRRString,
				(unsigned ) pFromFpga->data & ConfigU2ClkResetRMask);
	break;

    case ConfigU2IserdesResetRRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_ConfigU2IserdesResetRR,
				(pFromFpga->data & ConfigU2IserdesResetRMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				ConfigU2IserdesResetRRString,
				(unsigned ) pFromFpga->data & ConfigU2IserdesResetRMask);
	break;

    case ConfigU3ClkResetRRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_ConfigU3ClkResetRR,
				(pFromFpga->data & ConfigU3ClkResetRMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				ConfigU3ClkResetRRString,
				(unsigned ) pFromFpga->data & ConfigU3ClkResetRMask);
	break;

    case ConfigU3IserdesResetRRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_ConfigU3IserdesResetRR,
				(pFromFpga->data & ConfigU3IserdesResetRMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				ConfigU3IserdesResetRRString,
				(unsigned ) pFromFpga->data & ConfigU3IserdesResetRMask);
	break;

    case ConfigU4ResetRRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_ConfigU4ResetRR,
				(pFromFpga->data & ConfigU4ResetRMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				ConfigU4ResetRRString,
				(unsigned ) pFromFpga->data & ConfigU4ResetRMask);
	break;

    case ConfigBanyanMaskRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_ConfigBanyanMaskR,
				(pFromFpga->data & ConfigBanyanMaskMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				ConfigBanyanMaskRString,
				(unsigned ) pFromFpga->data & ConfigBanyanMaskMask);
	break;

    case ConfigBitslipRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_ConfigBitslipR,
				(pFromFpga->data & ConfigBitslipMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				ConfigBitslipRString,
				(unsigned ) pFromFpga->data & ConfigBitslipMask);
	break;

    case ConfigClkStatusWeRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_ConfigClkStatusWeR,
				(pFromFpga->data & ConfigClkStatusWeMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				ConfigClkStatusWeRString,
				(unsigned ) pFromFpga->data & ConfigClkStatusWeMask);
	break;

    case ConfigIdelayctrlResetRRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_ConfigIdelayctrlResetRR,
				(pFromFpga->data & ConfigIdelayctrlResetRMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				ConfigIdelayctrlResetRRString,
				(unsigned ) pFromFpga->data & ConfigIdelayctrlResetRMask);
	break;

    case ConfigLlspiWeRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_ConfigLlspiWeR,
				(pFromFpga->data & ConfigLlspiWeMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				ConfigLlspiWeRString,
				(unsigned ) pFromFpga->data & ConfigLlspiWeMask);
	break;

    case ConfigMmcmResetRRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_ConfigMmcmResetRR,
				(pFromFpga->data & ConfigMmcmResetRMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				ConfigMmcmResetRRString,
				(unsigned ) pFromFpga->data & ConfigMmcmResetRMask);
	break;

    case ConfigPeriphConfigRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_ConfigPeriphConfigR,
				(pFromFpga->data & ConfigPeriphConfigMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				ConfigPeriphConfigRString,
				(unsigned ) pFromFpga->data & ConfigPeriphConfigMask);
	break;

    case ConfigPhasexTrigRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_ConfigPhasexTrigR,
				(pFromFpga->data & ConfigPhasexTrigMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				ConfigPhasexTrigRString,
				(unsigned ) pFromFpga->data & ConfigPhasexTrigMask);
	break;

    case ConfigRawadcTrigRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_ConfigRawadcTrigR,
				(pFromFpga->data & ConfigRawadcTrigMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				ConfigRawadcTrigRString,
				(unsigned ) pFromFpga->data & ConfigRawadcTrigMask);
	break;

    case ConfigScanTriggerWeRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_ConfigScanTriggerWeR,
				(pFromFpga->data & ConfigScanTriggerWeMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				ConfigScanTriggerWeRString,
				(unsigned ) pFromFpga->data & ConfigScanTriggerWeMask);
	break;

    case ConfigScannerDebugRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_ConfigScannerDebugR,
				(pFromFpga->data & ConfigScannerDebugMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				ConfigScannerDebugRString,
				(unsigned ) pFromFpga->data & ConfigScannerDebugMask);
	break;

    case ConfigSyncAd7794CsetRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_ConfigSyncAd7794CsetR,
				(pFromFpga->data & ConfigSyncAd7794CsetMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				ConfigSyncAd7794CsetRString,
				(unsigned ) pFromFpga->data & ConfigSyncAd7794CsetMask);
	break;

    case ConfigSyncTps62210CsetRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_ConfigSyncTps62210CsetR,
				(pFromFpga->data & ConfigSyncTps62210CsetMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				ConfigSyncTps62210CsetRString,
				(unsigned ) pFromFpga->data & ConfigSyncTps62210CsetMask);
	break;

    case AdcTestModeRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_AdcTestModeR,
				(pFromFpga->data & AdcTestModeMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				AdcTestModeRString,
				(unsigned ) pFromFpga->data & AdcTestModeMask);
	break;

    case AdcTestResetRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_AdcTestResetR,
				(pFromFpga->data & AdcTestResetMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				AdcTestResetRString,
				(unsigned ) pFromFpga->data & AdcTestResetMask);
	break;

    case AmplitudeRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_AmplitudeR,
				(pFromFpga->data & AmplitudeMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				AmplitudeRString,
				(unsigned ) pFromFpga->data & AmplitudeMask);
	break;

    case AverageLenRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_AverageLenR,
				(pFromFpga->data & AverageLenMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				AverageLenRString,
				(unsigned ) pFromFpga->data & AverageLenMask);
	break;

    case BufTrigRAdr|flagReadMask:

		status = (asynStatus) setUIntDigitalParam(p_BufTrigR,
				(pFromFpga->data & BufTrigMask) , BufTrigMask);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				BufTrigRString,
				(unsigned ) pFromFpga->data & BufTrigMask);
	break;

    case CicPeriodRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_CicPeriodR,
				(pFromFpga->data & CicPeriodMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				CicPeriodRString,
				(unsigned ) pFromFpga->data & CicPeriodMask);
	break;

    case CicShiftRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_CicShiftR,
				(pFromFpga->data & CicShiftMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				CicShiftRString,
				(unsigned ) pFromFpga->data & CicShiftMask);
	break;

    case CircleBufFlipRAdr|flagReadMask:

		status = (asynStatus) setUIntDigitalParam(p_CircleBufFlipR,
				(pFromFpga->data & CircleBufFlipMask) , CircleBufFlipMask);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				CircleBufFlipRString,
				(unsigned ) pFromFpga->data & CircleBufFlipMask);
	break;

    case DacDdsResetRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_DacDdsResetR,
				(pFromFpga->data & DacDdsResetMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DacDdsResetRString,
				(unsigned ) pFromFpga->data & DacDdsResetMask);
	break;

    case DacModeRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_DacModeR,
				(pFromFpga->data & DacModeMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DacModeRString,
				(unsigned ) pFromFpga->data & DacModeMask);
	break;

    case DdsaModuloRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_DdsaModuloR,
				(pFromFpga->data & DdsaModuloMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DdsaModuloRString,
				(unsigned ) pFromFpga->data & DdsaModuloMask);
	break;

    case DdsaPhstepHRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_DdsaPhstepHR,
				(pFromFpga->data & DdsaPhstepHMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DdsaPhstepHRString,
				(unsigned ) pFromFpga->data & DdsaPhstepHMask);
	break;

    case DdsaPhstepLRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_DdsaPhstepLR,
				(pFromFpga->data & DdsaPhstepLMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DdsaPhstepLRString,
				(unsigned ) pFromFpga->data & DdsaPhstepLMask);
	break;

    case HistCountWStrobeRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_HistCountWStrobeR,
				(pFromFpga->data & HistCountWStrobeMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				HistCountWStrobeRString,
				(unsigned ) pFromFpga->data & HistCountWStrobeMask);
	break;

    case LlrfDspDacEnRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_LlrfDspDacEnR,
				(pFromFpga->data & LlrfDspDacEnMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				LlrfDspDacEnRString,
				(unsigned ) pFromFpga->data & LlrfDspDacEnMask);
	break;

    case LoAmpRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_LoAmpR,
				(pFromFpga->data & LoAmpMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				LoAmpRString,
				(unsigned ) pFromFpga->data & LoAmpMask);
	break;

    case ModuloRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_ModuloR,
				(pFromFpga->data & ModuloMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				ModuloRString,
				(unsigned ) pFromFpga->data & ModuloMask);
	break;

    case PhaseStepHRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_PhaseStepHR,
				(pFromFpga->data & PhaseStepHMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				PhaseStepHRString,
				(unsigned ) pFromFpga->data & PhaseStepHMask);
	break;

    case PhaseStepLRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_PhaseStepLR,
				(pFromFpga->data & PhaseStepLMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				PhaseStepLRString,
				(unsigned ) pFromFpga->data & PhaseStepLMask);
	break;

    case PrcDspCavSelRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_PrcDspCavSelR,
				(pFromFpga->data & PrcDspCavSelMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				PrcDspCavSelRString,
				(unsigned ) pFromFpga->data & PrcDspCavSelMask);
	break;

    case PrcDspPrlCfgRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_PrcDspPrlCfgR,
				(pFromFpga->data & PrcDspPrlCfgMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				PrcDspPrlCfgRString,
				(unsigned ) pFromFpga->data & PrcDspPrlCfgMask);
	break;

    case PrcDspPrlGainRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_PrcDspPrlGainR,
				(pFromFpga->data & PrcDspPrlGainMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				PrcDspPrlGainRString,
				(unsigned ) pFromFpga->data & PrcDspPrlGainMask);
	break;

    case Beam0ModuloRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Beam0ModuloR,
				(pFromFpga->data & Beam0ModuloMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Beam0ModuloRString,
				(unsigned ) pFromFpga->data & Beam0ModuloMask);
	break;

    case Beam0PhaseInitRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Beam0PhaseInitR,
				(pFromFpga->data & Beam0PhaseInitMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Beam0PhaseInitRString,
				(unsigned ) pFromFpga->data & Beam0PhaseInitMask);
	break;

    case Beam0PhaseStepRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Beam0PhaseStepR,
				(pFromFpga->data & Beam0PhaseStepMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Beam0PhaseStepRString,
				(unsigned ) pFromFpga->data & Beam0PhaseStepMask);
	break;

    case Beam1ModuloRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Beam1ModuloR,
				(pFromFpga->data & Beam1ModuloMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Beam1ModuloRString,
				(unsigned ) pFromFpga->data & Beam1ModuloMask);
	break;

    case Beam1PhaseInitRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Beam1PhaseInitR,
				(pFromFpga->data & Beam1PhaseInitMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Beam1PhaseInitRString,
				(unsigned ) pFromFpga->data & Beam1PhaseInitMask);
	break;

    case Beam1PhaseStepRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Beam1PhaseStepR,
				(pFromFpga->data & Beam1PhaseStepMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Beam1PhaseStepRString,
				(unsigned ) pFromFpga->data & Beam1PhaseStepMask);
	break;

    case Cav4MechPrngIvaRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Cav4MechPrngIvaR,
				(pFromFpga->data & Cav4MechPrngIvaMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cav4MechPrngIvaRString,
				(unsigned ) pFromFpga->data & Cav4MechPrngIvaMask);
	break;

    case Cav4MechPrngIvbRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Cav4MechPrngIvbR,
				(pFromFpga->data & Cav4MechPrngIvbMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cav4MechPrngIvbRString,
				(unsigned ) pFromFpga->data & Cav4MechPrngIvbMask);
	break;

    case Cav4MechPrngRandomRunRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Cav4MechPrngRandomRunR,
				(pFromFpga->data & Cav4MechPrngRandomRunMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cav4MechPrngRandomRunRString,
				(unsigned ) pFromFpga->data & Cav4MechPrngRandomRunMask);
	break;

    case Cavity0ACavOffsetRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Cavity0ACavOffsetR,
				(pFromFpga->data & Cavity0ACavOffsetMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0ACavOffsetRString,
				(unsigned ) pFromFpga->data & Cavity0ACavOffsetMask);
	break;

    case Cavity0AForOffsetRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Cavity0AForOffsetR,
				(pFromFpga->data & Cavity0AForOffsetMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0AForOffsetRString,
				(unsigned ) pFromFpga->data & Cavity0AForOffsetMask);
	break;

    case Cavity0ARflOffsetRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Cavity0ARflOffsetR,
				(pFromFpga->data & Cavity0ARflOffsetMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0ARflOffsetRString,
				(unsigned ) pFromFpga->data & Cavity0ARflOffsetMask);
	break;

    case Cavity0AmpLpBwRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Cavity0AmpLpBwR,
				(pFromFpga->data & Cavity0AmpLpBwMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0AmpLpBwRString,
				(unsigned ) pFromFpga->data & Cavity0AmpLpBwMask);
	break;

    case Cavity0Freq0CoarseFreqRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Cavity0Freq0CoarseFreqR,
				(pFromFpga->data & Cavity0Freq0CoarseFreqMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0Freq0CoarseFreqRString,
				(unsigned ) pFromFpga->data & Cavity0Freq0CoarseFreqMask);
	break;

    case Cavity0Freq1CoarseFreqRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Cavity0Freq1CoarseFreqR,
				(pFromFpga->data & Cavity0Freq1CoarseFreqMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0Freq1CoarseFreqRString,
				(unsigned ) pFromFpga->data & Cavity0Freq1CoarseFreqMask);
	break;

    case Cavity0Freq2CoarseFreqRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Cavity0Freq2CoarseFreqR,
				(pFromFpga->data & Cavity0Freq2CoarseFreqMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0Freq2CoarseFreqRString,
				(unsigned ) pFromFpga->data & Cavity0Freq2CoarseFreqMask);
	break;

    case Cavity0Mode0BeamCouplingRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Cavity0Mode0BeamCouplingR,
				(pFromFpga->data & Cavity0Mode0BeamCouplingMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0Mode0BeamCouplingRString,
				(unsigned ) pFromFpga->data & Cavity0Mode0BeamCouplingMask);
	break;

    case Cavity0Mode0BwRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Cavity0Mode0BwR,
				(pFromFpga->data & Cavity0Mode0BwMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0Mode0BwRString,
				(unsigned ) pFromFpga->data & Cavity0Mode0BwMask);
	break;

    case Cavity0Mode0DriveCouplingRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Cavity0Mode0DriveCouplingR,
				(pFromFpga->data & Cavity0Mode0DriveCouplingMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0Mode0DriveCouplingRString,
				(unsigned ) pFromFpga->data & Cavity0Mode0DriveCouplingMask);
	break;

    case Cavity0Mode1BeamCouplingRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Cavity0Mode1BeamCouplingR,
				(pFromFpga->data & Cavity0Mode1BeamCouplingMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0Mode1BeamCouplingRString,
				(unsigned ) pFromFpga->data & Cavity0Mode1BeamCouplingMask);
	break;

    case Cavity0Mode1BwRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Cavity0Mode1BwR,
				(pFromFpga->data & Cavity0Mode1BwMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0Mode1BwRString,
				(unsigned ) pFromFpga->data & Cavity0Mode1BwMask);
	break;

    case Cavity0Mode1DriveCouplingRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Cavity0Mode1DriveCouplingR,
				(pFromFpga->data & Cavity0Mode1DriveCouplingMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0Mode1DriveCouplingRString,
				(unsigned ) pFromFpga->data & Cavity0Mode1DriveCouplingMask);
	break;

    case Cavity0Mode2BeamCouplingRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Cavity0Mode2BeamCouplingR,
				(pFromFpga->data & Cavity0Mode2BeamCouplingMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0Mode2BeamCouplingRString,
				(unsigned ) pFromFpga->data & Cavity0Mode2BeamCouplingMask);
	break;

    case Cavity0Mode2BwRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Cavity0Mode2BwR,
				(pFromFpga->data & Cavity0Mode2BwMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0Mode2BwRString,
				(unsigned ) pFromFpga->data & Cavity0Mode2BwMask);
	break;

    case Cavity0Mode2DriveCouplingRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Cavity0Mode2DriveCouplingR,
				(pFromFpga->data & Cavity0Mode2DriveCouplingMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0Mode2DriveCouplingRString,
				(unsigned ) pFromFpga->data & Cavity0Mode2DriveCouplingMask);
	break;

    case Cavity0ModuloRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Cavity0ModuloR,
				(pFromFpga->data & Cavity0ModuloMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0ModuloRString,
				(unsigned ) pFromFpga->data & Cavity0ModuloMask);
	break;

    case Cavity0PhaseStepRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Cavity0PhaseStepR,
				(pFromFpga->data & Cavity0PhaseStepMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0PhaseStepRString,
				(unsigned ) pFromFpga->data & Cavity0PhaseStepMask);
	break;

    case Cavity0ComprSatCtlRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Cavity0ComprSatCtlR,
				(pFromFpga->data & Cavity0ComprSatCtlMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0ComprSatCtlRString,
				(unsigned ) pFromFpga->data & Cavity0ComprSatCtlMask);
	break;

    case Cavity0PrngIvaRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Cavity0PrngIvaR,
				(pFromFpga->data & Cavity0PrngIvaMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0PrngIvaRString,
				(unsigned ) pFromFpga->data & Cavity0PrngIvaMask);
	break;

    case Cavity0PrngIvbRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Cavity0PrngIvbR,
				(pFromFpga->data & Cavity0PrngIvbMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0PrngIvbRString,
				(unsigned ) pFromFpga->data & Cavity0PrngIvbMask);
	break;

    case Cavity0PrngRandomRunRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Cavity0PrngRandomRunR,
				(pFromFpga->data & Cavity0PrngRandomRunMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0PrngRandomRunRString,
				(unsigned ) pFromFpga->data & Cavity0PrngRandomRunMask);
	break;

    case Cavity1ACavOffsetRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Cavity1ACavOffsetR,
				(pFromFpga->data & Cavity1ACavOffsetMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1ACavOffsetRString,
				(unsigned ) pFromFpga->data & Cavity1ACavOffsetMask);
	break;

    case Cavity1AForOffsetRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Cavity1AForOffsetR,
				(pFromFpga->data & Cavity1AForOffsetMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1AForOffsetRString,
				(unsigned ) pFromFpga->data & Cavity1AForOffsetMask);
	break;

    case Cavity1ARflOffsetRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Cavity1ARflOffsetR,
				(pFromFpga->data & Cavity1ARflOffsetMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1ARflOffsetRString,
				(unsigned ) pFromFpga->data & Cavity1ARflOffsetMask);
	break;

    case Cavity1AmpLpBwRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Cavity1AmpLpBwR,
				(pFromFpga->data & Cavity1AmpLpBwMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1AmpLpBwRString,
				(unsigned ) pFromFpga->data & Cavity1AmpLpBwMask);
	break;

    case Cavity1Freq0CoarseFreqRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Cavity1Freq0CoarseFreqR,
				(pFromFpga->data & Cavity1Freq0CoarseFreqMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1Freq0CoarseFreqRString,
				(unsigned ) pFromFpga->data & Cavity1Freq0CoarseFreqMask);
	break;

    case Cavity1Freq1CoarseFreqRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Cavity1Freq1CoarseFreqR,
				(pFromFpga->data & Cavity1Freq1CoarseFreqMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1Freq1CoarseFreqRString,
				(unsigned ) pFromFpga->data & Cavity1Freq1CoarseFreqMask);
	break;

    case Cavity1Freq2CoarseFreqRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Cavity1Freq2CoarseFreqR,
				(pFromFpga->data & Cavity1Freq2CoarseFreqMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1Freq2CoarseFreqRString,
				(unsigned ) pFromFpga->data & Cavity1Freq2CoarseFreqMask);
	break;

    case Cavity1Mode0BeamCouplingRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Cavity1Mode0BeamCouplingR,
				(pFromFpga->data & Cavity1Mode0BeamCouplingMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1Mode0BeamCouplingRString,
				(unsigned ) pFromFpga->data & Cavity1Mode0BeamCouplingMask);
	break;

    case Cavity1Mode0BwRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Cavity1Mode0BwR,
				(pFromFpga->data & Cavity1Mode0BwMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1Mode0BwRString,
				(unsigned ) pFromFpga->data & Cavity1Mode0BwMask);
	break;

    case Cavity1Mode0DriveCouplingRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Cavity1Mode0DriveCouplingR,
				(pFromFpga->data & Cavity1Mode0DriveCouplingMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1Mode0DriveCouplingRString,
				(unsigned ) pFromFpga->data & Cavity1Mode0DriveCouplingMask);
	break;

    case Cavity1Mode1BeamCouplingRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Cavity1Mode1BeamCouplingR,
				(pFromFpga->data & Cavity1Mode1BeamCouplingMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1Mode1BeamCouplingRString,
				(unsigned ) pFromFpga->data & Cavity1Mode1BeamCouplingMask);
	break;

    case Cavity1Mode1BwRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Cavity1Mode1BwR,
				(pFromFpga->data & Cavity1Mode1BwMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1Mode1BwRString,
				(unsigned ) pFromFpga->data & Cavity1Mode1BwMask);
	break;

    case Cavity1Mode1DriveCouplingRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Cavity1Mode1DriveCouplingR,
				(pFromFpga->data & Cavity1Mode1DriveCouplingMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1Mode1DriveCouplingRString,
				(unsigned ) pFromFpga->data & Cavity1Mode1DriveCouplingMask);
	break;

    case Cavity1Mode2BeamCouplingRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Cavity1Mode2BeamCouplingR,
				(pFromFpga->data & Cavity1Mode2BeamCouplingMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1Mode2BeamCouplingRString,
				(unsigned ) pFromFpga->data & Cavity1Mode2BeamCouplingMask);
	break;

    case Cavity1Mode2BwRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Cavity1Mode2BwR,
				(pFromFpga->data & Cavity1Mode2BwMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1Mode2BwRString,
				(unsigned ) pFromFpga->data & Cavity1Mode2BwMask);
	break;

    case Cavity1Mode2DriveCouplingRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Cavity1Mode2DriveCouplingR,
				(pFromFpga->data & Cavity1Mode2DriveCouplingMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1Mode2DriveCouplingRString,
				(unsigned ) pFromFpga->data & Cavity1Mode2DriveCouplingMask);
	break;

    case Cavity1ModuloRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Cavity1ModuloR,
				(pFromFpga->data & Cavity1ModuloMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1ModuloRString,
				(unsigned ) pFromFpga->data & Cavity1ModuloMask);
	break;

    case Cavity1PhaseStepRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Cavity1PhaseStepR,
				(pFromFpga->data & Cavity1PhaseStepMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1PhaseStepRString,
				(unsigned ) pFromFpga->data & Cavity1PhaseStepMask);
	break;

    case Cavity1ComprSatCtlRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Cavity1ComprSatCtlR,
				(pFromFpga->data & Cavity1ComprSatCtlMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1ComprSatCtlRString,
				(unsigned ) pFromFpga->data & Cavity1ComprSatCtlMask);
	break;

    case Cavity1PrngIvaRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Cavity1PrngIvaR,
				(pFromFpga->data & Cavity1PrngIvaMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1PrngIvaRString,
				(unsigned ) pFromFpga->data & Cavity1PrngIvaMask);
	break;

    case Cavity1PrngIvbRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Cavity1PrngIvbR,
				(pFromFpga->data & Cavity1PrngIvbMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1PrngIvbRString,
				(unsigned ) pFromFpga->data & Cavity1PrngIvbMask);
	break;

    case Cavity1PrngRandomRunRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Cavity1PrngRandomRunR,
				(pFromFpga->data & Cavity1PrngRandomRunMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1PrngRandomRunRString,
				(unsigned ) pFromFpga->data & Cavity1PrngRandomRunMask);
	break;

    case DacIqPhaseRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_DacIqPhaseR,
				(pFromFpga->data & DacIqPhaseMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DacIqPhaseRString,
				(unsigned ) pFromFpga->data & DacIqPhaseMask);
	break;

    case Shell0DspChanKeepRAdr|flagReadMask:

		status = (asynStatus) setUIntDigitalParam(p_Shell0DspChanKeepR,
				(pFromFpga->data & Shell0DspChanKeepMask) , Shell0DspChanKeepMask);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell0DspChanKeepRString,
				(unsigned ) pFromFpga->data & Shell0DspChanKeepMask);
	break;

    case Shell0DspFdbkCoreCoarseScaleRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Shell0DspFdbkCoreCoarseScaleR,
				(pFromFpga->data & Shell0DspFdbkCoreCoarseScaleMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell0DspFdbkCoreCoarseScaleRString,
				(unsigned ) pFromFpga->data & Shell0DspFdbkCoreCoarseScaleMask);
	break;

    case Shell0DspFdbkCoreMpProcPhOffsetRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Shell0DspFdbkCoreMpProcPhOffsetR,
				(pFromFpga->data & Shell0DspFdbkCoreMpProcPhOffsetMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell0DspFdbkCoreMpProcPhOffsetRString,
				(unsigned ) pFromFpga->data & Shell0DspFdbkCoreMpProcPhOffsetMask);
	break;

    case Shell0DspFdbkCoreMpProcSelEnRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Shell0DspFdbkCoreMpProcSelEnR,
				(pFromFpga->data & Shell0DspFdbkCoreMpProcSelEnMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell0DspFdbkCoreMpProcSelEnRString,
				(unsigned ) pFromFpga->data & Shell0DspFdbkCoreMpProcSelEnMask);
	break;

    case Shell0DspFdbkCoreMpProcSelThreshRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Shell0DspFdbkCoreMpProcSelThreshR,
				(pFromFpga->data & Shell0DspFdbkCoreMpProcSelThreshMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell0DspFdbkCoreMpProcSelThreshRString,
				(unsigned ) pFromFpga->data & Shell0DspFdbkCoreMpProcSelThreshMask);
	break;

    case Shell0DspModuloRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Shell0DspModuloR,
				(pFromFpga->data & Shell0DspModuloMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell0DspModuloRString,
				(unsigned ) pFromFpga->data & Shell0DspModuloMask);
	break;

    case Shell0DspPhaseStepRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Shell0DspPhaseStepR,
				(pFromFpga->data & Shell0DspPhaseStepMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell0DspPhaseStepRString,
				(unsigned ) pFromFpga->data & Shell0DspPhaseStepMask);
	break;

    case Shell0DspPiezoPiezoDcRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Shell0DspPiezoPiezoDcR,
				(pFromFpga->data & Shell0DspPiezoPiezoDcMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell0DspPiezoPiezoDcRString,
				(unsigned ) pFromFpga->data & Shell0DspPiezoPiezoDcMask);
	break;

    case Shell0DspTagRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Shell0DspTagR,
				(pFromFpga->data & Shell0DspTagMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell0DspTagRString,
				(unsigned ) pFromFpga->data & Shell0DspTagMask);
	break;

    case Shell0DspUseFiberIqRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Shell0DspUseFiberIqR,
				(pFromFpga->data & Shell0DspUseFiberIqMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell0DspUseFiberIqRString,
				(unsigned ) pFromFpga->data & Shell0DspUseFiberIqMask);
	break;

    case Shell0DspWaveSampPerRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Shell0DspWaveSampPerR,
				(pFromFpga->data & Shell0DspWaveSampPerMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell0DspWaveSampPerRString,
				(unsigned ) pFromFpga->data & Shell0DspWaveSampPerMask);
	break;

    case Shell0DspWaveShiftRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Shell0DspWaveShiftR,
				(pFromFpga->data & Shell0DspWaveShiftMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell0DspWaveShiftRString,
				(unsigned ) pFromFpga->data & Shell0DspWaveShiftMask);
	break;

    case Shell1DspChanKeepRAdr|flagReadMask:

		status = (asynStatus) setUIntDigitalParam(p_Shell1DspChanKeepR,
				(pFromFpga->data & Shell1DspChanKeepMask) , Shell1DspChanKeepMask);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell1DspChanKeepRString,
				(unsigned ) pFromFpga->data & Shell1DspChanKeepMask);
	break;

    case Shell1DspFdbkCoreCoarseScaleRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Shell1DspFdbkCoreCoarseScaleR,
				(pFromFpga->data & Shell1DspFdbkCoreCoarseScaleMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell1DspFdbkCoreCoarseScaleRString,
				(unsigned ) pFromFpga->data & Shell1DspFdbkCoreCoarseScaleMask);
	break;

    case Shell1DspFdbkCoreMpProcPhOffsetRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Shell1DspFdbkCoreMpProcPhOffsetR,
				(pFromFpga->data & Shell1DspFdbkCoreMpProcPhOffsetMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell1DspFdbkCoreMpProcPhOffsetRString,
				(unsigned ) pFromFpga->data & Shell1DspFdbkCoreMpProcPhOffsetMask);
	break;

    case Shell1DspFdbkCoreMpProcSelEnRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Shell1DspFdbkCoreMpProcSelEnR,
				(pFromFpga->data & Shell1DspFdbkCoreMpProcSelEnMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell1DspFdbkCoreMpProcSelEnRString,
				(unsigned ) pFromFpga->data & Shell1DspFdbkCoreMpProcSelEnMask);
	break;

    case Shell1DspFdbkCoreMpProcSelThreshRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Shell1DspFdbkCoreMpProcSelThreshR,
				(pFromFpga->data & Shell1DspFdbkCoreMpProcSelThreshMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell1DspFdbkCoreMpProcSelThreshRString,
				(unsigned ) pFromFpga->data & Shell1DspFdbkCoreMpProcSelThreshMask);
	break;

    case Shell1DspModuloRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Shell1DspModuloR,
				(pFromFpga->data & Shell1DspModuloMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell1DspModuloRString,
				(unsigned ) pFromFpga->data & Shell1DspModuloMask);
	break;

    case Shell1DspPhaseStepRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Shell1DspPhaseStepR,
				(pFromFpga->data & Shell1DspPhaseStepMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell1DspPhaseStepRString,
				(unsigned ) pFromFpga->data & Shell1DspPhaseStepMask);
	break;

    case Shell1DspPiezoPiezoDcRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Shell1DspPiezoPiezoDcR,
				(pFromFpga->data & Shell1DspPiezoPiezoDcMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell1DspPiezoPiezoDcRString,
				(unsigned ) pFromFpga->data & Shell1DspPiezoPiezoDcMask);
	break;

    case Shell1DspTagRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Shell1DspTagR,
				(pFromFpga->data & Shell1DspTagMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell1DspTagRString,
				(unsigned ) pFromFpga->data & Shell1DspTagMask);
	break;

    case Shell1DspUseFiberIqRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Shell1DspUseFiberIqR,
				(pFromFpga->data & Shell1DspUseFiberIqMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell1DspUseFiberIqRString,
				(unsigned ) pFromFpga->data & Shell1DspUseFiberIqMask);
	break;

    case Shell1DspWaveSampPerRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Shell1DspWaveSampPerR,
				(pFromFpga->data & Shell1DspWaveSampPerMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell1DspWaveSampPerRString,
				(unsigned ) pFromFpga->data & Shell1DspWaveSampPerMask);
	break;

    case Shell1DspWaveShiftRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Shell1DspWaveShiftR,
				(pFromFpga->data & Shell1DspWaveShiftMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell1DspWaveShiftRString,
				(unsigned ) pFromFpga->data & Shell1DspWaveShiftMask);
	break;

    case RewindRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_RewindR,
				(pFromFpga->data & RewindMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				RewindRString,
				(unsigned ) pFromFpga->data & RewindMask);
	break;

    case SsaStimAmpstepRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_SsaStimAmpstepR,
				(pFromFpga->data & SsaStimAmpstepMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				SsaStimAmpstepRString,
				(unsigned ) pFromFpga->data & SsaStimAmpstepMask);
	break;

    case SsaStimEnRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_SsaStimEnR,
				(pFromFpga->data & SsaStimEnMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				SsaStimEnRString,
				(unsigned ) pFromFpga->data & SsaStimEnMask);
	break;

    case SsaStimGPeriodRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_SsaStimGPeriodR,
				(pFromFpga->data & SsaStimGPeriodMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				SsaStimGPeriodRString,
				(unsigned ) pFromFpga->data & SsaStimGPeriodMask);
	break;

    case SsaStimPertstepRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_SsaStimPertstepR,
				(pFromFpga->data & SsaStimPertstepMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				SsaStimPertstepRString,
				(unsigned ) pFromFpga->data & SsaStimPertstepMask);
	break;

    case TraceKeepRAdr|flagReadMask:

		status = (asynStatus) setUIntDigitalParam(p_TraceKeepR,
				(pFromFpga->data & TraceKeepMask) , TraceKeepMask);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				TraceKeepRString,
				(unsigned ) pFromFpga->data & TraceKeepMask);
	break;

    case TraceResetWeRAdr|flagReadMask:

		status = (asynStatus) setUIntDigitalParam(p_TraceResetWeR,
				(pFromFpga->data & TraceResetWeMask) , TraceResetWeMask);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				TraceResetWeRString,
				(unsigned ) pFromFpga->data & TraceResetWeMask);
	break;

    case TrigInternalRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_TrigInternalR,
				(pFromFpga->data & TrigInternalMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				TrigInternalRString,
				(unsigned ) pFromFpga->data & TrigInternalMask);
	break;

    case TrigModeRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_TrigModeR,
				(pFromFpga->data & TrigModeMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				TrigModeRString,
				(unsigned ) pFromFpga->data & TrigModeMask);
	break;

    case Wave0SrcRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Wave0SrcR,
				(pFromFpga->data & Wave0SrcMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Wave0SrcRString,
				(unsigned ) pFromFpga->data & Wave0SrcMask);
	break;

    case Wave1SrcRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Wave1SrcR,
				(pFromFpga->data & Wave1SrcMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Wave1SrcRString,
				(unsigned ) pFromFpga->data & Wave1SrcMask);
	break;

    case DomainJumpRealignRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_DomainJumpRealignR,
				(pFromFpga->data & DomainJumpRealignMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DomainJumpRealignRString,
				(unsigned ) pFromFpga->data & DomainJumpRealignMask);
	break;

    case IccCfgRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_IccCfgR,
				(pFromFpga->data & IccCfgMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				IccCfgRString,
				(unsigned ) pFromFpga->data & IccCfgMask);
	break;

    case QsfpI2CRegRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_QsfpI2CRegR,
				(pFromFpga->data & QsfpI2CRegMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				QsfpI2CRegRString,
				(unsigned ) pFromFpga->data & QsfpI2CRegMask);
	break;

    case SfpAddressSetRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_SfpAddressSetR,
				(pFromFpga->data & SfpAddressSetMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				SfpAddressSetRString,
				(unsigned ) pFromFpga->data & SfpAddressSetMask);
	break;

    case TagNowRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_TagNowR,
				(pFromFpga->data & TagNowMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				TagNowRString,
				(unsigned ) pFromFpga->data & TagNowMask);
		break;

	default:
		// Arrays larger than 16 elements should be handled in a subclass, generally more complicated
		if ((pFromFpga->addr >= (IdelayBaseRAdr|flagReadMask)) &&
				(pFromFpga->addr < ((IdelayBaseRAdr|flagReadMask) + 16)))
		{
			chan = (pFromFpga->addr - (IdelayBaseRAdr|flagReadMask));
			status = (asynStatus) setIntegerParam(chan,
				p_IdelayBaseR,
				(pFromFpga->data & IdelayBaseMask));
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
				IdelayBaseRString,chan,
				(unsigned ) pFromFpga->data & IdelayBaseMask);
			callParamCallbacks(chan, chan);
		}
		else
		if ((pFromFpga->addr >= (Shell0DspPiezoSfConstsRAdr|flagReadMask)) &&
				(pFromFpga->addr < ((Shell0DspPiezoSfConstsRAdr|flagReadMask) + 8)))
		{
			chan = (pFromFpga->addr - (Shell0DspPiezoSfConstsRAdr|flagReadMask));
			status = (asynStatus) setIntegerParam(chan,
				p_Shell0DspPiezoSfConstsR,
				(pFromFpga->data & Shell0DspPiezoSfConstsMask));
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell0DspPiezoSfConstsRString,chan,
				(unsigned ) pFromFpga->data & Shell0DspPiezoSfConstsMask);
			callParamCallbacks(chan, chan);
		}
		else
		if ((pFromFpga->addr >= (Shell1DspPiezoSfConstsRAdr|flagReadMask)) &&
				(pFromFpga->addr < ((Shell1DspPiezoSfConstsRAdr|flagReadMask) + 8)))
		{
			chan = (pFromFpga->addr - (Shell1DspPiezoSfConstsRAdr|flagReadMask));
			status = (asynStatus) setIntegerParam(chan,
				p_Shell1DspPiezoSfConstsR,
				(pFromFpga->data & Shell1DspPiezoSfConstsMask));
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell1DspPiezoSfConstsRString,chan,
				(unsigned ) pFromFpga->data & Shell1DspPiezoSfConstsMask);
			callParamCallbacks(chan, chan);
		}
		else
		if ((pFromFpga->addr >= (Shell0DspFdbkCoreMpProcCoeffRAdr|flagReadMask)) &&
				(pFromFpga->addr < ((Shell0DspFdbkCoreMpProcCoeffRAdr|flagReadMask) + 4)))
		{
			chan = (pFromFpga->addr - (Shell0DspFdbkCoreMpProcCoeffRAdr|flagReadMask));
			status = (asynStatus) setIntegerParam(chan,
				p_Shell0DspFdbkCoreMpProcCoeffR,
				(pFromFpga->data & Shell0DspFdbkCoreMpProcCoeffMask));
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell0DspFdbkCoreMpProcCoeffRString,chan,
				(unsigned ) pFromFpga->data & Shell0DspFdbkCoreMpProcCoeffMask);
			callParamCallbacks(chan, chan);
		}
		else
		if ((pFromFpga->addr >= (Shell0DspFdbkCoreMpProcLimRAdr|flagReadMask)) &&
				(pFromFpga->addr < ((Shell0DspFdbkCoreMpProcLimRAdr|flagReadMask) + 4)))
		{
			chan = (pFromFpga->addr - (Shell0DspFdbkCoreMpProcLimRAdr|flagReadMask));
			status = (asynStatus) setIntegerParam(chan,
				p_Shell0DspFdbkCoreMpProcLimR,
				(pFromFpga->data & Shell0DspFdbkCoreMpProcLimMask));
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell0DspFdbkCoreMpProcLimRString,chan,
				(unsigned ) pFromFpga->data & Shell0DspFdbkCoreMpProcLimMask);
			callParamCallbacks(chan, chan);
		}
		else
		if ((pFromFpga->addr >= (Shell0DspFdbkCoreMpProcSetmpRAdr|flagReadMask)) &&
				(pFromFpga->addr < ((Shell0DspFdbkCoreMpProcSetmpRAdr|flagReadMask) + 4)))
		{
			chan = (pFromFpga->addr - (Shell0DspFdbkCoreMpProcSetmpRAdr|flagReadMask));
			status = (asynStatus) setIntegerParam(chan,
				p_Shell0DspFdbkCoreMpProcSetmpR,
				(pFromFpga->data & Shell0DspFdbkCoreMpProcSetmpMask));
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell0DspFdbkCoreMpProcSetmpRString,chan,
				(unsigned ) pFromFpga->data & Shell0DspFdbkCoreMpProcSetmpMask);
			callParamCallbacks(chan, chan);
		}
		else
		if ((pFromFpga->addr >= (Shell1DspFdbkCoreMpProcCoeffRAdr|flagReadMask)) &&
				(pFromFpga->addr < ((Shell1DspFdbkCoreMpProcCoeffRAdr|flagReadMask) + 4)))
		{
			chan = (pFromFpga->addr - (Shell1DspFdbkCoreMpProcCoeffRAdr|flagReadMask));
			status = (asynStatus) setIntegerParam(chan,
				p_Shell1DspFdbkCoreMpProcCoeffR,
				(pFromFpga->data & Shell1DspFdbkCoreMpProcCoeffMask));
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell1DspFdbkCoreMpProcCoeffRString,chan,
				(unsigned ) pFromFpga->data & Shell1DspFdbkCoreMpProcCoeffMask);
			callParamCallbacks(chan, chan);
		}
		else
		if ((pFromFpga->addr >= (Shell1DspFdbkCoreMpProcLimRAdr|flagReadMask)) &&
				(pFromFpga->addr < ((Shell1DspFdbkCoreMpProcLimRAdr|flagReadMask) + 4)))
		{
			chan = (pFromFpga->addr - (Shell1DspFdbkCoreMpProcLimRAdr|flagReadMask));
			status = (asynStatus) setIntegerParam(chan,
				p_Shell1DspFdbkCoreMpProcLimR,
				(pFromFpga->data & Shell1DspFdbkCoreMpProcLimMask));
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell1DspFdbkCoreMpProcLimRString,chan,
				(unsigned ) pFromFpga->data & Shell1DspFdbkCoreMpProcLimMask);
			callParamCallbacks(chan, chan);
		}
		else
		if ((pFromFpga->addr >= (Shell1DspFdbkCoreMpProcSetmpRAdr|flagReadMask)) &&
				(pFromFpga->addr < ((Shell1DspFdbkCoreMpProcSetmpRAdr|flagReadMask) + 4)))
		{
			chan = (pFromFpga->addr - (Shell1DspFdbkCoreMpProcSetmpRAdr|flagReadMask));
			status = (asynStatus) setIntegerParam(chan,
				p_Shell1DspFdbkCoreMpProcSetmpR,
				(pFromFpga->data & Shell1DspFdbkCoreMpProcSetmpMask));
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell1DspFdbkCoreMpProcSetmpRString,chan,
				(unsigned ) pFromFpga->data & Shell1DspFdbkCoreMpProcSetmpMask);
			callParamCallbacks(chan, chan);
		}
		else
		if ((pFromFpga->addr >= (Cavity0DriveCoupleOutCouplingRAdr|flagReadMask)) &&
				(pFromFpga->addr < ((Cavity0DriveCoupleOutCouplingRAdr|flagReadMask) + 2)))
		{
			chan = (pFromFpga->addr - (Cavity0DriveCoupleOutCouplingRAdr|flagReadMask));
			status = (asynStatus) setIntegerParam(chan,
				p_Cavity0DriveCoupleOutCouplingR,
				(pFromFpga->data & Cavity0DriveCoupleOutCouplingMask));
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0DriveCoupleOutCouplingRString,chan,
				(unsigned ) pFromFpga->data & Cavity0DriveCoupleOutCouplingMask);
			callParamCallbacks(chan, chan);
		}
		else
		if ((pFromFpga->addr >= (Cavity0DriveCoupleOutPhaseOffsetRAdr|flagReadMask)) &&
				(pFromFpga->addr < ((Cavity0DriveCoupleOutPhaseOffsetRAdr|flagReadMask) + 2)))
		{
			chan = (pFromFpga->addr - (Cavity0DriveCoupleOutPhaseOffsetRAdr|flagReadMask));
			status = (asynStatus) setIntegerParam(chan,
				p_Cavity0DriveCoupleOutPhaseOffsetR,
				(pFromFpga->data & Cavity0DriveCoupleOutPhaseOffsetMask));
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0DriveCoupleOutPhaseOffsetRString,chan,
				(unsigned ) pFromFpga->data & Cavity0DriveCoupleOutPhaseOffsetMask);
			callParamCallbacks(chan, chan);
		}
		else
		if ((pFromFpga->addr >= (Cavity0Mode0CoupleOutCouplingRAdr|flagReadMask)) &&
				(pFromFpga->addr < ((Cavity0Mode0CoupleOutCouplingRAdr|flagReadMask) + 2)))
		{
			chan = (pFromFpga->addr - (Cavity0Mode0CoupleOutCouplingRAdr|flagReadMask));
			status = (asynStatus) setIntegerParam(chan,
				p_Cavity0Mode0CoupleOutCouplingR,
				(pFromFpga->data & Cavity0Mode0CoupleOutCouplingMask));
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0Mode0CoupleOutCouplingRString,chan,
				(unsigned ) pFromFpga->data & Cavity0Mode0CoupleOutCouplingMask);
			callParamCallbacks(chan, chan);
		}
		else
		if ((pFromFpga->addr >= (Cavity0Mode0CoupleOutPhaseOffsetRAdr|flagReadMask)) &&
				(pFromFpga->addr < ((Cavity0Mode0CoupleOutPhaseOffsetRAdr|flagReadMask) + 2)))
		{
			chan = (pFromFpga->addr - (Cavity0Mode0CoupleOutPhaseOffsetRAdr|flagReadMask));
			status = (asynStatus) setIntegerParam(chan,
				p_Cavity0Mode0CoupleOutPhaseOffsetR,
				(pFromFpga->data & Cavity0Mode0CoupleOutPhaseOffsetMask));
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0Mode0CoupleOutPhaseOffsetRString,chan,
				(unsigned ) pFromFpga->data & Cavity0Mode0CoupleOutPhaseOffsetMask);
			callParamCallbacks(chan, chan);
		}
		else
		if ((pFromFpga->addr >= (Cavity0Mode1CoupleOutCouplingRAdr|flagReadMask)) &&
				(pFromFpga->addr < ((Cavity0Mode1CoupleOutCouplingRAdr|flagReadMask) + 2)))
		{
			chan = (pFromFpga->addr - (Cavity0Mode1CoupleOutCouplingRAdr|flagReadMask));
			status = (asynStatus) setIntegerParam(chan,
				p_Cavity0Mode1CoupleOutCouplingR,
				(pFromFpga->data & Cavity0Mode1CoupleOutCouplingMask));
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0Mode1CoupleOutCouplingRString,chan,
				(unsigned ) pFromFpga->data & Cavity0Mode1CoupleOutCouplingMask);
			callParamCallbacks(chan, chan);
		}
		else
		if ((pFromFpga->addr >= (Cavity0Mode1CoupleOutPhaseOffsetRAdr|flagReadMask)) &&
				(pFromFpga->addr < ((Cavity0Mode1CoupleOutPhaseOffsetRAdr|flagReadMask) + 2)))
		{
			chan = (pFromFpga->addr - (Cavity0Mode1CoupleOutPhaseOffsetRAdr|flagReadMask));
			status = (asynStatus) setIntegerParam(chan,
				p_Cavity0Mode1CoupleOutPhaseOffsetR,
				(pFromFpga->data & Cavity0Mode1CoupleOutPhaseOffsetMask));
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0Mode1CoupleOutPhaseOffsetRString,chan,
				(unsigned ) pFromFpga->data & Cavity0Mode1CoupleOutPhaseOffsetMask);
			callParamCallbacks(chan, chan);
		}
		else
		if ((pFromFpga->addr >= (Cavity0Mode2CoupleOutCouplingRAdr|flagReadMask)) &&
				(pFromFpga->addr < ((Cavity0Mode2CoupleOutCouplingRAdr|flagReadMask) + 2)))
		{
			chan = (pFromFpga->addr - (Cavity0Mode2CoupleOutCouplingRAdr|flagReadMask));
			status = (asynStatus) setIntegerParam(chan,
				p_Cavity0Mode2CoupleOutCouplingR,
				(pFromFpga->data & Cavity0Mode2CoupleOutCouplingMask));
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0Mode2CoupleOutCouplingRString,chan,
				(unsigned ) pFromFpga->data & Cavity0Mode2CoupleOutCouplingMask);
			callParamCallbacks(chan, chan);
		}
		else
		if ((pFromFpga->addr >= (Cavity0Mode2CoupleOutPhaseOffsetRAdr|flagReadMask)) &&
				(pFromFpga->addr < ((Cavity0Mode2CoupleOutPhaseOffsetRAdr|flagReadMask) + 2)))
		{
			chan = (pFromFpga->addr - (Cavity0Mode2CoupleOutPhaseOffsetRAdr|flagReadMask));
			status = (asynStatus) setIntegerParam(chan,
				p_Cavity0Mode2CoupleOutPhaseOffsetR,
				(pFromFpga->data & Cavity0Mode2CoupleOutPhaseOffsetMask));
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0Mode2CoupleOutPhaseOffsetRString,chan,
				(unsigned ) pFromFpga->data & Cavity0Mode2CoupleOutPhaseOffsetMask);
			callParamCallbacks(chan, chan);
		}
		else
		if ((pFromFpga->addr >= (Cavity1DriveCoupleOutCouplingRAdr|flagReadMask)) &&
				(pFromFpga->addr < ((Cavity1DriveCoupleOutCouplingRAdr|flagReadMask) + 2)))
		{
			chan = (pFromFpga->addr - (Cavity1DriveCoupleOutCouplingRAdr|flagReadMask));
			status = (asynStatus) setIntegerParam(chan,
				p_Cavity1DriveCoupleOutCouplingR,
				(pFromFpga->data & Cavity1DriveCoupleOutCouplingMask));
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1DriveCoupleOutCouplingRString,chan,
				(unsigned ) pFromFpga->data & Cavity1DriveCoupleOutCouplingMask);
			callParamCallbacks(chan, chan);
		}
		else
		if ((pFromFpga->addr >= (Cavity1DriveCoupleOutPhaseOffsetRAdr|flagReadMask)) &&
				(pFromFpga->addr < ((Cavity1DriveCoupleOutPhaseOffsetRAdr|flagReadMask) + 2)))
		{
			chan = (pFromFpga->addr - (Cavity1DriveCoupleOutPhaseOffsetRAdr|flagReadMask));
			status = (asynStatus) setIntegerParam(chan,
				p_Cavity1DriveCoupleOutPhaseOffsetR,
				(pFromFpga->data & Cavity1DriveCoupleOutPhaseOffsetMask));
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1DriveCoupleOutPhaseOffsetRString,chan,
				(unsigned ) pFromFpga->data & Cavity1DriveCoupleOutPhaseOffsetMask);
			callParamCallbacks(chan, chan);
		}
		else
		if ((pFromFpga->addr >= (Cavity1Mode0CoupleOutCouplingRAdr|flagReadMask)) &&
				(pFromFpga->addr < ((Cavity1Mode0CoupleOutCouplingRAdr|flagReadMask) + 2)))
		{
			chan = (pFromFpga->addr - (Cavity1Mode0CoupleOutCouplingRAdr|flagReadMask));
			status = (asynStatus) setIntegerParam(chan,
				p_Cavity1Mode0CoupleOutCouplingR,
				(pFromFpga->data & Cavity1Mode0CoupleOutCouplingMask));
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1Mode0CoupleOutCouplingRString,chan,
				(unsigned ) pFromFpga->data & Cavity1Mode0CoupleOutCouplingMask);
			callParamCallbacks(chan, chan);
		}
		else
		if ((pFromFpga->addr >= (Cavity1Mode0CoupleOutPhaseOffsetRAdr|flagReadMask)) &&
				(pFromFpga->addr < ((Cavity1Mode0CoupleOutPhaseOffsetRAdr|flagReadMask) + 2)))
		{
			chan = (pFromFpga->addr - (Cavity1Mode0CoupleOutPhaseOffsetRAdr|flagReadMask));
			status = (asynStatus) setIntegerParam(chan,
				p_Cavity1Mode0CoupleOutPhaseOffsetR,
				(pFromFpga->data & Cavity1Mode0CoupleOutPhaseOffsetMask));
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1Mode0CoupleOutPhaseOffsetRString,chan,
				(unsigned ) pFromFpga->data & Cavity1Mode0CoupleOutPhaseOffsetMask);
			callParamCallbacks(chan, chan);
		}
		else
		if ((pFromFpga->addr >= (Cavity1Mode1CoupleOutCouplingRAdr|flagReadMask)) &&
				(pFromFpga->addr < ((Cavity1Mode1CoupleOutCouplingRAdr|flagReadMask) + 2)))
		{
			chan = (pFromFpga->addr - (Cavity1Mode1CoupleOutCouplingRAdr|flagReadMask));
			status = (asynStatus) setIntegerParam(chan,
				p_Cavity1Mode1CoupleOutCouplingR,
				(pFromFpga->data & Cavity1Mode1CoupleOutCouplingMask));
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1Mode1CoupleOutCouplingRString,chan,
				(unsigned ) pFromFpga->data & Cavity1Mode1CoupleOutCouplingMask);
			callParamCallbacks(chan, chan);
		}
		else
		if ((pFromFpga->addr >= (Cavity1Mode1CoupleOutPhaseOffsetRAdr|flagReadMask)) &&
				(pFromFpga->addr < ((Cavity1Mode1CoupleOutPhaseOffsetRAdr|flagReadMask) + 2)))
		{
			chan = (pFromFpga->addr - (Cavity1Mode1CoupleOutPhaseOffsetRAdr|flagReadMask));
			status = (asynStatus) setIntegerParam(chan,
				p_Cavity1Mode1CoupleOutPhaseOffsetR,
				(pFromFpga->data & Cavity1Mode1CoupleOutPhaseOffsetMask));
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1Mode1CoupleOutPhaseOffsetRString,chan,
				(unsigned ) pFromFpga->data & Cavity1Mode1CoupleOutPhaseOffsetMask);
			callParamCallbacks(chan, chan);
		}
		else
		if ((pFromFpga->addr >= (Cavity1Mode2CoupleOutCouplingRAdr|flagReadMask)) &&
				(pFromFpga->addr < ((Cavity1Mode2CoupleOutCouplingRAdr|flagReadMask) + 2)))
		{
			chan = (pFromFpga->addr - (Cavity1Mode2CoupleOutCouplingRAdr|flagReadMask));
			status = (asynStatus) setIntegerParam(chan,
				p_Cavity1Mode2CoupleOutCouplingR,
				(pFromFpga->data & Cavity1Mode2CoupleOutCouplingMask));
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1Mode2CoupleOutCouplingRString,chan,
				(unsigned ) pFromFpga->data & Cavity1Mode2CoupleOutCouplingMask);
			callParamCallbacks(chan, chan);
		}
		else
		if ((pFromFpga->addr >= (Cavity1Mode2CoupleOutPhaseOffsetRAdr|flagReadMask)) &&
				(pFromFpga->addr < ((Cavity1Mode2CoupleOutPhaseOffsetRAdr|flagReadMask) + 2)))
		{
			chan = (pFromFpga->addr - (Cavity1Mode2CoupleOutPhaseOffsetRAdr|flagReadMask));
			status = (asynStatus) setIntegerParam(chan,
				p_Cavity1Mode2CoupleOutPhaseOffsetR,
				(pFromFpga->data & Cavity1Mode2CoupleOutPhaseOffsetMask));
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1Mode2CoupleOutPhaseOffsetRString,chan,
				(unsigned ) pFromFpga->data & Cavity1Mode2CoupleOutPhaseOffsetMask);
			callParamCallbacks(chan, chan);
		}
		else
		if ((pFromFpga->addr >= (Shell0DspLpNotchLp1AKxRAdr|flagReadMask)) &&
				(pFromFpga->addr < ((Shell0DspLpNotchLp1AKxRAdr|flagReadMask) + 2)))
		{
			chan = (pFromFpga->addr - (Shell0DspLpNotchLp1AKxRAdr|flagReadMask));
			status = (asynStatus) setIntegerParam(chan,
				p_Shell0DspLpNotchLp1AKxR,
				(pFromFpga->data & Shell0DspLpNotchLp1AKxMask));
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell0DspLpNotchLp1AKxRString,chan,
				(unsigned ) pFromFpga->data & Shell0DspLpNotchLp1AKxMask);
			callParamCallbacks(chan, chan);
		}
		else
		if ((pFromFpga->addr >= (Shell0DspLpNotchLp1AKyRAdr|flagReadMask)) &&
				(pFromFpga->addr < ((Shell0DspLpNotchLp1AKyRAdr|flagReadMask) + 2)))
		{
			chan = (pFromFpga->addr - (Shell0DspLpNotchLp1AKyRAdr|flagReadMask));
			status = (asynStatus) setIntegerParam(chan,
				p_Shell0DspLpNotchLp1AKyR,
				(pFromFpga->data & Shell0DspLpNotchLp1AKyMask));
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell0DspLpNotchLp1AKyRString,chan,
				(unsigned ) pFromFpga->data & Shell0DspLpNotchLp1AKyMask);
			callParamCallbacks(chan, chan);
		}
		else
		if ((pFromFpga->addr >= (Shell0DspLpNotchLp1BKxRAdr|flagReadMask)) &&
				(pFromFpga->addr < ((Shell0DspLpNotchLp1BKxRAdr|flagReadMask) + 2)))
		{
			chan = (pFromFpga->addr - (Shell0DspLpNotchLp1BKxRAdr|flagReadMask));
			status = (asynStatus) setIntegerParam(chan,
				p_Shell0DspLpNotchLp1BKxR,
				(pFromFpga->data & Shell0DspLpNotchLp1BKxMask));
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell0DspLpNotchLp1BKxRString,chan,
				(unsigned ) pFromFpga->data & Shell0DspLpNotchLp1BKxMask);
			callParamCallbacks(chan, chan);
		}
		else
		if ((pFromFpga->addr >= (Shell0DspLpNotchLp1BKyRAdr|flagReadMask)) &&
				(pFromFpga->addr < ((Shell0DspLpNotchLp1BKyRAdr|flagReadMask) + 2)))
		{
			chan = (pFromFpga->addr - (Shell0DspLpNotchLp1BKyRAdr|flagReadMask));
			status = (asynStatus) setIntegerParam(chan,
				p_Shell0DspLpNotchLp1BKyR,
				(pFromFpga->data & Shell0DspLpNotchLp1BKyMask));
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell0DspLpNotchLp1BKyRString,chan,
				(unsigned ) pFromFpga->data & Shell0DspLpNotchLp1BKyMask);
			callParamCallbacks(chan, chan);
		}
		else
		if ((pFromFpga->addr >= (Shell1DspLpNotchLp1AKxRAdr|flagReadMask)) &&
				(pFromFpga->addr < ((Shell1DspLpNotchLp1AKxRAdr|flagReadMask) + 2)))
		{
			chan = (pFromFpga->addr - (Shell1DspLpNotchLp1AKxRAdr|flagReadMask));
			status = (asynStatus) setIntegerParam(chan,
				p_Shell1DspLpNotchLp1AKxR,
				(pFromFpga->data & Shell1DspLpNotchLp1AKxMask));
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell1DspLpNotchLp1AKxRString,chan,
				(unsigned ) pFromFpga->data & Shell1DspLpNotchLp1AKxMask);
			callParamCallbacks(chan, chan);
		}
		else
		if ((pFromFpga->addr >= (Shell1DspLpNotchLp1AKyRAdr|flagReadMask)) &&
				(pFromFpga->addr < ((Shell1DspLpNotchLp1AKyRAdr|flagReadMask) + 2)))
		{
			chan = (pFromFpga->addr - (Shell1DspLpNotchLp1AKyRAdr|flagReadMask));
			status = (asynStatus) setIntegerParam(chan,
				p_Shell1DspLpNotchLp1AKyR,
				(pFromFpga->data & Shell1DspLpNotchLp1AKyMask));
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell1DspLpNotchLp1AKyRString,chan,
				(unsigned ) pFromFpga->data & Shell1DspLpNotchLp1AKyMask);
			callParamCallbacks(chan, chan);
		}
		else
		if ((pFromFpga->addr >= (Shell1DspLpNotchLp1BKxRAdr|flagReadMask)) &&
				(pFromFpga->addr < ((Shell1DspLpNotchLp1BKxRAdr|flagReadMask) + 2)))
		{
			chan = (pFromFpga->addr - (Shell1DspLpNotchLp1BKxRAdr|flagReadMask));
			status = (asynStatus) setIntegerParam(chan,
				p_Shell1DspLpNotchLp1BKxR,
				(pFromFpga->data & Shell1DspLpNotchLp1BKxMask));
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell1DspLpNotchLp1BKxRString,chan,
				(unsigned ) pFromFpga->data & Shell1DspLpNotchLp1BKxMask);
			callParamCallbacks(chan, chan);
		}
		else
		if ((pFromFpga->addr >= (Shell1DspLpNotchLp1BKyRAdr|flagReadMask)) &&
				(pFromFpga->addr < ((Shell1DspLpNotchLp1BKyRAdr|flagReadMask) + 2)))
		{
			chan = (pFromFpga->addr - (Shell1DspLpNotchLp1BKyRAdr|flagReadMask));
			status = (asynStatus) setIntegerParam(chan,
				p_Shell1DspLpNotchLp1BKyR,
				(pFromFpga->data & Shell1DspLpNotchLp1BKyMask));
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell1DspLpNotchLp1BKyRString,chan,
				(unsigned ) pFromFpga->data & Shell1DspLpNotchLp1BKyMask);
			callParamCallbacks(chan, chan);
		}
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value read from unmapped address 0x%X, value=0x%X\n", __PRETTY_FUNCTION__,
				pFromFpga->addr, (unsigned ) pFromFpga->data);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
			status = asynError;
		}

		break;
    }

    return status;
}


/**  Extract register address and data from the received message and set the appropriate
 * asyn parameter.
 * Some registers have a "new waveform data ready" flag. If they have this and it is set,
 * set weveIsReady to true.
 * Note: This function should not set waveIsReady to false. That is done by a loop in the
 * calling function.
* \param[in] pFromFpga Data returned from the FPGA for a single register
* \param[in] waveIsReady A flag that gets set to true if the appropriate bit was set by the FPGA
*/
asynStatus scllrfPRCDriver::processRegWriteResponse(const FpgaReg *pFromFpga)
{
	asynStatus status = asynSuccess;
	epicsInt32 valueSet; // Put the value sent to the FPGA here for comparison
	epicsUInt32 uValueSet;
	epicsInt32 errorCount;
//  variables that may be useful for checking array data
//	asynUser *pAsynArrayUser;
//	unsigned int i;

	/* Map address to parameter, set the parameter in the parameter library. */
	switch (pFromFpga->addr)
    {
    case AdcMmcmWAdr:
		status = (asynStatus) getIntegerParam(p_AdcMmcmW, &valueSet );
		if( (uint32_t)(valueSet & AdcMmcmMask) == (uint32_t)(pFromFpga->data & AdcMmcmMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				AdcMmcmWString, (unsigned ) pFromFpga->data & AdcMmcmMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				AdcMmcmWString, valueSet & AdcMmcmMask, (unsigned ) pFromFpga->data & AdcMmcmMask);
			status = asynError;
			setParamStatus(p_AdcMmcmW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case CcErrorClearWAdr:
		status = (asynStatus) getIntegerParam(p_CcErrorClearW, &valueSet );
		if( (uint32_t)(valueSet & CcErrorClearMask) == (uint32_t)(pFromFpga->data & CcErrorClearMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				CcErrorClearWString, (unsigned ) pFromFpga->data & CcErrorClearMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				CcErrorClearWString, valueSet & CcErrorClearMask, (unsigned ) pFromFpga->data & CcErrorClearMask);
			status = asynError;
			setParamStatus(p_CcErrorClearW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case CcLoc1WAdr:
		status = (asynStatus) getIntegerParam(p_CcLoc1W, &valueSet );
		if( (uint32_t)(valueSet & CcLoc1Mask) == (uint32_t)(pFromFpga->data & CcLoc1Mask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				CcLoc1WString, (unsigned ) pFromFpga->data & CcLoc1Mask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				CcLoc1WString, valueSet & CcLoc1Mask, (unsigned ) pFromFpga->data & CcLoc1Mask);
			status = asynError;
			setParamStatus(p_CcLoc1W, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Cct1Cavity0StatusAuxWAdr:
		status = (asynStatus) getIntegerParam(p_Cct1Cavity0StatusAuxW, &valueSet );
		if( (uint32_t)(valueSet & Cct1Cavity0StatusAuxMask) == (uint32_t)(pFromFpga->data & Cct1Cavity0StatusAuxMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cct1Cavity0StatusAuxWString, (unsigned ) pFromFpga->data & Cct1Cavity0StatusAuxMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Cct1Cavity0StatusAuxWString, valueSet & Cct1Cavity0StatusAuxMask, (unsigned ) pFromFpga->data & Cct1Cavity0StatusAuxMask);
			status = asynError;
			setParamStatus(p_Cct1Cavity0StatusAuxW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Cct1Cavity1StatusAuxWAdr:
		status = (asynStatus) getIntegerParam(p_Cct1Cavity1StatusAuxW, &valueSet );
		if( (uint32_t)(valueSet & Cct1Cavity1StatusAuxMask) == (uint32_t)(pFromFpga->data & Cct1Cavity1StatusAuxMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cct1Cavity1StatusAuxWString, (unsigned ) pFromFpga->data & Cct1Cavity1StatusAuxMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Cct1Cavity1StatusAuxWString, valueSet & Cct1Cavity1StatusAuxMask, (unsigned ) pFromFpga->data & Cct1Cavity1StatusAuxMask);
			status = asynError;
			setParamStatus(p_Cct1Cavity1StatusAuxW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case ConfigU15SpiDataAddrRWAdr:
		status = (asynStatus) getIntegerParam(p_ConfigU15SpiDataAddrRW, &valueSet );
		if( (uint32_t)(valueSet & ConfigU15SpiDataAddrRMask) == (uint32_t)(pFromFpga->data & ConfigU15SpiDataAddrRMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				ConfigU15SpiDataAddrRWString, (unsigned ) pFromFpga->data & ConfigU15SpiDataAddrRMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				ConfigU15SpiDataAddrRWString, valueSet & ConfigU15SpiDataAddrRMask, (unsigned ) pFromFpga->data & ConfigU15SpiDataAddrRMask);
			status = asynError;
			setParamStatus(p_ConfigU15SpiDataAddrRW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case ConfigU15SpiReadAndStartRWAdr:
		status = (asynStatus) getIntegerParam(p_ConfigU15SpiReadAndStartRW, &valueSet );
		if( (uint32_t)(valueSet & ConfigU15SpiReadAndStartRMask) == (uint32_t)(pFromFpga->data & ConfigU15SpiReadAndStartRMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				ConfigU15SpiReadAndStartRWString, (unsigned ) pFromFpga->data & ConfigU15SpiReadAndStartRMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				ConfigU15SpiReadAndStartRWString, valueSet & ConfigU15SpiReadAndStartRMask, (unsigned ) pFromFpga->data & ConfigU15SpiReadAndStartRMask);
			status = asynError;
			setParamStatus(p_ConfigU15SpiReadAndStartRW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case ConfigU18SpiDataAddrRWAdr:
		status = (asynStatus) getIntegerParam(p_ConfigU18SpiDataAddrRW, &valueSet );
		if( (uint32_t)(valueSet & ConfigU18SpiDataAddrRMask) == (uint32_t)(pFromFpga->data & ConfigU18SpiDataAddrRMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				ConfigU18SpiDataAddrRWString, (unsigned ) pFromFpga->data & ConfigU18SpiDataAddrRMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				ConfigU18SpiDataAddrRWString, valueSet & ConfigU18SpiDataAddrRMask, (unsigned ) pFromFpga->data & ConfigU18SpiDataAddrRMask);
			status = asynError;
			setParamStatus(p_ConfigU18SpiDataAddrRW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case ConfigU18SpiReadAndStartRWAdr:
		status = (asynStatus) getIntegerParam(p_ConfigU18SpiReadAndStartRW, &valueSet );
		if( (uint32_t)(valueSet & ConfigU18SpiReadAndStartRMask) == (uint32_t)(pFromFpga->data & ConfigU18SpiReadAndStartRMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				ConfigU18SpiReadAndStartRWString, (unsigned ) pFromFpga->data & ConfigU18SpiReadAndStartRMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				ConfigU18SpiReadAndStartRWString, valueSet & ConfigU18SpiReadAndStartRMask, (unsigned ) pFromFpga->data & ConfigU18SpiReadAndStartRMask);
			status = asynError;
			setParamStatus(p_ConfigU18SpiReadAndStartRW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case ConfigU2ClkResetRWAdr:
		status = (asynStatus) getIntegerParam(p_ConfigU2ClkResetRW, &valueSet );
		if( (uint32_t)(valueSet & ConfigU2ClkResetRMask) == (uint32_t)(pFromFpga->data & ConfigU2ClkResetRMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				ConfigU2ClkResetRWString, (unsigned ) pFromFpga->data & ConfigU2ClkResetRMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				ConfigU2ClkResetRWString, valueSet & ConfigU2ClkResetRMask, (unsigned ) pFromFpga->data & ConfigU2ClkResetRMask);
			status = asynError;
			setParamStatus(p_ConfigU2ClkResetRW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case ConfigU2IserdesResetRWAdr:
		status = (asynStatus) getIntegerParam(p_ConfigU2IserdesResetRW, &valueSet );
		if( (uint32_t)(valueSet & ConfigU2IserdesResetRMask) == (uint32_t)(pFromFpga->data & ConfigU2IserdesResetRMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				ConfigU2IserdesResetRWString, (unsigned ) pFromFpga->data & ConfigU2IserdesResetRMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				ConfigU2IserdesResetRWString, valueSet & ConfigU2IserdesResetRMask, (unsigned ) pFromFpga->data & ConfigU2IserdesResetRMask);
			status = asynError;
			setParamStatus(p_ConfigU2IserdesResetRW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case ConfigU3ClkResetRWAdr:
		status = (asynStatus) getIntegerParam(p_ConfigU3ClkResetRW, &valueSet );
		if( (uint32_t)(valueSet & ConfigU3ClkResetRMask) == (uint32_t)(pFromFpga->data & ConfigU3ClkResetRMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				ConfigU3ClkResetRWString, (unsigned ) pFromFpga->data & ConfigU3ClkResetRMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				ConfigU3ClkResetRWString, valueSet & ConfigU3ClkResetRMask, (unsigned ) pFromFpga->data & ConfigU3ClkResetRMask);
			status = asynError;
			setParamStatus(p_ConfigU3ClkResetRW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case ConfigU3IserdesResetRWAdr:
		status = (asynStatus) getIntegerParam(p_ConfigU3IserdesResetRW, &valueSet );
		if( (uint32_t)(valueSet & ConfigU3IserdesResetRMask) == (uint32_t)(pFromFpga->data & ConfigU3IserdesResetRMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				ConfigU3IserdesResetRWString, (unsigned ) pFromFpga->data & ConfigU3IserdesResetRMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				ConfigU3IserdesResetRWString, valueSet & ConfigU3IserdesResetRMask, (unsigned ) pFromFpga->data & ConfigU3IserdesResetRMask);
			status = asynError;
			setParamStatus(p_ConfigU3IserdesResetRW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case ConfigU4ResetRWAdr:
		status = (asynStatus) getIntegerParam(p_ConfigU4ResetRW, &valueSet );
		if( (uint32_t)(valueSet & ConfigU4ResetRMask) == (uint32_t)(pFromFpga->data & ConfigU4ResetRMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				ConfigU4ResetRWString, (unsigned ) pFromFpga->data & ConfigU4ResetRMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				ConfigU4ResetRWString, valueSet & ConfigU4ResetRMask, (unsigned ) pFromFpga->data & ConfigU4ResetRMask);
			status = asynError;
			setParamStatus(p_ConfigU4ResetRW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case ConfigBanyanMaskWAdr:
		status = (asynStatus) getIntegerParam(p_ConfigBanyanMaskW, &valueSet );
		if( (uint32_t)(valueSet & ConfigBanyanMaskMask) == (uint32_t)(pFromFpga->data & ConfigBanyanMaskMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				ConfigBanyanMaskWString, (unsigned ) pFromFpga->data & ConfigBanyanMaskMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				ConfigBanyanMaskWString, valueSet & ConfigBanyanMaskMask, (unsigned ) pFromFpga->data & ConfigBanyanMaskMask);
			status = asynError;
			setParamStatus(p_ConfigBanyanMaskW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case ConfigBitslipWAdr:
		status = (asynStatus) getIntegerParam(p_ConfigBitslipW, &valueSet );
		if( (uint32_t)(valueSet & ConfigBitslipMask) == (uint32_t)(pFromFpga->data & ConfigBitslipMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				ConfigBitslipWString, (unsigned ) pFromFpga->data & ConfigBitslipMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				ConfigBitslipWString, valueSet & ConfigBitslipMask, (unsigned ) pFromFpga->data & ConfigBitslipMask);
			status = asynError;
			setParamStatus(p_ConfigBitslipW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case ConfigClkStatusWeWAdr:
		status = (asynStatus) getIntegerParam(p_ConfigClkStatusWeW, &valueSet );
		if( (uint32_t)(valueSet & ConfigClkStatusWeMask) == (uint32_t)(pFromFpga->data & ConfigClkStatusWeMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				ConfigClkStatusWeWString, (unsigned ) pFromFpga->data & ConfigClkStatusWeMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				ConfigClkStatusWeWString, valueSet & ConfigClkStatusWeMask, (unsigned ) pFromFpga->data & ConfigClkStatusWeMask);
			status = asynError;
			setParamStatus(p_ConfigClkStatusWeW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case ConfigIdelayctrlResetRWAdr:
		status = (asynStatus) getIntegerParam(p_ConfigIdelayctrlResetRW, &valueSet );
		if( (uint32_t)(valueSet & ConfigIdelayctrlResetRMask) == (uint32_t)(pFromFpga->data & ConfigIdelayctrlResetRMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				ConfigIdelayctrlResetRWString, (unsigned ) pFromFpga->data & ConfigIdelayctrlResetRMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				ConfigIdelayctrlResetRWString, valueSet & ConfigIdelayctrlResetRMask, (unsigned ) pFromFpga->data & ConfigIdelayctrlResetRMask);
			status = asynError;
			setParamStatus(p_ConfigIdelayctrlResetRW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case ConfigLlspiWeWAdr:
		status = (asynStatus) getIntegerParam(p_ConfigLlspiWeW, &valueSet );
		if( (uint32_t)(valueSet & ConfigLlspiWeMask) == (uint32_t)(pFromFpga->data & ConfigLlspiWeMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				ConfigLlspiWeWString, (unsigned ) pFromFpga->data & ConfigLlspiWeMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				ConfigLlspiWeWString, valueSet & ConfigLlspiWeMask, (unsigned ) pFromFpga->data & ConfigLlspiWeMask);
			status = asynError;
			setParamStatus(p_ConfigLlspiWeW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case ConfigMmcmResetRWAdr:
		status = (asynStatus) getIntegerParam(p_ConfigMmcmResetRW, &valueSet );
		if( (uint32_t)(valueSet & ConfigMmcmResetRMask) == (uint32_t)(pFromFpga->data & ConfigMmcmResetRMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				ConfigMmcmResetRWString, (unsigned ) pFromFpga->data & ConfigMmcmResetRMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				ConfigMmcmResetRWString, valueSet & ConfigMmcmResetRMask, (unsigned ) pFromFpga->data & ConfigMmcmResetRMask);
			status = asynError;
			setParamStatus(p_ConfigMmcmResetRW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case ConfigPeriphConfigWAdr:
		status = (asynStatus) getIntegerParam(p_ConfigPeriphConfigW, &valueSet );
		if( (uint32_t)(valueSet & ConfigPeriphConfigMask) == (uint32_t)(pFromFpga->data & ConfigPeriphConfigMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				ConfigPeriphConfigWString, (unsigned ) pFromFpga->data & ConfigPeriphConfigMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				ConfigPeriphConfigWString, valueSet & ConfigPeriphConfigMask, (unsigned ) pFromFpga->data & ConfigPeriphConfigMask);
			status = asynError;
			setParamStatus(p_ConfigPeriphConfigW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case ConfigPhasexTrigWAdr:
		status = (asynStatus) getIntegerParam(p_ConfigPhasexTrigW, &valueSet );
		if( (uint32_t)(valueSet & ConfigPhasexTrigMask) == (uint32_t)(pFromFpga->data & ConfigPhasexTrigMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				ConfigPhasexTrigWString, (unsigned ) pFromFpga->data & ConfigPhasexTrigMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				ConfigPhasexTrigWString, valueSet & ConfigPhasexTrigMask, (unsigned ) pFromFpga->data & ConfigPhasexTrigMask);
			status = asynError;
			setParamStatus(p_ConfigPhasexTrigW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case ConfigRawadcTrigWAdr:
		status = (asynStatus) getIntegerParam(p_ConfigRawadcTrigW, &valueSet );
		if( (uint32_t)(valueSet & ConfigRawadcTrigMask) == (uint32_t)(pFromFpga->data & ConfigRawadcTrigMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				ConfigRawadcTrigWString, (unsigned ) pFromFpga->data & ConfigRawadcTrigMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				ConfigRawadcTrigWString, valueSet & ConfigRawadcTrigMask, (unsigned ) pFromFpga->data & ConfigRawadcTrigMask);
			status = asynError;
			setParamStatus(p_ConfigRawadcTrigW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case ConfigScanTriggerWeWAdr:
		status = (asynStatus) getIntegerParam(p_ConfigScanTriggerWeW, &valueSet );
		if( (uint32_t)(valueSet & ConfigScanTriggerWeMask) == (uint32_t)(pFromFpga->data & ConfigScanTriggerWeMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				ConfigScanTriggerWeWString, (unsigned ) pFromFpga->data & ConfigScanTriggerWeMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				ConfigScanTriggerWeWString, valueSet & ConfigScanTriggerWeMask, (unsigned ) pFromFpga->data & ConfigScanTriggerWeMask);
			status = asynError;
			setParamStatus(p_ConfigScanTriggerWeW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case ConfigScannerDebugWAdr:
		status = (asynStatus) getIntegerParam(p_ConfigScannerDebugW, &valueSet );
		if( (uint32_t)(valueSet & ConfigScannerDebugMask) == (uint32_t)(pFromFpga->data & ConfigScannerDebugMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				ConfigScannerDebugWString, (unsigned ) pFromFpga->data & ConfigScannerDebugMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				ConfigScannerDebugWString, valueSet & ConfigScannerDebugMask, (unsigned ) pFromFpga->data & ConfigScannerDebugMask);
			status = asynError;
			setParamStatus(p_ConfigScannerDebugW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case ConfigSyncAd7794CsetWAdr:
		status = (asynStatus) getIntegerParam(p_ConfigSyncAd7794CsetW, &valueSet );
		if( (uint32_t)(valueSet & ConfigSyncAd7794CsetMask) == (uint32_t)(pFromFpga->data & ConfigSyncAd7794CsetMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				ConfigSyncAd7794CsetWString, (unsigned ) pFromFpga->data & ConfigSyncAd7794CsetMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				ConfigSyncAd7794CsetWString, valueSet & ConfigSyncAd7794CsetMask, (unsigned ) pFromFpga->data & ConfigSyncAd7794CsetMask);
			status = asynError;
			setParamStatus(p_ConfigSyncAd7794CsetW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case ConfigSyncTps62210CsetWAdr:
		status = (asynStatus) getIntegerParam(p_ConfigSyncTps62210CsetW, &valueSet );
		if( (uint32_t)(valueSet & ConfigSyncTps62210CsetMask) == (uint32_t)(pFromFpga->data & ConfigSyncTps62210CsetMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				ConfigSyncTps62210CsetWString, (unsigned ) pFromFpga->data & ConfigSyncTps62210CsetMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				ConfigSyncTps62210CsetWString, valueSet & ConfigSyncTps62210CsetMask, (unsigned ) pFromFpga->data & ConfigSyncTps62210CsetMask);
			status = asynError;
			setParamStatus(p_ConfigSyncTps62210CsetW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case AdcTestModeWAdr:
		status = (asynStatus) getIntegerParam(p_AdcTestModeW, &valueSet );
		if( (uint32_t)(valueSet & AdcTestModeMask) == (uint32_t)(pFromFpga->data & AdcTestModeMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				AdcTestModeWString, (unsigned ) pFromFpga->data & AdcTestModeMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				AdcTestModeWString, valueSet & AdcTestModeMask, (unsigned ) pFromFpga->data & AdcTestModeMask);
			status = asynError;
			setParamStatus(p_AdcTestModeW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case AdcTestResetWAdr:
		status = (asynStatus) getIntegerParam(p_AdcTestResetW, &valueSet );
		if( (uint32_t)(valueSet & AdcTestResetMask) == (uint32_t)(pFromFpga->data & AdcTestResetMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				AdcTestResetWString, (unsigned ) pFromFpga->data & AdcTestResetMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				AdcTestResetWString, valueSet & AdcTestResetMask, (unsigned ) pFromFpga->data & AdcTestResetMask);
			status = asynError;
			setParamStatus(p_AdcTestResetW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case AmplitudeWAdr:
		status = (asynStatus) getIntegerParam(p_AmplitudeW, &valueSet );
		if( (uint32_t)(valueSet & AmplitudeMask) == (uint32_t)(pFromFpga->data & AmplitudeMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				AmplitudeWString, (unsigned ) pFromFpga->data & AmplitudeMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				AmplitudeWString, valueSet & AmplitudeMask, (unsigned ) pFromFpga->data & AmplitudeMask);
			status = asynError;
			setParamStatus(p_AmplitudeW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case AverageLenWAdr:
		status = (asynStatus) getIntegerParam(p_AverageLenW, &valueSet );
		if( (uint32_t)(valueSet & AverageLenMask) == (uint32_t)(pFromFpga->data & AverageLenMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				AverageLenWString, (unsigned ) pFromFpga->data & AverageLenMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				AverageLenWString, valueSet & AverageLenMask, (unsigned ) pFromFpga->data & AverageLenMask);
			status = asynError;
			setParamStatus(p_AverageLenW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case BufTrigWAdr:
		status = (asynStatus) getUIntDigitalParam(p_BufTrigW, &uValueSet , BufTrigMask);
		if( (uint32_t)(uValueSet & BufTrigMask) == (uint32_t)(pFromFpga->data & BufTrigMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				BufTrigWString, (unsigned ) pFromFpga->data & BufTrigMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				BufTrigWString, uValueSet & BufTrigMask, (unsigned ) pFromFpga->data & BufTrigMask);
			status = asynError;
			setParamStatus(p_BufTrigW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case CicPeriodWAdr:
		status = (asynStatus) getIntegerParam(p_CicPeriodW, &valueSet );
		if( (uint32_t)(valueSet & CicPeriodMask) == (uint32_t)(pFromFpga->data & CicPeriodMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				CicPeriodWString, (unsigned ) pFromFpga->data & CicPeriodMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				CicPeriodWString, valueSet & CicPeriodMask, (unsigned ) pFromFpga->data & CicPeriodMask);
			status = asynError;
			setParamStatus(p_CicPeriodW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case CicShiftWAdr:
		status = (asynStatus) getIntegerParam(p_CicShiftW, &valueSet );
		if( (uint32_t)(valueSet & CicShiftMask) == (uint32_t)(pFromFpga->data & CicShiftMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				CicShiftWString, (unsigned ) pFromFpga->data & CicShiftMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				CicShiftWString, valueSet & CicShiftMask, (unsigned ) pFromFpga->data & CicShiftMask);
			status = asynError;
			setParamStatus(p_CicShiftW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case CircleBufFlipWAdr:
		status = (asynStatus) getUIntDigitalParam(p_CircleBufFlipW, &uValueSet , CircleBufFlipMask);
		if( (uint32_t)(uValueSet & CircleBufFlipMask) == (uint32_t)(pFromFpga->data & CircleBufFlipMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				CircleBufFlipWString, (unsigned ) pFromFpga->data & CircleBufFlipMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				CircleBufFlipWString, uValueSet & CircleBufFlipMask, (unsigned ) pFromFpga->data & CircleBufFlipMask);
			status = asynError;
			setParamStatus(p_CircleBufFlipW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case DacDdsResetWAdr:
		status = (asynStatus) getIntegerParam(p_DacDdsResetW, &valueSet );
		if( (uint32_t)(valueSet & DacDdsResetMask) == (uint32_t)(pFromFpga->data & DacDdsResetMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DacDdsResetWString, (unsigned ) pFromFpga->data & DacDdsResetMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				DacDdsResetWString, valueSet & DacDdsResetMask, (unsigned ) pFromFpga->data & DacDdsResetMask);
			status = asynError;
			setParamStatus(p_DacDdsResetW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case DacModeWAdr:
		status = (asynStatus) getIntegerParam(p_DacModeW, &valueSet );
		if( (uint32_t)(valueSet & DacModeMask) == (uint32_t)(pFromFpga->data & DacModeMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DacModeWString, (unsigned ) pFromFpga->data & DacModeMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				DacModeWString, valueSet & DacModeMask, (unsigned ) pFromFpga->data & DacModeMask);
			status = asynError;
			setParamStatus(p_DacModeW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case DdsaModuloWAdr:
		status = (asynStatus) getIntegerParam(p_DdsaModuloW, &valueSet );
		if( (uint32_t)(valueSet & DdsaModuloMask) == (uint32_t)(pFromFpga->data & DdsaModuloMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DdsaModuloWString, (unsigned ) pFromFpga->data & DdsaModuloMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				DdsaModuloWString, valueSet & DdsaModuloMask, (unsigned ) pFromFpga->data & DdsaModuloMask);
			status = asynError;
			setParamStatus(p_DdsaModuloW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case DdsaPhstepHWAdr:
		status = (asynStatus) getIntegerParam(p_DdsaPhstepHW, &valueSet );
		if( (uint32_t)(valueSet & DdsaPhstepHMask) == (uint32_t)(pFromFpga->data & DdsaPhstepHMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DdsaPhstepHWString, (unsigned ) pFromFpga->data & DdsaPhstepHMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				DdsaPhstepHWString, valueSet & DdsaPhstepHMask, (unsigned ) pFromFpga->data & DdsaPhstepHMask);
			status = asynError;
			setParamStatus(p_DdsaPhstepHW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case DdsaPhstepLWAdr:
		status = (asynStatus) getIntegerParam(p_DdsaPhstepLW, &valueSet );
		if( (uint32_t)(valueSet & DdsaPhstepLMask) == (uint32_t)(pFromFpga->data & DdsaPhstepLMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DdsaPhstepLWString, (unsigned ) pFromFpga->data & DdsaPhstepLMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				DdsaPhstepLWString, valueSet & DdsaPhstepLMask, (unsigned ) pFromFpga->data & DdsaPhstepLMask);
			status = asynError;
			setParamStatus(p_DdsaPhstepLW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case HistCountWStrobeWAdr:
		status = (asynStatus) getIntegerParam(p_HistCountWStrobeW, &valueSet );
		if( (uint32_t)(valueSet & HistCountWStrobeMask) == (uint32_t)(pFromFpga->data & HistCountWStrobeMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				HistCountWStrobeWString, (unsigned ) pFromFpga->data & HistCountWStrobeMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				HistCountWStrobeWString, valueSet & HistCountWStrobeMask, (unsigned ) pFromFpga->data & HistCountWStrobeMask);
			status = asynError;
			setParamStatus(p_HistCountWStrobeW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case LlrfDspDacEnWAdr:
		status = (asynStatus) getIntegerParam(p_LlrfDspDacEnW, &valueSet );
		if( (uint32_t)(valueSet & LlrfDspDacEnMask) == (uint32_t)(pFromFpga->data & LlrfDspDacEnMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				LlrfDspDacEnWString, (unsigned ) pFromFpga->data & LlrfDspDacEnMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				LlrfDspDacEnWString, valueSet & LlrfDspDacEnMask, (unsigned ) pFromFpga->data & LlrfDspDacEnMask);
			status = asynError;
			setParamStatus(p_LlrfDspDacEnW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case LoAmpWAdr:
		status = (asynStatus) getIntegerParam(p_LoAmpW, &valueSet );
		if( (uint32_t)(valueSet & LoAmpMask) == (uint32_t)(pFromFpga->data & LoAmpMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				LoAmpWString, (unsigned ) pFromFpga->data & LoAmpMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				LoAmpWString, valueSet & LoAmpMask, (unsigned ) pFromFpga->data & LoAmpMask);
			status = asynError;
			setParamStatus(p_LoAmpW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case ModuloWAdr:
		status = (asynStatus) getIntegerParam(p_ModuloW, &valueSet );
		if( (uint32_t)(valueSet & ModuloMask) == (uint32_t)(pFromFpga->data & ModuloMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				ModuloWString, (unsigned ) pFromFpga->data & ModuloMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				ModuloWString, valueSet & ModuloMask, (unsigned ) pFromFpga->data & ModuloMask);
			status = asynError;
			setParamStatus(p_ModuloW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case PhaseStepHWAdr:
		status = (asynStatus) getIntegerParam(p_PhaseStepHW, &valueSet );
		if( (uint32_t)(valueSet & PhaseStepHMask) == (uint32_t)(pFromFpga->data & PhaseStepHMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				PhaseStepHWString, (unsigned ) pFromFpga->data & PhaseStepHMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				PhaseStepHWString, valueSet & PhaseStepHMask, (unsigned ) pFromFpga->data & PhaseStepHMask);
			status = asynError;
			setParamStatus(p_PhaseStepHW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case PhaseStepLWAdr:
		status = (asynStatus) getIntegerParam(p_PhaseStepLW, &valueSet );
		if( (uint32_t)(valueSet & PhaseStepLMask) == (uint32_t)(pFromFpga->data & PhaseStepLMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				PhaseStepLWString, (unsigned ) pFromFpga->data & PhaseStepLMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				PhaseStepLWString, valueSet & PhaseStepLMask, (unsigned ) pFromFpga->data & PhaseStepLMask);
			status = asynError;
			setParamStatus(p_PhaseStepLW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case PrcDspCavSelWAdr:
		status = (asynStatus) getIntegerParam(p_PrcDspCavSelW, &valueSet );
		if( (uint32_t)(valueSet & PrcDspCavSelMask) == (uint32_t)(pFromFpga->data & PrcDspCavSelMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				PrcDspCavSelWString, (unsigned ) pFromFpga->data & PrcDspCavSelMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				PrcDspCavSelWString, valueSet & PrcDspCavSelMask, (unsigned ) pFromFpga->data & PrcDspCavSelMask);
			status = asynError;
			setParamStatus(p_PrcDspCavSelW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case PrcDspPrlCfgWAdr:
		status = (asynStatus) getIntegerParam(p_PrcDspPrlCfgW, &valueSet );
		if( (uint32_t)(valueSet & PrcDspPrlCfgMask) == (uint32_t)(pFromFpga->data & PrcDspPrlCfgMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				PrcDspPrlCfgWString, (unsigned ) pFromFpga->data & PrcDspPrlCfgMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				PrcDspPrlCfgWString, valueSet & PrcDspPrlCfgMask, (unsigned ) pFromFpga->data & PrcDspPrlCfgMask);
			status = asynError;
			setParamStatus(p_PrcDspPrlCfgW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case PrcDspPrlGainWAdr:
		status = (asynStatus) getIntegerParam(p_PrcDspPrlGainW, &valueSet );
		if( (uint32_t)(valueSet & PrcDspPrlGainMask) == (uint32_t)(pFromFpga->data & PrcDspPrlGainMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				PrcDspPrlGainWString, (unsigned ) pFromFpga->data & PrcDspPrlGainMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				PrcDspPrlGainWString, valueSet & PrcDspPrlGainMask, (unsigned ) pFromFpga->data & PrcDspPrlGainMask);
			status = asynError;
			setParamStatus(p_PrcDspPrlGainW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Beam0ModuloWAdr:
		status = (asynStatus) getIntegerParam(p_Beam0ModuloW, &valueSet );
		if( (uint32_t)(valueSet & Beam0ModuloMask) == (uint32_t)(pFromFpga->data & Beam0ModuloMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Beam0ModuloWString, (unsigned ) pFromFpga->data & Beam0ModuloMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Beam0ModuloWString, valueSet & Beam0ModuloMask, (unsigned ) pFromFpga->data & Beam0ModuloMask);
			status = asynError;
			setParamStatus(p_Beam0ModuloW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Beam0PhaseInitWAdr:
		status = (asynStatus) getIntegerParam(p_Beam0PhaseInitW, &valueSet );
		if( (uint32_t)(valueSet & Beam0PhaseInitMask) == (uint32_t)(pFromFpga->data & Beam0PhaseInitMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Beam0PhaseInitWString, (unsigned ) pFromFpga->data & Beam0PhaseInitMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Beam0PhaseInitWString, valueSet & Beam0PhaseInitMask, (unsigned ) pFromFpga->data & Beam0PhaseInitMask);
			status = asynError;
			setParamStatus(p_Beam0PhaseInitW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Beam0PhaseStepWAdr:
		status = (asynStatus) getIntegerParam(p_Beam0PhaseStepW, &valueSet );
		if( (uint32_t)(valueSet & Beam0PhaseStepMask) == (uint32_t)(pFromFpga->data & Beam0PhaseStepMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Beam0PhaseStepWString, (unsigned ) pFromFpga->data & Beam0PhaseStepMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Beam0PhaseStepWString, valueSet & Beam0PhaseStepMask, (unsigned ) pFromFpga->data & Beam0PhaseStepMask);
			status = asynError;
			setParamStatus(p_Beam0PhaseStepW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Beam1ModuloWAdr:
		status = (asynStatus) getIntegerParam(p_Beam1ModuloW, &valueSet );
		if( (uint32_t)(valueSet & Beam1ModuloMask) == (uint32_t)(pFromFpga->data & Beam1ModuloMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Beam1ModuloWString, (unsigned ) pFromFpga->data & Beam1ModuloMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Beam1ModuloWString, valueSet & Beam1ModuloMask, (unsigned ) pFromFpga->data & Beam1ModuloMask);
			status = asynError;
			setParamStatus(p_Beam1ModuloW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Beam1PhaseInitWAdr:
		status = (asynStatus) getIntegerParam(p_Beam1PhaseInitW, &valueSet );
		if( (uint32_t)(valueSet & Beam1PhaseInitMask) == (uint32_t)(pFromFpga->data & Beam1PhaseInitMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Beam1PhaseInitWString, (unsigned ) pFromFpga->data & Beam1PhaseInitMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Beam1PhaseInitWString, valueSet & Beam1PhaseInitMask, (unsigned ) pFromFpga->data & Beam1PhaseInitMask);
			status = asynError;
			setParamStatus(p_Beam1PhaseInitW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Beam1PhaseStepWAdr:
		status = (asynStatus) getIntegerParam(p_Beam1PhaseStepW, &valueSet );
		if( (uint32_t)(valueSet & Beam1PhaseStepMask) == (uint32_t)(pFromFpga->data & Beam1PhaseStepMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Beam1PhaseStepWString, (unsigned ) pFromFpga->data & Beam1PhaseStepMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Beam1PhaseStepWString, valueSet & Beam1PhaseStepMask, (unsigned ) pFromFpga->data & Beam1PhaseStepMask);
			status = asynError;
			setParamStatus(p_Beam1PhaseStepW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Cav4MechPrngIvaWAdr:
		status = (asynStatus) getIntegerParam(p_Cav4MechPrngIvaW, &valueSet );
		if( (uint32_t)(valueSet & Cav4MechPrngIvaMask) == (uint32_t)(pFromFpga->data & Cav4MechPrngIvaMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cav4MechPrngIvaWString, (unsigned ) pFromFpga->data & Cav4MechPrngIvaMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Cav4MechPrngIvaWString, valueSet & Cav4MechPrngIvaMask, (unsigned ) pFromFpga->data & Cav4MechPrngIvaMask);
			status = asynError;
			setParamStatus(p_Cav4MechPrngIvaW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Cav4MechPrngIvbWAdr:
		status = (asynStatus) getIntegerParam(p_Cav4MechPrngIvbW, &valueSet );
		if( (uint32_t)(valueSet & Cav4MechPrngIvbMask) == (uint32_t)(pFromFpga->data & Cav4MechPrngIvbMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cav4MechPrngIvbWString, (unsigned ) pFromFpga->data & Cav4MechPrngIvbMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Cav4MechPrngIvbWString, valueSet & Cav4MechPrngIvbMask, (unsigned ) pFromFpga->data & Cav4MechPrngIvbMask);
			status = asynError;
			setParamStatus(p_Cav4MechPrngIvbW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Cav4MechPrngRandomRunWAdr:
		status = (asynStatus) getIntegerParam(p_Cav4MechPrngRandomRunW, &valueSet );
		if( (uint32_t)(valueSet & Cav4MechPrngRandomRunMask) == (uint32_t)(pFromFpga->data & Cav4MechPrngRandomRunMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cav4MechPrngRandomRunWString, (unsigned ) pFromFpga->data & Cav4MechPrngRandomRunMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Cav4MechPrngRandomRunWString, valueSet & Cav4MechPrngRandomRunMask, (unsigned ) pFromFpga->data & Cav4MechPrngRandomRunMask);
			status = asynError;
			setParamStatus(p_Cav4MechPrngRandomRunW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Cavity0ACavOffsetWAdr:
		status = (asynStatus) getIntegerParam(p_Cavity0ACavOffsetW, &valueSet );
		if( (uint32_t)(valueSet & Cavity0ACavOffsetMask) == (uint32_t)(pFromFpga->data & Cavity0ACavOffsetMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0ACavOffsetWString, (unsigned ) pFromFpga->data & Cavity0ACavOffsetMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0ACavOffsetWString, valueSet & Cavity0ACavOffsetMask, (unsigned ) pFromFpga->data & Cavity0ACavOffsetMask);
			status = asynError;
			setParamStatus(p_Cavity0ACavOffsetW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Cavity0AForOffsetWAdr:
		status = (asynStatus) getIntegerParam(p_Cavity0AForOffsetW, &valueSet );
		if( (uint32_t)(valueSet & Cavity0AForOffsetMask) == (uint32_t)(pFromFpga->data & Cavity0AForOffsetMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0AForOffsetWString, (unsigned ) pFromFpga->data & Cavity0AForOffsetMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0AForOffsetWString, valueSet & Cavity0AForOffsetMask, (unsigned ) pFromFpga->data & Cavity0AForOffsetMask);
			status = asynError;
			setParamStatus(p_Cavity0AForOffsetW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Cavity0ARflOffsetWAdr:
		status = (asynStatus) getIntegerParam(p_Cavity0ARflOffsetW, &valueSet );
		if( (uint32_t)(valueSet & Cavity0ARflOffsetMask) == (uint32_t)(pFromFpga->data & Cavity0ARflOffsetMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0ARflOffsetWString, (unsigned ) pFromFpga->data & Cavity0ARflOffsetMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0ARflOffsetWString, valueSet & Cavity0ARflOffsetMask, (unsigned ) pFromFpga->data & Cavity0ARflOffsetMask);
			status = asynError;
			setParamStatus(p_Cavity0ARflOffsetW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Cavity0AmpLpBwWAdr:
		status = (asynStatus) getIntegerParam(p_Cavity0AmpLpBwW, &valueSet );
		if( (uint32_t)(valueSet & Cavity0AmpLpBwMask) == (uint32_t)(pFromFpga->data & Cavity0AmpLpBwMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0AmpLpBwWString, (unsigned ) pFromFpga->data & Cavity0AmpLpBwMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0AmpLpBwWString, valueSet & Cavity0AmpLpBwMask, (unsigned ) pFromFpga->data & Cavity0AmpLpBwMask);
			status = asynError;
			setParamStatus(p_Cavity0AmpLpBwW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Cavity0Freq0CoarseFreqWAdr:
		status = (asynStatus) getIntegerParam(p_Cavity0Freq0CoarseFreqW, &valueSet );
		if( (uint32_t)(valueSet & Cavity0Freq0CoarseFreqMask) == (uint32_t)(pFromFpga->data & Cavity0Freq0CoarseFreqMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0Freq0CoarseFreqWString, (unsigned ) pFromFpga->data & Cavity0Freq0CoarseFreqMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0Freq0CoarseFreqWString, valueSet & Cavity0Freq0CoarseFreqMask, (unsigned ) pFromFpga->data & Cavity0Freq0CoarseFreqMask);
			status = asynError;
			setParamStatus(p_Cavity0Freq0CoarseFreqW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Cavity0Freq1CoarseFreqWAdr:
		status = (asynStatus) getIntegerParam(p_Cavity0Freq1CoarseFreqW, &valueSet );
		if( (uint32_t)(valueSet & Cavity0Freq1CoarseFreqMask) == (uint32_t)(pFromFpga->data & Cavity0Freq1CoarseFreqMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0Freq1CoarseFreqWString, (unsigned ) pFromFpga->data & Cavity0Freq1CoarseFreqMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0Freq1CoarseFreqWString, valueSet & Cavity0Freq1CoarseFreqMask, (unsigned ) pFromFpga->data & Cavity0Freq1CoarseFreqMask);
			status = asynError;
			setParamStatus(p_Cavity0Freq1CoarseFreqW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Cavity0Freq2CoarseFreqWAdr:
		status = (asynStatus) getIntegerParam(p_Cavity0Freq2CoarseFreqW, &valueSet );
		if( (uint32_t)(valueSet & Cavity0Freq2CoarseFreqMask) == (uint32_t)(pFromFpga->data & Cavity0Freq2CoarseFreqMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0Freq2CoarseFreqWString, (unsigned ) pFromFpga->data & Cavity0Freq2CoarseFreqMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0Freq2CoarseFreqWString, valueSet & Cavity0Freq2CoarseFreqMask, (unsigned ) pFromFpga->data & Cavity0Freq2CoarseFreqMask);
			status = asynError;
			setParamStatus(p_Cavity0Freq2CoarseFreqW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Cavity0Mode0BeamCouplingWAdr:
		status = (asynStatus) getIntegerParam(p_Cavity0Mode0BeamCouplingW, &valueSet );
		if( (uint32_t)(valueSet & Cavity0Mode0BeamCouplingMask) == (uint32_t)(pFromFpga->data & Cavity0Mode0BeamCouplingMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0Mode0BeamCouplingWString, (unsigned ) pFromFpga->data & Cavity0Mode0BeamCouplingMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0Mode0BeamCouplingWString, valueSet & Cavity0Mode0BeamCouplingMask, (unsigned ) pFromFpga->data & Cavity0Mode0BeamCouplingMask);
			status = asynError;
			setParamStatus(p_Cavity0Mode0BeamCouplingW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Cavity0Mode0BwWAdr:
		status = (asynStatus) getIntegerParam(p_Cavity0Mode0BwW, &valueSet );
		if( (uint32_t)(valueSet & Cavity0Mode0BwMask) == (uint32_t)(pFromFpga->data & Cavity0Mode0BwMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0Mode0BwWString, (unsigned ) pFromFpga->data & Cavity0Mode0BwMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0Mode0BwWString, valueSet & Cavity0Mode0BwMask, (unsigned ) pFromFpga->data & Cavity0Mode0BwMask);
			status = asynError;
			setParamStatus(p_Cavity0Mode0BwW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Cavity0Mode0DriveCouplingWAdr:
		status = (asynStatus) getIntegerParam(p_Cavity0Mode0DriveCouplingW, &valueSet );
		if( (uint32_t)(valueSet & Cavity0Mode0DriveCouplingMask) == (uint32_t)(pFromFpga->data & Cavity0Mode0DriveCouplingMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0Mode0DriveCouplingWString, (unsigned ) pFromFpga->data & Cavity0Mode0DriveCouplingMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0Mode0DriveCouplingWString, valueSet & Cavity0Mode0DriveCouplingMask, (unsigned ) pFromFpga->data & Cavity0Mode0DriveCouplingMask);
			status = asynError;
			setParamStatus(p_Cavity0Mode0DriveCouplingW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Cavity0Mode1BeamCouplingWAdr:
		status = (asynStatus) getIntegerParam(p_Cavity0Mode1BeamCouplingW, &valueSet );
		if( (uint32_t)(valueSet & Cavity0Mode1BeamCouplingMask) == (uint32_t)(pFromFpga->data & Cavity0Mode1BeamCouplingMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0Mode1BeamCouplingWString, (unsigned ) pFromFpga->data & Cavity0Mode1BeamCouplingMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0Mode1BeamCouplingWString, valueSet & Cavity0Mode1BeamCouplingMask, (unsigned ) pFromFpga->data & Cavity0Mode1BeamCouplingMask);
			status = asynError;
			setParamStatus(p_Cavity0Mode1BeamCouplingW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Cavity0Mode1BwWAdr:
		status = (asynStatus) getIntegerParam(p_Cavity0Mode1BwW, &valueSet );
		if( (uint32_t)(valueSet & Cavity0Mode1BwMask) == (uint32_t)(pFromFpga->data & Cavity0Mode1BwMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0Mode1BwWString, (unsigned ) pFromFpga->data & Cavity0Mode1BwMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0Mode1BwWString, valueSet & Cavity0Mode1BwMask, (unsigned ) pFromFpga->data & Cavity0Mode1BwMask);
			status = asynError;
			setParamStatus(p_Cavity0Mode1BwW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Cavity0Mode1DriveCouplingWAdr:
		status = (asynStatus) getIntegerParam(p_Cavity0Mode1DriveCouplingW, &valueSet );
		if( (uint32_t)(valueSet & Cavity0Mode1DriveCouplingMask) == (uint32_t)(pFromFpga->data & Cavity0Mode1DriveCouplingMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0Mode1DriveCouplingWString, (unsigned ) pFromFpga->data & Cavity0Mode1DriveCouplingMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0Mode1DriveCouplingWString, valueSet & Cavity0Mode1DriveCouplingMask, (unsigned ) pFromFpga->data & Cavity0Mode1DriveCouplingMask);
			status = asynError;
			setParamStatus(p_Cavity0Mode1DriveCouplingW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Cavity0Mode2BeamCouplingWAdr:
		status = (asynStatus) getIntegerParam(p_Cavity0Mode2BeamCouplingW, &valueSet );
		if( (uint32_t)(valueSet & Cavity0Mode2BeamCouplingMask) == (uint32_t)(pFromFpga->data & Cavity0Mode2BeamCouplingMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0Mode2BeamCouplingWString, (unsigned ) pFromFpga->data & Cavity0Mode2BeamCouplingMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0Mode2BeamCouplingWString, valueSet & Cavity0Mode2BeamCouplingMask, (unsigned ) pFromFpga->data & Cavity0Mode2BeamCouplingMask);
			status = asynError;
			setParamStatus(p_Cavity0Mode2BeamCouplingW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Cavity0Mode2BwWAdr:
		status = (asynStatus) getIntegerParam(p_Cavity0Mode2BwW, &valueSet );
		if( (uint32_t)(valueSet & Cavity0Mode2BwMask) == (uint32_t)(pFromFpga->data & Cavity0Mode2BwMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0Mode2BwWString, (unsigned ) pFromFpga->data & Cavity0Mode2BwMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0Mode2BwWString, valueSet & Cavity0Mode2BwMask, (unsigned ) pFromFpga->data & Cavity0Mode2BwMask);
			status = asynError;
			setParamStatus(p_Cavity0Mode2BwW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Cavity0Mode2DriveCouplingWAdr:
		status = (asynStatus) getIntegerParam(p_Cavity0Mode2DriveCouplingW, &valueSet );
		if( (uint32_t)(valueSet & Cavity0Mode2DriveCouplingMask) == (uint32_t)(pFromFpga->data & Cavity0Mode2DriveCouplingMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0Mode2DriveCouplingWString, (unsigned ) pFromFpga->data & Cavity0Mode2DriveCouplingMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0Mode2DriveCouplingWString, valueSet & Cavity0Mode2DriveCouplingMask, (unsigned ) pFromFpga->data & Cavity0Mode2DriveCouplingMask);
			status = asynError;
			setParamStatus(p_Cavity0Mode2DriveCouplingW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Cavity0ModuloWAdr:
		status = (asynStatus) getIntegerParam(p_Cavity0ModuloW, &valueSet );
		if( (uint32_t)(valueSet & Cavity0ModuloMask) == (uint32_t)(pFromFpga->data & Cavity0ModuloMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0ModuloWString, (unsigned ) pFromFpga->data & Cavity0ModuloMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0ModuloWString, valueSet & Cavity0ModuloMask, (unsigned ) pFromFpga->data & Cavity0ModuloMask);
			status = asynError;
			setParamStatus(p_Cavity0ModuloW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Cavity0PhaseStepWAdr:
		status = (asynStatus) getIntegerParam(p_Cavity0PhaseStepW, &valueSet );
		if( (uint32_t)(valueSet & Cavity0PhaseStepMask) == (uint32_t)(pFromFpga->data & Cavity0PhaseStepMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0PhaseStepWString, (unsigned ) pFromFpga->data & Cavity0PhaseStepMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0PhaseStepWString, valueSet & Cavity0PhaseStepMask, (unsigned ) pFromFpga->data & Cavity0PhaseStepMask);
			status = asynError;
			setParamStatus(p_Cavity0PhaseStepW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Cavity0ComprSatCtlWAdr:
		status = (asynStatus) getIntegerParam(p_Cavity0ComprSatCtlW, &valueSet );
		if( (uint32_t)(valueSet & Cavity0ComprSatCtlMask) == (uint32_t)(pFromFpga->data & Cavity0ComprSatCtlMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0ComprSatCtlWString, (unsigned ) pFromFpga->data & Cavity0ComprSatCtlMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0ComprSatCtlWString, valueSet & Cavity0ComprSatCtlMask, (unsigned ) pFromFpga->data & Cavity0ComprSatCtlMask);
			status = asynError;
			setParamStatus(p_Cavity0ComprSatCtlW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Cavity0PrngIvaWAdr:
		status = (asynStatus) getIntegerParam(p_Cavity0PrngIvaW, &valueSet );
		if( (uint32_t)(valueSet & Cavity0PrngIvaMask) == (uint32_t)(pFromFpga->data & Cavity0PrngIvaMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0PrngIvaWString, (unsigned ) pFromFpga->data & Cavity0PrngIvaMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0PrngIvaWString, valueSet & Cavity0PrngIvaMask, (unsigned ) pFromFpga->data & Cavity0PrngIvaMask);
			status = asynError;
			setParamStatus(p_Cavity0PrngIvaW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Cavity0PrngIvbWAdr:
		status = (asynStatus) getIntegerParam(p_Cavity0PrngIvbW, &valueSet );
		if( (uint32_t)(valueSet & Cavity0PrngIvbMask) == (uint32_t)(pFromFpga->data & Cavity0PrngIvbMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0PrngIvbWString, (unsigned ) pFromFpga->data & Cavity0PrngIvbMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0PrngIvbWString, valueSet & Cavity0PrngIvbMask, (unsigned ) pFromFpga->data & Cavity0PrngIvbMask);
			status = asynError;
			setParamStatus(p_Cavity0PrngIvbW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Cavity0PrngRandomRunWAdr:
		status = (asynStatus) getIntegerParam(p_Cavity0PrngRandomRunW, &valueSet );
		if( (uint32_t)(valueSet & Cavity0PrngRandomRunMask) == (uint32_t)(pFromFpga->data & Cavity0PrngRandomRunMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0PrngRandomRunWString, (unsigned ) pFromFpga->data & Cavity0PrngRandomRunMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity0PrngRandomRunWString, valueSet & Cavity0PrngRandomRunMask, (unsigned ) pFromFpga->data & Cavity0PrngRandomRunMask);
			status = asynError;
			setParamStatus(p_Cavity0PrngRandomRunW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Cavity1ACavOffsetWAdr:
		status = (asynStatus) getIntegerParam(p_Cavity1ACavOffsetW, &valueSet );
		if( (uint32_t)(valueSet & Cavity1ACavOffsetMask) == (uint32_t)(pFromFpga->data & Cavity1ACavOffsetMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1ACavOffsetWString, (unsigned ) pFromFpga->data & Cavity1ACavOffsetMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1ACavOffsetWString, valueSet & Cavity1ACavOffsetMask, (unsigned ) pFromFpga->data & Cavity1ACavOffsetMask);
			status = asynError;
			setParamStatus(p_Cavity1ACavOffsetW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Cavity1AForOffsetWAdr:
		status = (asynStatus) getIntegerParam(p_Cavity1AForOffsetW, &valueSet );
		if( (uint32_t)(valueSet & Cavity1AForOffsetMask) == (uint32_t)(pFromFpga->data & Cavity1AForOffsetMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1AForOffsetWString, (unsigned ) pFromFpga->data & Cavity1AForOffsetMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1AForOffsetWString, valueSet & Cavity1AForOffsetMask, (unsigned ) pFromFpga->data & Cavity1AForOffsetMask);
			status = asynError;
			setParamStatus(p_Cavity1AForOffsetW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Cavity1ARflOffsetWAdr:
		status = (asynStatus) getIntegerParam(p_Cavity1ARflOffsetW, &valueSet );
		if( (uint32_t)(valueSet & Cavity1ARflOffsetMask) == (uint32_t)(pFromFpga->data & Cavity1ARflOffsetMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1ARflOffsetWString, (unsigned ) pFromFpga->data & Cavity1ARflOffsetMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1ARflOffsetWString, valueSet & Cavity1ARflOffsetMask, (unsigned ) pFromFpga->data & Cavity1ARflOffsetMask);
			status = asynError;
			setParamStatus(p_Cavity1ARflOffsetW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Cavity1AmpLpBwWAdr:
		status = (asynStatus) getIntegerParam(p_Cavity1AmpLpBwW, &valueSet );
		if( (uint32_t)(valueSet & Cavity1AmpLpBwMask) == (uint32_t)(pFromFpga->data & Cavity1AmpLpBwMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1AmpLpBwWString, (unsigned ) pFromFpga->data & Cavity1AmpLpBwMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1AmpLpBwWString, valueSet & Cavity1AmpLpBwMask, (unsigned ) pFromFpga->data & Cavity1AmpLpBwMask);
			status = asynError;
			setParamStatus(p_Cavity1AmpLpBwW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Cavity1Freq0CoarseFreqWAdr:
		status = (asynStatus) getIntegerParam(p_Cavity1Freq0CoarseFreqW, &valueSet );
		if( (uint32_t)(valueSet & Cavity1Freq0CoarseFreqMask) == (uint32_t)(pFromFpga->data & Cavity1Freq0CoarseFreqMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1Freq0CoarseFreqWString, (unsigned ) pFromFpga->data & Cavity1Freq0CoarseFreqMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1Freq0CoarseFreqWString, valueSet & Cavity1Freq0CoarseFreqMask, (unsigned ) pFromFpga->data & Cavity1Freq0CoarseFreqMask);
			status = asynError;
			setParamStatus(p_Cavity1Freq0CoarseFreqW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Cavity1Freq1CoarseFreqWAdr:
		status = (asynStatus) getIntegerParam(p_Cavity1Freq1CoarseFreqW, &valueSet );
		if( (uint32_t)(valueSet & Cavity1Freq1CoarseFreqMask) == (uint32_t)(pFromFpga->data & Cavity1Freq1CoarseFreqMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1Freq1CoarseFreqWString, (unsigned ) pFromFpga->data & Cavity1Freq1CoarseFreqMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1Freq1CoarseFreqWString, valueSet & Cavity1Freq1CoarseFreqMask, (unsigned ) pFromFpga->data & Cavity1Freq1CoarseFreqMask);
			status = asynError;
			setParamStatus(p_Cavity1Freq1CoarseFreqW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Cavity1Freq2CoarseFreqWAdr:
		status = (asynStatus) getIntegerParam(p_Cavity1Freq2CoarseFreqW, &valueSet );
		if( (uint32_t)(valueSet & Cavity1Freq2CoarseFreqMask) == (uint32_t)(pFromFpga->data & Cavity1Freq2CoarseFreqMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1Freq2CoarseFreqWString, (unsigned ) pFromFpga->data & Cavity1Freq2CoarseFreqMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1Freq2CoarseFreqWString, valueSet & Cavity1Freq2CoarseFreqMask, (unsigned ) pFromFpga->data & Cavity1Freq2CoarseFreqMask);
			status = asynError;
			setParamStatus(p_Cavity1Freq2CoarseFreqW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Cavity1Mode0BeamCouplingWAdr:
		status = (asynStatus) getIntegerParam(p_Cavity1Mode0BeamCouplingW, &valueSet );
		if( (uint32_t)(valueSet & Cavity1Mode0BeamCouplingMask) == (uint32_t)(pFromFpga->data & Cavity1Mode0BeamCouplingMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1Mode0BeamCouplingWString, (unsigned ) pFromFpga->data & Cavity1Mode0BeamCouplingMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1Mode0BeamCouplingWString, valueSet & Cavity1Mode0BeamCouplingMask, (unsigned ) pFromFpga->data & Cavity1Mode0BeamCouplingMask);
			status = asynError;
			setParamStatus(p_Cavity1Mode0BeamCouplingW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Cavity1Mode0BwWAdr:
		status = (asynStatus) getIntegerParam(p_Cavity1Mode0BwW, &valueSet );
		if( (uint32_t)(valueSet & Cavity1Mode0BwMask) == (uint32_t)(pFromFpga->data & Cavity1Mode0BwMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1Mode0BwWString, (unsigned ) pFromFpga->data & Cavity1Mode0BwMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1Mode0BwWString, valueSet & Cavity1Mode0BwMask, (unsigned ) pFromFpga->data & Cavity1Mode0BwMask);
			status = asynError;
			setParamStatus(p_Cavity1Mode0BwW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Cavity1Mode0DriveCouplingWAdr:
		status = (asynStatus) getIntegerParam(p_Cavity1Mode0DriveCouplingW, &valueSet );
		if( (uint32_t)(valueSet & Cavity1Mode0DriveCouplingMask) == (uint32_t)(pFromFpga->data & Cavity1Mode0DriveCouplingMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1Mode0DriveCouplingWString, (unsigned ) pFromFpga->data & Cavity1Mode0DriveCouplingMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1Mode0DriveCouplingWString, valueSet & Cavity1Mode0DriveCouplingMask, (unsigned ) pFromFpga->data & Cavity1Mode0DriveCouplingMask);
			status = asynError;
			setParamStatus(p_Cavity1Mode0DriveCouplingW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Cavity1Mode1BeamCouplingWAdr:
		status = (asynStatus) getIntegerParam(p_Cavity1Mode1BeamCouplingW, &valueSet );
		if( (uint32_t)(valueSet & Cavity1Mode1BeamCouplingMask) == (uint32_t)(pFromFpga->data & Cavity1Mode1BeamCouplingMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1Mode1BeamCouplingWString, (unsigned ) pFromFpga->data & Cavity1Mode1BeamCouplingMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1Mode1BeamCouplingWString, valueSet & Cavity1Mode1BeamCouplingMask, (unsigned ) pFromFpga->data & Cavity1Mode1BeamCouplingMask);
			status = asynError;
			setParamStatus(p_Cavity1Mode1BeamCouplingW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Cavity1Mode1BwWAdr:
		status = (asynStatus) getIntegerParam(p_Cavity1Mode1BwW, &valueSet );
		if( (uint32_t)(valueSet & Cavity1Mode1BwMask) == (uint32_t)(pFromFpga->data & Cavity1Mode1BwMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1Mode1BwWString, (unsigned ) pFromFpga->data & Cavity1Mode1BwMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1Mode1BwWString, valueSet & Cavity1Mode1BwMask, (unsigned ) pFromFpga->data & Cavity1Mode1BwMask);
			status = asynError;
			setParamStatus(p_Cavity1Mode1BwW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Cavity1Mode1DriveCouplingWAdr:
		status = (asynStatus) getIntegerParam(p_Cavity1Mode1DriveCouplingW, &valueSet );
		if( (uint32_t)(valueSet & Cavity1Mode1DriveCouplingMask) == (uint32_t)(pFromFpga->data & Cavity1Mode1DriveCouplingMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1Mode1DriveCouplingWString, (unsigned ) pFromFpga->data & Cavity1Mode1DriveCouplingMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1Mode1DriveCouplingWString, valueSet & Cavity1Mode1DriveCouplingMask, (unsigned ) pFromFpga->data & Cavity1Mode1DriveCouplingMask);
			status = asynError;
			setParamStatus(p_Cavity1Mode1DriveCouplingW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Cavity1Mode2BeamCouplingWAdr:
		status = (asynStatus) getIntegerParam(p_Cavity1Mode2BeamCouplingW, &valueSet );
		if( (uint32_t)(valueSet & Cavity1Mode2BeamCouplingMask) == (uint32_t)(pFromFpga->data & Cavity1Mode2BeamCouplingMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1Mode2BeamCouplingWString, (unsigned ) pFromFpga->data & Cavity1Mode2BeamCouplingMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1Mode2BeamCouplingWString, valueSet & Cavity1Mode2BeamCouplingMask, (unsigned ) pFromFpga->data & Cavity1Mode2BeamCouplingMask);
			status = asynError;
			setParamStatus(p_Cavity1Mode2BeamCouplingW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Cavity1Mode2BwWAdr:
		status = (asynStatus) getIntegerParam(p_Cavity1Mode2BwW, &valueSet );
		if( (uint32_t)(valueSet & Cavity1Mode2BwMask) == (uint32_t)(pFromFpga->data & Cavity1Mode2BwMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1Mode2BwWString, (unsigned ) pFromFpga->data & Cavity1Mode2BwMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1Mode2BwWString, valueSet & Cavity1Mode2BwMask, (unsigned ) pFromFpga->data & Cavity1Mode2BwMask);
			status = asynError;
			setParamStatus(p_Cavity1Mode2BwW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Cavity1Mode2DriveCouplingWAdr:
		status = (asynStatus) getIntegerParam(p_Cavity1Mode2DriveCouplingW, &valueSet );
		if( (uint32_t)(valueSet & Cavity1Mode2DriveCouplingMask) == (uint32_t)(pFromFpga->data & Cavity1Mode2DriveCouplingMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1Mode2DriveCouplingWString, (unsigned ) pFromFpga->data & Cavity1Mode2DriveCouplingMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1Mode2DriveCouplingWString, valueSet & Cavity1Mode2DriveCouplingMask, (unsigned ) pFromFpga->data & Cavity1Mode2DriveCouplingMask);
			status = asynError;
			setParamStatus(p_Cavity1Mode2DriveCouplingW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Cavity1ModuloWAdr:
		status = (asynStatus) getIntegerParam(p_Cavity1ModuloW, &valueSet );
		if( (uint32_t)(valueSet & Cavity1ModuloMask) == (uint32_t)(pFromFpga->data & Cavity1ModuloMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1ModuloWString, (unsigned ) pFromFpga->data & Cavity1ModuloMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1ModuloWString, valueSet & Cavity1ModuloMask, (unsigned ) pFromFpga->data & Cavity1ModuloMask);
			status = asynError;
			setParamStatus(p_Cavity1ModuloW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Cavity1PhaseStepWAdr:
		status = (asynStatus) getIntegerParam(p_Cavity1PhaseStepW, &valueSet );
		if( (uint32_t)(valueSet & Cavity1PhaseStepMask) == (uint32_t)(pFromFpga->data & Cavity1PhaseStepMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1PhaseStepWString, (unsigned ) pFromFpga->data & Cavity1PhaseStepMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1PhaseStepWString, valueSet & Cavity1PhaseStepMask, (unsigned ) pFromFpga->data & Cavity1PhaseStepMask);
			status = asynError;
			setParamStatus(p_Cavity1PhaseStepW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Cavity1ComprSatCtlWAdr:
		status = (asynStatus) getIntegerParam(p_Cavity1ComprSatCtlW, &valueSet );
		if( (uint32_t)(valueSet & Cavity1ComprSatCtlMask) == (uint32_t)(pFromFpga->data & Cavity1ComprSatCtlMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1ComprSatCtlWString, (unsigned ) pFromFpga->data & Cavity1ComprSatCtlMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1ComprSatCtlWString, valueSet & Cavity1ComprSatCtlMask, (unsigned ) pFromFpga->data & Cavity1ComprSatCtlMask);
			status = asynError;
			setParamStatus(p_Cavity1ComprSatCtlW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Cavity1PrngIvaWAdr:
		status = (asynStatus) getIntegerParam(p_Cavity1PrngIvaW, &valueSet );
		if( (uint32_t)(valueSet & Cavity1PrngIvaMask) == (uint32_t)(pFromFpga->data & Cavity1PrngIvaMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1PrngIvaWString, (unsigned ) pFromFpga->data & Cavity1PrngIvaMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1PrngIvaWString, valueSet & Cavity1PrngIvaMask, (unsigned ) pFromFpga->data & Cavity1PrngIvaMask);
			status = asynError;
			setParamStatus(p_Cavity1PrngIvaW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Cavity1PrngIvbWAdr:
		status = (asynStatus) getIntegerParam(p_Cavity1PrngIvbW, &valueSet );
		if( (uint32_t)(valueSet & Cavity1PrngIvbMask) == (uint32_t)(pFromFpga->data & Cavity1PrngIvbMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1PrngIvbWString, (unsigned ) pFromFpga->data & Cavity1PrngIvbMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1PrngIvbWString, valueSet & Cavity1PrngIvbMask, (unsigned ) pFromFpga->data & Cavity1PrngIvbMask);
			status = asynError;
			setParamStatus(p_Cavity1PrngIvbW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Cavity1PrngRandomRunWAdr:
		status = (asynStatus) getIntegerParam(p_Cavity1PrngRandomRunW, &valueSet );
		if( (uint32_t)(valueSet & Cavity1PrngRandomRunMask) == (uint32_t)(pFromFpga->data & Cavity1PrngRandomRunMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1PrngRandomRunWString, (unsigned ) pFromFpga->data & Cavity1PrngRandomRunMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1PrngRandomRunWString, valueSet & Cavity1PrngRandomRunMask, (unsigned ) pFromFpga->data & Cavity1PrngRandomRunMask);
			status = asynError;
			setParamStatus(p_Cavity1PrngRandomRunW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case DacIqPhaseWAdr:
		status = (asynStatus) getIntegerParam(p_DacIqPhaseW, &valueSet );
		if( (uint32_t)(valueSet & DacIqPhaseMask) == (uint32_t)(pFromFpga->data & DacIqPhaseMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DacIqPhaseWString, (unsigned ) pFromFpga->data & DacIqPhaseMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				DacIqPhaseWString, valueSet & DacIqPhaseMask, (unsigned ) pFromFpga->data & DacIqPhaseMask);
			status = asynError;
			setParamStatus(p_DacIqPhaseW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Shell0DspChanKeepWAdr:
		status = (asynStatus) getUIntDigitalParam(p_Shell0DspChanKeepW, &uValueSet , Shell0DspChanKeepMask);
		if( (uint32_t)(uValueSet & Shell0DspChanKeepMask) == (uint32_t)(pFromFpga->data & Shell0DspChanKeepMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell0DspChanKeepWString, (unsigned ) pFromFpga->data & Shell0DspChanKeepMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Shell0DspChanKeepWString, uValueSet & Shell0DspChanKeepMask, (unsigned ) pFromFpga->data & Shell0DspChanKeepMask);
			status = asynError;
			setParamStatus(p_Shell0DspChanKeepW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Shell0DspFdbkCoreCoarseScaleWAdr:
		status = (asynStatus) getIntegerParam(p_Shell0DspFdbkCoreCoarseScaleW, &valueSet );
		if( (uint32_t)(valueSet & Shell0DspFdbkCoreCoarseScaleMask) == (uint32_t)(pFromFpga->data & Shell0DspFdbkCoreCoarseScaleMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell0DspFdbkCoreCoarseScaleWString, (unsigned ) pFromFpga->data & Shell0DspFdbkCoreCoarseScaleMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Shell0DspFdbkCoreCoarseScaleWString, valueSet & Shell0DspFdbkCoreCoarseScaleMask, (unsigned ) pFromFpga->data & Shell0DspFdbkCoreCoarseScaleMask);
			status = asynError;
			setParamStatus(p_Shell0DspFdbkCoreCoarseScaleW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Shell0DspFdbkCoreMpProcPhOffsetWAdr:
		status = (asynStatus) getIntegerParam(p_Shell0DspFdbkCoreMpProcPhOffsetW, &valueSet );
		if( (uint32_t)(valueSet & Shell0DspFdbkCoreMpProcPhOffsetMask) == (uint32_t)(pFromFpga->data & Shell0DspFdbkCoreMpProcPhOffsetMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell0DspFdbkCoreMpProcPhOffsetWString, (unsigned ) pFromFpga->data & Shell0DspFdbkCoreMpProcPhOffsetMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Shell0DspFdbkCoreMpProcPhOffsetWString, valueSet & Shell0DspFdbkCoreMpProcPhOffsetMask, (unsigned ) pFromFpga->data & Shell0DspFdbkCoreMpProcPhOffsetMask);
			status = asynError;
			setParamStatus(p_Shell0DspFdbkCoreMpProcPhOffsetW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Shell0DspFdbkCoreMpProcSelEnWAdr:
		status = (asynStatus) getIntegerParam(p_Shell0DspFdbkCoreMpProcSelEnW, &valueSet );
		if( (uint32_t)(valueSet & Shell0DspFdbkCoreMpProcSelEnMask) == (uint32_t)(pFromFpga->data & Shell0DspFdbkCoreMpProcSelEnMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell0DspFdbkCoreMpProcSelEnWString, (unsigned ) pFromFpga->data & Shell0DspFdbkCoreMpProcSelEnMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Shell0DspFdbkCoreMpProcSelEnWString, valueSet & Shell0DspFdbkCoreMpProcSelEnMask, (unsigned ) pFromFpga->data & Shell0DspFdbkCoreMpProcSelEnMask);
			status = asynError;
			setParamStatus(p_Shell0DspFdbkCoreMpProcSelEnW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Shell0DspFdbkCoreMpProcSelThreshWAdr:
		status = (asynStatus) getIntegerParam(p_Shell0DspFdbkCoreMpProcSelThreshW, &valueSet );
		if( (uint32_t)(valueSet & Shell0DspFdbkCoreMpProcSelThreshMask) == (uint32_t)(pFromFpga->data & Shell0DspFdbkCoreMpProcSelThreshMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell0DspFdbkCoreMpProcSelThreshWString, (unsigned ) pFromFpga->data & Shell0DspFdbkCoreMpProcSelThreshMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Shell0DspFdbkCoreMpProcSelThreshWString, valueSet & Shell0DspFdbkCoreMpProcSelThreshMask, (unsigned ) pFromFpga->data & Shell0DspFdbkCoreMpProcSelThreshMask);
			status = asynError;
			setParamStatus(p_Shell0DspFdbkCoreMpProcSelThreshW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Shell0DspModuloWAdr:
		status = (asynStatus) getIntegerParam(p_Shell0DspModuloW, &valueSet );
		if( (uint32_t)(valueSet & Shell0DspModuloMask) == (uint32_t)(pFromFpga->data & Shell0DspModuloMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell0DspModuloWString, (unsigned ) pFromFpga->data & Shell0DspModuloMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Shell0DspModuloWString, valueSet & Shell0DspModuloMask, (unsigned ) pFromFpga->data & Shell0DspModuloMask);
			status = asynError;
			setParamStatus(p_Shell0DspModuloW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Shell0DspPhaseStepWAdr:
		status = (asynStatus) getIntegerParam(p_Shell0DspPhaseStepW, &valueSet );
		if( (uint32_t)(valueSet & Shell0DspPhaseStepMask) == (uint32_t)(pFromFpga->data & Shell0DspPhaseStepMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell0DspPhaseStepWString, (unsigned ) pFromFpga->data & Shell0DspPhaseStepMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Shell0DspPhaseStepWString, valueSet & Shell0DspPhaseStepMask, (unsigned ) pFromFpga->data & Shell0DspPhaseStepMask);
			status = asynError;
			setParamStatus(p_Shell0DspPhaseStepW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Shell0DspPiezoPiezoDcWAdr:
		status = (asynStatus) getIntegerParam(p_Shell0DspPiezoPiezoDcW, &valueSet );
		if( (uint32_t)(valueSet & Shell0DspPiezoPiezoDcMask) == (uint32_t)(pFromFpga->data & Shell0DspPiezoPiezoDcMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell0DspPiezoPiezoDcWString, (unsigned ) pFromFpga->data & Shell0DspPiezoPiezoDcMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Shell0DspPiezoPiezoDcWString, valueSet & Shell0DspPiezoPiezoDcMask, (unsigned ) pFromFpga->data & Shell0DspPiezoPiezoDcMask);
			status = asynError;
			setParamStatus(p_Shell0DspPiezoPiezoDcW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Shell0DspTagWAdr:
		status = (asynStatus) getIntegerParam(p_Shell0DspTagW, &valueSet );
		if( (uint32_t)(valueSet & Shell0DspTagMask) == (uint32_t)(pFromFpga->data & Shell0DspTagMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell0DspTagWString, (unsigned ) pFromFpga->data & Shell0DspTagMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Shell0DspTagWString, valueSet & Shell0DspTagMask, (unsigned ) pFromFpga->data & Shell0DspTagMask);
			status = asynError;
			setParamStatus(p_Shell0DspTagW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Shell0DspUseFiberIqWAdr:
		status = (asynStatus) getIntegerParam(p_Shell0DspUseFiberIqW, &valueSet );
		if( (uint32_t)(valueSet & Shell0DspUseFiberIqMask) == (uint32_t)(pFromFpga->data & Shell0DspUseFiberIqMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell0DspUseFiberIqWString, (unsigned ) pFromFpga->data & Shell0DspUseFiberIqMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Shell0DspUseFiberIqWString, valueSet & Shell0DspUseFiberIqMask, (unsigned ) pFromFpga->data & Shell0DspUseFiberIqMask);
			status = asynError;
			setParamStatus(p_Shell0DspUseFiberIqW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Shell0DspWaveSampPerWAdr:
		status = (asynStatus) getIntegerParam(p_Shell0DspWaveSampPerW, &valueSet );
		if( (uint32_t)(valueSet & Shell0DspWaveSampPerMask) == (uint32_t)(pFromFpga->data & Shell0DspWaveSampPerMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell0DspWaveSampPerWString, (unsigned ) pFromFpga->data & Shell0DspWaveSampPerMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Shell0DspWaveSampPerWString, valueSet & Shell0DspWaveSampPerMask, (unsigned ) pFromFpga->data & Shell0DspWaveSampPerMask);
			status = asynError;
			setParamStatus(p_Shell0DspWaveSampPerW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Shell0DspWaveShiftWAdr:
		status = (asynStatus) getIntegerParam(p_Shell0DspWaveShiftW, &valueSet );
		if( (uint32_t)(valueSet & Shell0DspWaveShiftMask) == (uint32_t)(pFromFpga->data & Shell0DspWaveShiftMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell0DspWaveShiftWString, (unsigned ) pFromFpga->data & Shell0DspWaveShiftMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Shell0DspWaveShiftWString, valueSet & Shell0DspWaveShiftMask, (unsigned ) pFromFpga->data & Shell0DspWaveShiftMask);
			status = asynError;
			setParamStatus(p_Shell0DspWaveShiftW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Shell1DspChanKeepWAdr:
		status = (asynStatus) getUIntDigitalParam(p_Shell1DspChanKeepW, &uValueSet , Shell1DspChanKeepMask);
		if( (uint32_t)(uValueSet & Shell1DspChanKeepMask) == (uint32_t)(pFromFpga->data & Shell1DspChanKeepMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell1DspChanKeepWString, (unsigned ) pFromFpga->data & Shell1DspChanKeepMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Shell1DspChanKeepWString, uValueSet & Shell1DspChanKeepMask, (unsigned ) pFromFpga->data & Shell1DspChanKeepMask);
			status = asynError;
			setParamStatus(p_Shell1DspChanKeepW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Shell1DspFdbkCoreCoarseScaleWAdr:
		status = (asynStatus) getIntegerParam(p_Shell1DspFdbkCoreCoarseScaleW, &valueSet );
		if( (uint32_t)(valueSet & Shell1DspFdbkCoreCoarseScaleMask) == (uint32_t)(pFromFpga->data & Shell1DspFdbkCoreCoarseScaleMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell1DspFdbkCoreCoarseScaleWString, (unsigned ) pFromFpga->data & Shell1DspFdbkCoreCoarseScaleMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Shell1DspFdbkCoreCoarseScaleWString, valueSet & Shell1DspFdbkCoreCoarseScaleMask, (unsigned ) pFromFpga->data & Shell1DspFdbkCoreCoarseScaleMask);
			status = asynError;
			setParamStatus(p_Shell1DspFdbkCoreCoarseScaleW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Shell1DspFdbkCoreMpProcPhOffsetWAdr:
		status = (asynStatus) getIntegerParam(p_Shell1DspFdbkCoreMpProcPhOffsetW, &valueSet );
		if( (uint32_t)(valueSet & Shell1DspFdbkCoreMpProcPhOffsetMask) == (uint32_t)(pFromFpga->data & Shell1DspFdbkCoreMpProcPhOffsetMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell1DspFdbkCoreMpProcPhOffsetWString, (unsigned ) pFromFpga->data & Shell1DspFdbkCoreMpProcPhOffsetMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Shell1DspFdbkCoreMpProcPhOffsetWString, valueSet & Shell1DspFdbkCoreMpProcPhOffsetMask, (unsigned ) pFromFpga->data & Shell1DspFdbkCoreMpProcPhOffsetMask);
			status = asynError;
			setParamStatus(p_Shell1DspFdbkCoreMpProcPhOffsetW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Shell1DspFdbkCoreMpProcSelEnWAdr:
		status = (asynStatus) getIntegerParam(p_Shell1DspFdbkCoreMpProcSelEnW, &valueSet );
		if( (uint32_t)(valueSet & Shell1DspFdbkCoreMpProcSelEnMask) == (uint32_t)(pFromFpga->data & Shell1DspFdbkCoreMpProcSelEnMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell1DspFdbkCoreMpProcSelEnWString, (unsigned ) pFromFpga->data & Shell1DspFdbkCoreMpProcSelEnMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Shell1DspFdbkCoreMpProcSelEnWString, valueSet & Shell1DspFdbkCoreMpProcSelEnMask, (unsigned ) pFromFpga->data & Shell1DspFdbkCoreMpProcSelEnMask);
			status = asynError;
			setParamStatus(p_Shell1DspFdbkCoreMpProcSelEnW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Shell1DspFdbkCoreMpProcSelThreshWAdr:
		status = (asynStatus) getIntegerParam(p_Shell1DspFdbkCoreMpProcSelThreshW, &valueSet );
		if( (uint32_t)(valueSet & Shell1DspFdbkCoreMpProcSelThreshMask) == (uint32_t)(pFromFpga->data & Shell1DspFdbkCoreMpProcSelThreshMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell1DspFdbkCoreMpProcSelThreshWString, (unsigned ) pFromFpga->data & Shell1DspFdbkCoreMpProcSelThreshMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Shell1DspFdbkCoreMpProcSelThreshWString, valueSet & Shell1DspFdbkCoreMpProcSelThreshMask, (unsigned ) pFromFpga->data & Shell1DspFdbkCoreMpProcSelThreshMask);
			status = asynError;
			setParamStatus(p_Shell1DspFdbkCoreMpProcSelThreshW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Shell1DspModuloWAdr:
		status = (asynStatus) getIntegerParam(p_Shell1DspModuloW, &valueSet );
		if( (uint32_t)(valueSet & Shell1DspModuloMask) == (uint32_t)(pFromFpga->data & Shell1DspModuloMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell1DspModuloWString, (unsigned ) pFromFpga->data & Shell1DspModuloMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Shell1DspModuloWString, valueSet & Shell1DspModuloMask, (unsigned ) pFromFpga->data & Shell1DspModuloMask);
			status = asynError;
			setParamStatus(p_Shell1DspModuloW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Shell1DspPhaseStepWAdr:
		status = (asynStatus) getIntegerParam(p_Shell1DspPhaseStepW, &valueSet );
		if( (uint32_t)(valueSet & Shell1DspPhaseStepMask) == (uint32_t)(pFromFpga->data & Shell1DspPhaseStepMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell1DspPhaseStepWString, (unsigned ) pFromFpga->data & Shell1DspPhaseStepMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Shell1DspPhaseStepWString, valueSet & Shell1DspPhaseStepMask, (unsigned ) pFromFpga->data & Shell1DspPhaseStepMask);
			status = asynError;
			setParamStatus(p_Shell1DspPhaseStepW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Shell1DspPiezoPiezoDcWAdr:
		status = (asynStatus) getIntegerParam(p_Shell1DspPiezoPiezoDcW, &valueSet );
		if( (uint32_t)(valueSet & Shell1DspPiezoPiezoDcMask) == (uint32_t)(pFromFpga->data & Shell1DspPiezoPiezoDcMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell1DspPiezoPiezoDcWString, (unsigned ) pFromFpga->data & Shell1DspPiezoPiezoDcMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Shell1DspPiezoPiezoDcWString, valueSet & Shell1DspPiezoPiezoDcMask, (unsigned ) pFromFpga->data & Shell1DspPiezoPiezoDcMask);
			status = asynError;
			setParamStatus(p_Shell1DspPiezoPiezoDcW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Shell1DspTagWAdr:
		status = (asynStatus) getIntegerParam(p_Shell1DspTagW, &valueSet );
		if( (uint32_t)(valueSet & Shell1DspTagMask) == (uint32_t)(pFromFpga->data & Shell1DspTagMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell1DspTagWString, (unsigned ) pFromFpga->data & Shell1DspTagMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Shell1DspTagWString, valueSet & Shell1DspTagMask, (unsigned ) pFromFpga->data & Shell1DspTagMask);
			status = asynError;
			setParamStatus(p_Shell1DspTagW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Shell1DspUseFiberIqWAdr:
		status = (asynStatus) getIntegerParam(p_Shell1DspUseFiberIqW, &valueSet );
		if( (uint32_t)(valueSet & Shell1DspUseFiberIqMask) == (uint32_t)(pFromFpga->data & Shell1DspUseFiberIqMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell1DspUseFiberIqWString, (unsigned ) pFromFpga->data & Shell1DspUseFiberIqMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Shell1DspUseFiberIqWString, valueSet & Shell1DspUseFiberIqMask, (unsigned ) pFromFpga->data & Shell1DspUseFiberIqMask);
			status = asynError;
			setParamStatus(p_Shell1DspUseFiberIqW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Shell1DspWaveSampPerWAdr:
		status = (asynStatus) getIntegerParam(p_Shell1DspWaveSampPerW, &valueSet );
		if( (uint32_t)(valueSet & Shell1DspWaveSampPerMask) == (uint32_t)(pFromFpga->data & Shell1DspWaveSampPerMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell1DspWaveSampPerWString, (unsigned ) pFromFpga->data & Shell1DspWaveSampPerMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Shell1DspWaveSampPerWString, valueSet & Shell1DspWaveSampPerMask, (unsigned ) pFromFpga->data & Shell1DspWaveSampPerMask);
			status = asynError;
			setParamStatus(p_Shell1DspWaveSampPerW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Shell1DspWaveShiftWAdr:
		status = (asynStatus) getIntegerParam(p_Shell1DspWaveShiftW, &valueSet );
		if( (uint32_t)(valueSet & Shell1DspWaveShiftMask) == (uint32_t)(pFromFpga->data & Shell1DspWaveShiftMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell1DspWaveShiftWString, (unsigned ) pFromFpga->data & Shell1DspWaveShiftMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Shell1DspWaveShiftWString, valueSet & Shell1DspWaveShiftMask, (unsigned ) pFromFpga->data & Shell1DspWaveShiftMask);
			status = asynError;
			setParamStatus(p_Shell1DspWaveShiftW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case RewindWAdr:
		status = (asynStatus) getIntegerParam(p_RewindW, &valueSet );
		if( (uint32_t)(valueSet & RewindMask) == (uint32_t)(pFromFpga->data & RewindMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				RewindWString, (unsigned ) pFromFpga->data & RewindMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				RewindWString, valueSet & RewindMask, (unsigned ) pFromFpga->data & RewindMask);
			status = asynError;
			setParamStatus(p_RewindW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case SsaStimAmpstepWAdr:
		status = (asynStatus) getIntegerParam(p_SsaStimAmpstepW, &valueSet );
		if( (uint32_t)(valueSet & SsaStimAmpstepMask) == (uint32_t)(pFromFpga->data & SsaStimAmpstepMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				SsaStimAmpstepWString, (unsigned ) pFromFpga->data & SsaStimAmpstepMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				SsaStimAmpstepWString, valueSet & SsaStimAmpstepMask, (unsigned ) pFromFpga->data & SsaStimAmpstepMask);
			status = asynError;
			setParamStatus(p_SsaStimAmpstepW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case SsaStimEnWAdr:
		status = (asynStatus) getIntegerParam(p_SsaStimEnW, &valueSet );
		if( (uint32_t)(valueSet & SsaStimEnMask) == (uint32_t)(pFromFpga->data & SsaStimEnMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				SsaStimEnWString, (unsigned ) pFromFpga->data & SsaStimEnMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				SsaStimEnWString, valueSet & SsaStimEnMask, (unsigned ) pFromFpga->data & SsaStimEnMask);
			status = asynError;
			setParamStatus(p_SsaStimEnW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case SsaStimGPeriodWAdr:
		status = (asynStatus) getIntegerParam(p_SsaStimGPeriodW, &valueSet );
		if( (uint32_t)(valueSet & SsaStimGPeriodMask) == (uint32_t)(pFromFpga->data & SsaStimGPeriodMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				SsaStimGPeriodWString, (unsigned ) pFromFpga->data & SsaStimGPeriodMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				SsaStimGPeriodWString, valueSet & SsaStimGPeriodMask, (unsigned ) pFromFpga->data & SsaStimGPeriodMask);
			status = asynError;
			setParamStatus(p_SsaStimGPeriodW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case SsaStimPertstepWAdr:
		status = (asynStatus) getIntegerParam(p_SsaStimPertstepW, &valueSet );
		if( (uint32_t)(valueSet & SsaStimPertstepMask) == (uint32_t)(pFromFpga->data & SsaStimPertstepMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				SsaStimPertstepWString, (unsigned ) pFromFpga->data & SsaStimPertstepMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				SsaStimPertstepWString, valueSet & SsaStimPertstepMask, (unsigned ) pFromFpga->data & SsaStimPertstepMask);
			status = asynError;
			setParamStatus(p_SsaStimPertstepW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case TraceKeepWAdr:
		status = (asynStatus) getUIntDigitalParam(p_TraceKeepW, &uValueSet , TraceKeepMask);
		if( (uint32_t)(uValueSet & TraceKeepMask) == (uint32_t)(pFromFpga->data & TraceKeepMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				TraceKeepWString, (unsigned ) pFromFpga->data & TraceKeepMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				TraceKeepWString, uValueSet & TraceKeepMask, (unsigned ) pFromFpga->data & TraceKeepMask);
			status = asynError;
			setParamStatus(p_TraceKeepW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case TraceResetWeWAdr:
		status = (asynStatus) getUIntDigitalParam(p_TraceResetWeW, &uValueSet , TraceResetWeMask);
		if( (uint32_t)(uValueSet & TraceResetWeMask) == (uint32_t)(pFromFpga->data & TraceResetWeMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				TraceResetWeWString, (unsigned ) pFromFpga->data & TraceResetWeMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				TraceResetWeWString, uValueSet & TraceResetWeMask, (unsigned ) pFromFpga->data & TraceResetWeMask);
			status = asynError;
			setParamStatus(p_TraceResetWeW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case TrigInternalWAdr:
		status = (asynStatus) getIntegerParam(p_TrigInternalW, &valueSet );
		if( (uint32_t)(valueSet & TrigInternalMask) == (uint32_t)(pFromFpga->data & TrigInternalMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				TrigInternalWString, (unsigned ) pFromFpga->data & TrigInternalMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				TrigInternalWString, valueSet & TrigInternalMask, (unsigned ) pFromFpga->data & TrigInternalMask);
			status = asynError;
			setParamStatus(p_TrigInternalW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case TrigModeWAdr:
		status = (asynStatus) getIntegerParam(p_TrigModeW, &valueSet );
		if( (uint32_t)(valueSet & TrigModeMask) == (uint32_t)(pFromFpga->data & TrigModeMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				TrigModeWString, (unsigned ) pFromFpga->data & TrigModeMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				TrigModeWString, valueSet & TrigModeMask, (unsigned ) pFromFpga->data & TrigModeMask);
			status = asynError;
			setParamStatus(p_TrigModeW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Wave0SrcWAdr:
		status = (asynStatus) getIntegerParam(p_Wave0SrcW, &valueSet );
		if( (uint32_t)(valueSet & Wave0SrcMask) == (uint32_t)(pFromFpga->data & Wave0SrcMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Wave0SrcWString, (unsigned ) pFromFpga->data & Wave0SrcMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Wave0SrcWString, valueSet & Wave0SrcMask, (unsigned ) pFromFpga->data & Wave0SrcMask);
			status = asynError;
			setParamStatus(p_Wave0SrcW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Wave1SrcWAdr:
		status = (asynStatus) getIntegerParam(p_Wave1SrcW, &valueSet );
		if( (uint32_t)(valueSet & Wave1SrcMask) == (uint32_t)(pFromFpga->data & Wave1SrcMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Wave1SrcWString, (unsigned ) pFromFpga->data & Wave1SrcMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Wave1SrcWString, valueSet & Wave1SrcMask, (unsigned ) pFromFpga->data & Wave1SrcMask);
			status = asynError;
			setParamStatus(p_Wave1SrcW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case DomainJumpRealignWAdr:
		status = (asynStatus) getIntegerParam(p_DomainJumpRealignW, &valueSet );
		if( (uint32_t)(valueSet & DomainJumpRealignMask) == (uint32_t)(pFromFpga->data & DomainJumpRealignMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DomainJumpRealignWString, (unsigned ) pFromFpga->data & DomainJumpRealignMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				DomainJumpRealignWString, valueSet & DomainJumpRealignMask, (unsigned ) pFromFpga->data & DomainJumpRealignMask);
			status = asynError;
			setParamStatus(p_DomainJumpRealignW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case IccCfgWAdr:
		status = (asynStatus) getIntegerParam(p_IccCfgW, &valueSet );
		if( (uint32_t)(valueSet & IccCfgMask) == (uint32_t)(pFromFpga->data & IccCfgMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				IccCfgWString, (unsigned ) pFromFpga->data & IccCfgMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				IccCfgWString, valueSet & IccCfgMask, (unsigned ) pFromFpga->data & IccCfgMask);
			status = asynError;
			setParamStatus(p_IccCfgW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case QsfpI2CRegWAdr:
		status = (asynStatus) getIntegerParam(p_QsfpI2CRegW, &valueSet );
		if( (uint32_t)(valueSet & QsfpI2CRegMask) == (uint32_t)(pFromFpga->data & QsfpI2CRegMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				QsfpI2CRegWString, (unsigned ) pFromFpga->data & QsfpI2CRegMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				QsfpI2CRegWString, valueSet & QsfpI2CRegMask, (unsigned ) pFromFpga->data & QsfpI2CRegMask);
			status = asynError;
			setParamStatus(p_QsfpI2CRegW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case SfpAddressSetWAdr:
		status = (asynStatus) getIntegerParam(p_SfpAddressSetW, &valueSet );
		if( (uint32_t)(valueSet & SfpAddressSetMask) == (uint32_t)(pFromFpga->data & SfpAddressSetMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				SfpAddressSetWString, (unsigned ) pFromFpga->data & SfpAddressSetMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				SfpAddressSetWString, valueSet & SfpAddressSetMask, (unsigned ) pFromFpga->data & SfpAddressSetMask);
			status = asynError;
			setParamStatus(p_SfpAddressSetW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case TagNowWAdr:
		status = (asynStatus) getIntegerParam(p_TagNowW, &valueSet );
		if( (uint32_t)(valueSet & TagNowMask) == (uint32_t)(pFromFpga->data & TagNowMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				TagNowWString, (unsigned ) pFromFpga->data & TagNowMask);
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				TagNowWString, valueSet & TagNowMask, (unsigned ) pFromFpga->data & TagNowMask);
			status = asynError;
			setParamStatus(p_TagNowW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
	default:
		// Arrays larger than 16 elements should be handled in a subclass, generally more complicated
		if ((pFromFpga->addr >= Shell0DspPiezoSfConstsWAdr) &&
				(pFromFpga->addr < (Shell0DspPiezoSfConstsWAdr + 8)))
		{
			status = (asynStatus) getIntegerParam((pFromFpga->addr - Shell0DspPiezoSfConstsWAdr),
					p_Shell0DspPiezoSfConstsW, &valueSet);
			if( (valueSet & TagNowMask) == (pFromFpga->data & TagNowMask))
				asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
					"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
					Shell0DspPiezoSfConstsWString, (pFromFpga->addr - Shell0DspPiezoSfConstsWAdr), (unsigned ) pFromFpga->data & TagNowMask);
			else
			{
				asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
					"%s: value sent to %s, channel %u, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
					Shell0DspPiezoSfConstsWString, (pFromFpga->addr - Shell0DspPiezoSfConstsWAdr), valueSet & TagNowMask, (unsigned ) pFromFpga->data & TagNowMask);
				status = asynError;
				setParamStatus(p_Shell0DspPiezoSfConstsW, status);
				getIntegerParam(p_CommErrorCount, &errorCount);
				setIntegerParam(p_CommErrorCount, ++errorCount);
			}


		}
		else
		if ((pFromFpga->addr >= Shell1DspPiezoSfConstsWAdr) &&
				(pFromFpga->addr < (Shell1DspPiezoSfConstsWAdr + 8)))
		{
			status = (asynStatus) getIntegerParam((pFromFpga->addr - Shell1DspPiezoSfConstsWAdr),
					p_Shell1DspPiezoSfConstsW, &valueSet);
			if( (valueSet & TagNowMask) == (pFromFpga->data & TagNowMask))
				asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
					"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
					Shell1DspPiezoSfConstsWString, (pFromFpga->addr - Shell1DspPiezoSfConstsWAdr), (unsigned ) pFromFpga->data & TagNowMask);
			else
			{
				asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
					"%s: value sent to %s, channel %u, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
					Shell1DspPiezoSfConstsWString, (pFromFpga->addr - Shell1DspPiezoSfConstsWAdr), valueSet & TagNowMask, (unsigned ) pFromFpga->data & TagNowMask);
				status = asynError;
				setParamStatus(p_Shell1DspPiezoSfConstsW, status);
				getIntegerParam(p_CommErrorCount, &errorCount);
				setIntegerParam(p_CommErrorCount, ++errorCount);
			}


		}
		else
		if ((pFromFpga->addr >= Shell0DspFdbkCoreMpProcCoeffWAdr) &&
				(pFromFpga->addr < (Shell0DspFdbkCoreMpProcCoeffWAdr + 4)))
		{
			status = (asynStatus) getIntegerParam((pFromFpga->addr - Shell0DspFdbkCoreMpProcCoeffWAdr),
					p_Shell0DspFdbkCoreMpProcCoeffW, &valueSet);
			if( (valueSet & TagNowMask) == (pFromFpga->data & TagNowMask))
				asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
					"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
					Shell0DspFdbkCoreMpProcCoeffWString, (pFromFpga->addr - Shell0DspFdbkCoreMpProcCoeffWAdr), (unsigned ) pFromFpga->data & TagNowMask);
			else
			{
				asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
					"%s: value sent to %s, channel %u, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
					Shell0DspFdbkCoreMpProcCoeffWString, (pFromFpga->addr - Shell0DspFdbkCoreMpProcCoeffWAdr), valueSet & TagNowMask, (unsigned ) pFromFpga->data & TagNowMask);
				status = asynError;
				setParamStatus(p_Shell0DspFdbkCoreMpProcCoeffW, status);
				getIntegerParam(p_CommErrorCount, &errorCount);
				setIntegerParam(p_CommErrorCount, ++errorCount);
			}


		}
		else
		if ((pFromFpga->addr >= Shell0DspFdbkCoreMpProcLimWAdr) &&
				(pFromFpga->addr < (Shell0DspFdbkCoreMpProcLimWAdr + 4)))
		{
			status = (asynStatus) getIntegerParam((pFromFpga->addr - Shell0DspFdbkCoreMpProcLimWAdr),
					p_Shell0DspFdbkCoreMpProcLimW, &valueSet);
			if( (valueSet & TagNowMask) == (pFromFpga->data & TagNowMask))
				asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
					"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
					Shell0DspFdbkCoreMpProcLimWString, (pFromFpga->addr - Shell0DspFdbkCoreMpProcLimWAdr), (unsigned ) pFromFpga->data & TagNowMask);
			else
			{
				asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
					"%s: value sent to %s, channel %u, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
					Shell0DspFdbkCoreMpProcLimWString, (pFromFpga->addr - Shell0DspFdbkCoreMpProcLimWAdr), valueSet & TagNowMask, (unsigned ) pFromFpga->data & TagNowMask);
				status = asynError;
				setParamStatus(p_Shell0DspFdbkCoreMpProcLimW, status);
				getIntegerParam(p_CommErrorCount, &errorCount);
				setIntegerParam(p_CommErrorCount, ++errorCount);
			}


		}
		else
		if ((pFromFpga->addr >= Shell0DspFdbkCoreMpProcSetmpWAdr) &&
				(pFromFpga->addr < (Shell0DspFdbkCoreMpProcSetmpWAdr + 4)))
		{
			status = (asynStatus) getIntegerParam((pFromFpga->addr - Shell0DspFdbkCoreMpProcSetmpWAdr),
					p_Shell0DspFdbkCoreMpProcSetmpW, &valueSet);
			if( (valueSet & TagNowMask) == (pFromFpga->data & TagNowMask))
				asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
					"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
					Shell0DspFdbkCoreMpProcSetmpWString, (pFromFpga->addr - Shell0DspFdbkCoreMpProcSetmpWAdr), (unsigned ) pFromFpga->data & TagNowMask);
			else
			{
				asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
					"%s: value sent to %s, channel %u, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
					Shell0DspFdbkCoreMpProcSetmpWString, (pFromFpga->addr - Shell0DspFdbkCoreMpProcSetmpWAdr), valueSet & TagNowMask, (unsigned ) pFromFpga->data & TagNowMask);
				status = asynError;
				setParamStatus(p_Shell0DspFdbkCoreMpProcSetmpW, status);
				getIntegerParam(p_CommErrorCount, &errorCount);
				setIntegerParam(p_CommErrorCount, ++errorCount);
			}


		}
		else
		if ((pFromFpga->addr >= Shell1DspFdbkCoreMpProcCoeffWAdr) &&
				(pFromFpga->addr < (Shell1DspFdbkCoreMpProcCoeffWAdr + 4)))
		{
			status = (asynStatus) getIntegerParam((pFromFpga->addr - Shell1DspFdbkCoreMpProcCoeffWAdr),
					p_Shell1DspFdbkCoreMpProcCoeffW, &valueSet);
			if( (valueSet & TagNowMask) == (pFromFpga->data & TagNowMask))
				asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
					"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
					Shell1DspFdbkCoreMpProcCoeffWString, (pFromFpga->addr - Shell1DspFdbkCoreMpProcCoeffWAdr), (unsigned ) pFromFpga->data & TagNowMask);
			else
			{
				asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
					"%s: value sent to %s, channel %u, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
					Shell1DspFdbkCoreMpProcCoeffWString, (pFromFpga->addr - Shell1DspFdbkCoreMpProcCoeffWAdr), valueSet & TagNowMask, (unsigned ) pFromFpga->data & TagNowMask);
				status = asynError;
				setParamStatus(p_Shell1DspFdbkCoreMpProcCoeffW, status);
				getIntegerParam(p_CommErrorCount, &errorCount);
				setIntegerParam(p_CommErrorCount, ++errorCount);
			}


		}
		else
		if ((pFromFpga->addr >= Shell1DspFdbkCoreMpProcLimWAdr) &&
				(pFromFpga->addr < (Shell1DspFdbkCoreMpProcLimWAdr + 4)))
		{
			status = (asynStatus) getIntegerParam((pFromFpga->addr - Shell1DspFdbkCoreMpProcLimWAdr),
					p_Shell1DspFdbkCoreMpProcLimW, &valueSet);
			if( (valueSet & TagNowMask) == (pFromFpga->data & TagNowMask))
				asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
					"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
					Shell1DspFdbkCoreMpProcLimWString, (pFromFpga->addr - Shell1DspFdbkCoreMpProcLimWAdr), (unsigned ) pFromFpga->data & TagNowMask);
			else
			{
				asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
					"%s: value sent to %s, channel %u, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
					Shell1DspFdbkCoreMpProcLimWString, (pFromFpga->addr - Shell1DspFdbkCoreMpProcLimWAdr), valueSet & TagNowMask, (unsigned ) pFromFpga->data & TagNowMask);
				status = asynError;
				setParamStatus(p_Shell1DspFdbkCoreMpProcLimW, status);
				getIntegerParam(p_CommErrorCount, &errorCount);
				setIntegerParam(p_CommErrorCount, ++errorCount);
			}


		}
		else
		if ((pFromFpga->addr >= Shell1DspFdbkCoreMpProcSetmpWAdr) &&
				(pFromFpga->addr < (Shell1DspFdbkCoreMpProcSetmpWAdr + 4)))
		{
			status = (asynStatus) getIntegerParam((pFromFpga->addr - Shell1DspFdbkCoreMpProcSetmpWAdr),
					p_Shell1DspFdbkCoreMpProcSetmpW, &valueSet);
			if( (valueSet & TagNowMask) == (pFromFpga->data & TagNowMask))
				asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
					"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
					Shell1DspFdbkCoreMpProcSetmpWString, (pFromFpga->addr - Shell1DspFdbkCoreMpProcSetmpWAdr), (unsigned ) pFromFpga->data & TagNowMask);
			else
			{
				asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
					"%s: value sent to %s, channel %u, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
					Shell1DspFdbkCoreMpProcSetmpWString, (pFromFpga->addr - Shell1DspFdbkCoreMpProcSetmpWAdr), valueSet & TagNowMask, (unsigned ) pFromFpga->data & TagNowMask);
				status = asynError;
				setParamStatus(p_Shell1DspFdbkCoreMpProcSetmpW, status);
				getIntegerParam(p_CommErrorCount, &errorCount);
				setIntegerParam(p_CommErrorCount, ++errorCount);
			}


		}
		else
		if ((pFromFpga->addr >= Cavity0DriveCoupleOutCouplingWAdr) &&
				(pFromFpga->addr < (Cavity0DriveCoupleOutCouplingWAdr + 2)))
		{
			status = (asynStatus) getIntegerParam((pFromFpga->addr - Cavity0DriveCoupleOutCouplingWAdr),
					p_Cavity0DriveCoupleOutCouplingW, &valueSet);
			if( (valueSet & TagNowMask) == (pFromFpga->data & TagNowMask))
				asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
					"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
					Cavity0DriveCoupleOutCouplingWString, (pFromFpga->addr - Cavity0DriveCoupleOutCouplingWAdr), (unsigned ) pFromFpga->data & TagNowMask);
			else
			{
				asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
					"%s: value sent to %s, channel %u, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
					Cavity0DriveCoupleOutCouplingWString, (pFromFpga->addr - Cavity0DriveCoupleOutCouplingWAdr), valueSet & TagNowMask, (unsigned ) pFromFpga->data & TagNowMask);
				status = asynError;
				setParamStatus(p_Cavity0DriveCoupleOutCouplingW, status);
				getIntegerParam(p_CommErrorCount, &errorCount);
				setIntegerParam(p_CommErrorCount, ++errorCount);
			}


		}
		else
		if ((pFromFpga->addr >= Cavity0DriveCoupleOutPhaseOffsetWAdr) &&
				(pFromFpga->addr < (Cavity0DriveCoupleOutPhaseOffsetWAdr + 2)))
		{
			status = (asynStatus) getIntegerParam((pFromFpga->addr - Cavity0DriveCoupleOutPhaseOffsetWAdr),
					p_Cavity0DriveCoupleOutPhaseOffsetW, &valueSet);
			if( (valueSet & TagNowMask) == (pFromFpga->data & TagNowMask))
				asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
					"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
					Cavity0DriveCoupleOutPhaseOffsetWString, (pFromFpga->addr - Cavity0DriveCoupleOutPhaseOffsetWAdr), (unsigned ) pFromFpga->data & TagNowMask);
			else
			{
				asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
					"%s: value sent to %s, channel %u, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
					Cavity0DriveCoupleOutPhaseOffsetWString, (pFromFpga->addr - Cavity0DriveCoupleOutPhaseOffsetWAdr), valueSet & TagNowMask, (unsigned ) pFromFpga->data & TagNowMask);
				status = asynError;
				setParamStatus(p_Cavity0DriveCoupleOutPhaseOffsetW, status);
				getIntegerParam(p_CommErrorCount, &errorCount);
				setIntegerParam(p_CommErrorCount, ++errorCount);
			}


		}
		else
		if ((pFromFpga->addr >= Cavity0Mode0CoupleOutCouplingWAdr) &&
				(pFromFpga->addr < (Cavity0Mode0CoupleOutCouplingWAdr + 2)))
		{
			status = (asynStatus) getIntegerParam((pFromFpga->addr - Cavity0Mode0CoupleOutCouplingWAdr),
					p_Cavity0Mode0CoupleOutCouplingW, &valueSet);
			if( (valueSet & TagNowMask) == (pFromFpga->data & TagNowMask))
				asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
					"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
					Cavity0Mode0CoupleOutCouplingWString, (pFromFpga->addr - Cavity0Mode0CoupleOutCouplingWAdr), (unsigned ) pFromFpga->data & TagNowMask);
			else
			{
				asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
					"%s: value sent to %s, channel %u, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
					Cavity0Mode0CoupleOutCouplingWString, (pFromFpga->addr - Cavity0Mode0CoupleOutCouplingWAdr), valueSet & TagNowMask, (unsigned ) pFromFpga->data & TagNowMask);
				status = asynError;
				setParamStatus(p_Cavity0Mode0CoupleOutCouplingW, status);
				getIntegerParam(p_CommErrorCount, &errorCount);
				setIntegerParam(p_CommErrorCount, ++errorCount);
			}


		}
		else
		if ((pFromFpga->addr >= Cavity0Mode0CoupleOutPhaseOffsetWAdr) &&
				(pFromFpga->addr < (Cavity0Mode0CoupleOutPhaseOffsetWAdr + 2)))
		{
			status = (asynStatus) getIntegerParam((pFromFpga->addr - Cavity0Mode0CoupleOutPhaseOffsetWAdr),
					p_Cavity0Mode0CoupleOutPhaseOffsetW, &valueSet);
			if( (valueSet & TagNowMask) == (pFromFpga->data & TagNowMask))
				asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
					"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
					Cavity0Mode0CoupleOutPhaseOffsetWString, (pFromFpga->addr - Cavity0Mode0CoupleOutPhaseOffsetWAdr), (unsigned ) pFromFpga->data & TagNowMask);
			else
			{
				asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
					"%s: value sent to %s, channel %u, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
					Cavity0Mode0CoupleOutPhaseOffsetWString, (pFromFpga->addr - Cavity0Mode0CoupleOutPhaseOffsetWAdr), valueSet & TagNowMask, (unsigned ) pFromFpga->data & TagNowMask);
				status = asynError;
				setParamStatus(p_Cavity0Mode0CoupleOutPhaseOffsetW, status);
				getIntegerParam(p_CommErrorCount, &errorCount);
				setIntegerParam(p_CommErrorCount, ++errorCount);
			}


		}
		else
		if ((pFromFpga->addr >= Cavity0Mode1CoupleOutCouplingWAdr) &&
				(pFromFpga->addr < (Cavity0Mode1CoupleOutCouplingWAdr + 2)))
		{
			status = (asynStatus) getIntegerParam((pFromFpga->addr - Cavity0Mode1CoupleOutCouplingWAdr),
					p_Cavity0Mode1CoupleOutCouplingW, &valueSet);
			if( (valueSet & TagNowMask) == (pFromFpga->data & TagNowMask))
				asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
					"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
					Cavity0Mode1CoupleOutCouplingWString, (pFromFpga->addr - Cavity0Mode1CoupleOutCouplingWAdr), (unsigned ) pFromFpga->data & TagNowMask);
			else
			{
				asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
					"%s: value sent to %s, channel %u, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
					Cavity0Mode1CoupleOutCouplingWString, (pFromFpga->addr - Cavity0Mode1CoupleOutCouplingWAdr), valueSet & TagNowMask, (unsigned ) pFromFpga->data & TagNowMask);
				status = asynError;
				setParamStatus(p_Cavity0Mode1CoupleOutCouplingW, status);
				getIntegerParam(p_CommErrorCount, &errorCount);
				setIntegerParam(p_CommErrorCount, ++errorCount);
			}


		}
		else
		if ((pFromFpga->addr >= Cavity0Mode1CoupleOutPhaseOffsetWAdr) &&
				(pFromFpga->addr < (Cavity0Mode1CoupleOutPhaseOffsetWAdr + 2)))
		{
			status = (asynStatus) getIntegerParam((pFromFpga->addr - Cavity0Mode1CoupleOutPhaseOffsetWAdr),
					p_Cavity0Mode1CoupleOutPhaseOffsetW, &valueSet);
			if( (valueSet & TagNowMask) == (pFromFpga->data & TagNowMask))
				asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
					"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
					Cavity0Mode1CoupleOutPhaseOffsetWString, (pFromFpga->addr - Cavity0Mode1CoupleOutPhaseOffsetWAdr), (unsigned ) pFromFpga->data & TagNowMask);
			else
			{
				asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
					"%s: value sent to %s, channel %u, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
					Cavity0Mode1CoupleOutPhaseOffsetWString, (pFromFpga->addr - Cavity0Mode1CoupleOutPhaseOffsetWAdr), valueSet & TagNowMask, (unsigned ) pFromFpga->data & TagNowMask);
				status = asynError;
				setParamStatus(p_Cavity0Mode1CoupleOutPhaseOffsetW, status);
				getIntegerParam(p_CommErrorCount, &errorCount);
				setIntegerParam(p_CommErrorCount, ++errorCount);
			}


		}
		else
		if ((pFromFpga->addr >= Cavity0Mode2CoupleOutCouplingWAdr) &&
				(pFromFpga->addr < (Cavity0Mode2CoupleOutCouplingWAdr + 2)))
		{
			status = (asynStatus) getIntegerParam((pFromFpga->addr - Cavity0Mode2CoupleOutCouplingWAdr),
					p_Cavity0Mode2CoupleOutCouplingW, &valueSet);
			if( (valueSet & TagNowMask) == (pFromFpga->data & TagNowMask))
				asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
					"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
					Cavity0Mode2CoupleOutCouplingWString, (pFromFpga->addr - Cavity0Mode2CoupleOutCouplingWAdr), (unsigned ) pFromFpga->data & TagNowMask);
			else
			{
				asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
					"%s: value sent to %s, channel %u, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
					Cavity0Mode2CoupleOutCouplingWString, (pFromFpga->addr - Cavity0Mode2CoupleOutCouplingWAdr), valueSet & TagNowMask, (unsigned ) pFromFpga->data & TagNowMask);
				status = asynError;
				setParamStatus(p_Cavity0Mode2CoupleOutCouplingW, status);
				getIntegerParam(p_CommErrorCount, &errorCount);
				setIntegerParam(p_CommErrorCount, ++errorCount);
			}


		}
		else
		if ((pFromFpga->addr >= Cavity0Mode2CoupleOutPhaseOffsetWAdr) &&
				(pFromFpga->addr < (Cavity0Mode2CoupleOutPhaseOffsetWAdr + 2)))
		{
			status = (asynStatus) getIntegerParam((pFromFpga->addr - Cavity0Mode2CoupleOutPhaseOffsetWAdr),
					p_Cavity0Mode2CoupleOutPhaseOffsetW, &valueSet);
			if( (valueSet & TagNowMask) == (pFromFpga->data & TagNowMask))
				asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
					"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
					Cavity0Mode2CoupleOutPhaseOffsetWString, (pFromFpga->addr - Cavity0Mode2CoupleOutPhaseOffsetWAdr), (unsigned ) pFromFpga->data & TagNowMask);
			else
			{
				asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
					"%s: value sent to %s, channel %u, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
					Cavity0Mode2CoupleOutPhaseOffsetWString, (pFromFpga->addr - Cavity0Mode2CoupleOutPhaseOffsetWAdr), valueSet & TagNowMask, (unsigned ) pFromFpga->data & TagNowMask);
				status = asynError;
				setParamStatus(p_Cavity0Mode2CoupleOutPhaseOffsetW, status);
				getIntegerParam(p_CommErrorCount, &errorCount);
				setIntegerParam(p_CommErrorCount, ++errorCount);
			}


		}
		else
		if ((pFromFpga->addr >= Cavity1DriveCoupleOutCouplingWAdr) &&
				(pFromFpga->addr < (Cavity1DriveCoupleOutCouplingWAdr + 2)))
		{
			status = (asynStatus) getIntegerParam((pFromFpga->addr - Cavity1DriveCoupleOutCouplingWAdr),
					p_Cavity1DriveCoupleOutCouplingW, &valueSet);
			if( (valueSet & TagNowMask) == (pFromFpga->data & TagNowMask))
				asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
					"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
					Cavity1DriveCoupleOutCouplingWString, (pFromFpga->addr - Cavity1DriveCoupleOutCouplingWAdr), (unsigned ) pFromFpga->data & TagNowMask);
			else
			{
				asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
					"%s: value sent to %s, channel %u, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
					Cavity1DriveCoupleOutCouplingWString, (pFromFpga->addr - Cavity1DriveCoupleOutCouplingWAdr), valueSet & TagNowMask, (unsigned ) pFromFpga->data & TagNowMask);
				status = asynError;
				setParamStatus(p_Cavity1DriveCoupleOutCouplingW, status);
				getIntegerParam(p_CommErrorCount, &errorCount);
				setIntegerParam(p_CommErrorCount, ++errorCount);
			}


		}
		else
		if ((pFromFpga->addr >= Cavity1DriveCoupleOutPhaseOffsetWAdr) &&
				(pFromFpga->addr < (Cavity1DriveCoupleOutPhaseOffsetWAdr + 2)))
		{
			status = (asynStatus) getIntegerParam((pFromFpga->addr - Cavity1DriveCoupleOutPhaseOffsetWAdr),
					p_Cavity1DriveCoupleOutPhaseOffsetW, &valueSet);
			if( (valueSet & TagNowMask) == (pFromFpga->data & TagNowMask))
				asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
					"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
					Cavity1DriveCoupleOutPhaseOffsetWString, (pFromFpga->addr - Cavity1DriveCoupleOutPhaseOffsetWAdr), (unsigned ) pFromFpga->data & TagNowMask);
			else
			{
				asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
					"%s: value sent to %s, channel %u, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
					Cavity1DriveCoupleOutPhaseOffsetWString, (pFromFpga->addr - Cavity1DriveCoupleOutPhaseOffsetWAdr), valueSet & TagNowMask, (unsigned ) pFromFpga->data & TagNowMask);
				status = asynError;
				setParamStatus(p_Cavity1DriveCoupleOutPhaseOffsetW, status);
				getIntegerParam(p_CommErrorCount, &errorCount);
				setIntegerParam(p_CommErrorCount, ++errorCount);
			}


		}
		else
		if ((pFromFpga->addr >= Cavity1Mode0CoupleOutCouplingWAdr) &&
				(pFromFpga->addr < (Cavity1Mode0CoupleOutCouplingWAdr + 2)))
		{
			status = (asynStatus) getIntegerParam((pFromFpga->addr - Cavity1Mode0CoupleOutCouplingWAdr),
					p_Cavity1Mode0CoupleOutCouplingW, &valueSet);
			if( (valueSet & TagNowMask) == (pFromFpga->data & TagNowMask))
				asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
					"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
					Cavity1Mode0CoupleOutCouplingWString, (pFromFpga->addr - Cavity1Mode0CoupleOutCouplingWAdr), (unsigned ) pFromFpga->data & TagNowMask);
			else
			{
				asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
					"%s: value sent to %s, channel %u, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
					Cavity1Mode0CoupleOutCouplingWString, (pFromFpga->addr - Cavity1Mode0CoupleOutCouplingWAdr), valueSet & TagNowMask, (unsigned ) pFromFpga->data & TagNowMask);
				status = asynError;
				setParamStatus(p_Cavity1Mode0CoupleOutCouplingW, status);
				getIntegerParam(p_CommErrorCount, &errorCount);
				setIntegerParam(p_CommErrorCount, ++errorCount);
			}


		}
		else
		if ((pFromFpga->addr >= Cavity1Mode0CoupleOutPhaseOffsetWAdr) &&
				(pFromFpga->addr < (Cavity1Mode0CoupleOutPhaseOffsetWAdr + 2)))
		{
			status = (asynStatus) getIntegerParam((pFromFpga->addr - Cavity1Mode0CoupleOutPhaseOffsetWAdr),
					p_Cavity1Mode0CoupleOutPhaseOffsetW, &valueSet);
			if( (valueSet & TagNowMask) == (pFromFpga->data & TagNowMask))
				asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
					"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
					Cavity1Mode0CoupleOutPhaseOffsetWString, (pFromFpga->addr - Cavity1Mode0CoupleOutPhaseOffsetWAdr), (unsigned ) pFromFpga->data & TagNowMask);
			else
			{
				asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
					"%s: value sent to %s, channel %u, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
					Cavity1Mode0CoupleOutPhaseOffsetWString, (pFromFpga->addr - Cavity1Mode0CoupleOutPhaseOffsetWAdr), valueSet & TagNowMask, (unsigned ) pFromFpga->data & TagNowMask);
				status = asynError;
				setParamStatus(p_Cavity1Mode0CoupleOutPhaseOffsetW, status);
				getIntegerParam(p_CommErrorCount, &errorCount);
				setIntegerParam(p_CommErrorCount, ++errorCount);
			}


		}
		else
		if ((pFromFpga->addr >= Cavity1Mode1CoupleOutCouplingWAdr) &&
				(pFromFpga->addr < (Cavity1Mode1CoupleOutCouplingWAdr + 2)))
		{
			status = (asynStatus) getIntegerParam((pFromFpga->addr - Cavity1Mode1CoupleOutCouplingWAdr),
					p_Cavity1Mode1CoupleOutCouplingW, &valueSet);
			if( (valueSet & TagNowMask) == (pFromFpga->data & TagNowMask))
				asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
					"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
					Cavity1Mode1CoupleOutCouplingWString, (pFromFpga->addr - Cavity1Mode1CoupleOutCouplingWAdr), (unsigned ) pFromFpga->data & TagNowMask);
			else
			{
				asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
					"%s: value sent to %s, channel %u, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
					Cavity1Mode1CoupleOutCouplingWString, (pFromFpga->addr - Cavity1Mode1CoupleOutCouplingWAdr), valueSet & TagNowMask, (unsigned ) pFromFpga->data & TagNowMask);
				status = asynError;
				setParamStatus(p_Cavity1Mode1CoupleOutCouplingW, status);
				getIntegerParam(p_CommErrorCount, &errorCount);
				setIntegerParam(p_CommErrorCount, ++errorCount);
			}


		}
		else
		if ((pFromFpga->addr >= Cavity1Mode1CoupleOutPhaseOffsetWAdr) &&
				(pFromFpga->addr < (Cavity1Mode1CoupleOutPhaseOffsetWAdr + 2)))
		{
			status = (asynStatus) getIntegerParam((pFromFpga->addr - Cavity1Mode1CoupleOutPhaseOffsetWAdr),
					p_Cavity1Mode1CoupleOutPhaseOffsetW, &valueSet);
			if( (valueSet & TagNowMask) == (pFromFpga->data & TagNowMask))
				asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
					"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
					Cavity1Mode1CoupleOutPhaseOffsetWString, (pFromFpga->addr - Cavity1Mode1CoupleOutPhaseOffsetWAdr), (unsigned ) pFromFpga->data & TagNowMask);
			else
			{
				asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
					"%s: value sent to %s, channel %u, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
					Cavity1Mode1CoupleOutPhaseOffsetWString, (pFromFpga->addr - Cavity1Mode1CoupleOutPhaseOffsetWAdr), valueSet & TagNowMask, (unsigned ) pFromFpga->data & TagNowMask);
				status = asynError;
				setParamStatus(p_Cavity1Mode1CoupleOutPhaseOffsetW, status);
				getIntegerParam(p_CommErrorCount, &errorCount);
				setIntegerParam(p_CommErrorCount, ++errorCount);
			}


		}
		else
		if ((pFromFpga->addr >= Cavity1Mode2CoupleOutCouplingWAdr) &&
				(pFromFpga->addr < (Cavity1Mode2CoupleOutCouplingWAdr + 2)))
		{
			status = (asynStatus) getIntegerParam((pFromFpga->addr - Cavity1Mode2CoupleOutCouplingWAdr),
					p_Cavity1Mode2CoupleOutCouplingW, &valueSet);
			if( (valueSet & TagNowMask) == (pFromFpga->data & TagNowMask))
				asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
					"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
					Cavity1Mode2CoupleOutCouplingWString, (pFromFpga->addr - Cavity1Mode2CoupleOutCouplingWAdr), (unsigned ) pFromFpga->data & TagNowMask);
			else
			{
				asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
					"%s: value sent to %s, channel %u, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
					Cavity1Mode2CoupleOutCouplingWString, (pFromFpga->addr - Cavity1Mode2CoupleOutCouplingWAdr), valueSet & TagNowMask, (unsigned ) pFromFpga->data & TagNowMask);
				status = asynError;
				setParamStatus(p_Cavity1Mode2CoupleOutCouplingW, status);
				getIntegerParam(p_CommErrorCount, &errorCount);
				setIntegerParam(p_CommErrorCount, ++errorCount);
			}


		}
		else
		if ((pFromFpga->addr >= Cavity1Mode2CoupleOutPhaseOffsetWAdr) &&
				(pFromFpga->addr < (Cavity1Mode2CoupleOutPhaseOffsetWAdr + 2)))
		{
			status = (asynStatus) getIntegerParam((pFromFpga->addr - Cavity1Mode2CoupleOutPhaseOffsetWAdr),
					p_Cavity1Mode2CoupleOutPhaseOffsetW, &valueSet);
			if( (valueSet & TagNowMask) == (pFromFpga->data & TagNowMask))
				asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
					"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
					Cavity1Mode2CoupleOutPhaseOffsetWString, (pFromFpga->addr - Cavity1Mode2CoupleOutPhaseOffsetWAdr), (unsigned ) pFromFpga->data & TagNowMask);
			else
			{
				asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
					"%s: value sent to %s, channel %u, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
					Cavity1Mode2CoupleOutPhaseOffsetWString, (pFromFpga->addr - Cavity1Mode2CoupleOutPhaseOffsetWAdr), valueSet & TagNowMask, (unsigned ) pFromFpga->data & TagNowMask);
				status = asynError;
				setParamStatus(p_Cavity1Mode2CoupleOutPhaseOffsetW, status);
				getIntegerParam(p_CommErrorCount, &errorCount);
				setIntegerParam(p_CommErrorCount, ++errorCount);
			}


		}
		else
		if ((pFromFpga->addr >= Shell0DspLpNotchLp1AKxWAdr) &&
				(pFromFpga->addr < (Shell0DspLpNotchLp1AKxWAdr + 2)))
		{
			status = (asynStatus) getIntegerParam((pFromFpga->addr - Shell0DspLpNotchLp1AKxWAdr),
					p_Shell0DspLpNotchLp1AKxW, &valueSet);
			if( (valueSet & TagNowMask) == (pFromFpga->data & TagNowMask))
				asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
					"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
					Shell0DspLpNotchLp1AKxWString, (pFromFpga->addr - Shell0DspLpNotchLp1AKxWAdr), (unsigned ) pFromFpga->data & TagNowMask);
			else
			{
				asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
					"%s: value sent to %s, channel %u, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
					Shell0DspLpNotchLp1AKxWString, (pFromFpga->addr - Shell0DspLpNotchLp1AKxWAdr), valueSet & TagNowMask, (unsigned ) pFromFpga->data & TagNowMask);
				status = asynError;
				setParamStatus(p_Shell0DspLpNotchLp1AKxW, status);
				getIntegerParam(p_CommErrorCount, &errorCount);
				setIntegerParam(p_CommErrorCount, ++errorCount);
			}


		}
		else
		if ((pFromFpga->addr >= Shell0DspLpNotchLp1AKyWAdr) &&
				(pFromFpga->addr < (Shell0DspLpNotchLp1AKyWAdr + 2)))
		{
			status = (asynStatus) getIntegerParam((pFromFpga->addr - Shell0DspLpNotchLp1AKyWAdr),
					p_Shell0DspLpNotchLp1AKyW, &valueSet);
			if( (valueSet & TagNowMask) == (pFromFpga->data & TagNowMask))
				asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
					"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
					Shell0DspLpNotchLp1AKyWString, (pFromFpga->addr - Shell0DspLpNotchLp1AKyWAdr), (unsigned ) pFromFpga->data & TagNowMask);
			else
			{
				asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
					"%s: value sent to %s, channel %u, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
					Shell0DspLpNotchLp1AKyWString, (pFromFpga->addr - Shell0DspLpNotchLp1AKyWAdr), valueSet & TagNowMask, (unsigned ) pFromFpga->data & TagNowMask);
				status = asynError;
				setParamStatus(p_Shell0DspLpNotchLp1AKyW, status);
				getIntegerParam(p_CommErrorCount, &errorCount);
				setIntegerParam(p_CommErrorCount, ++errorCount);
			}


		}
		else
		if ((pFromFpga->addr >= Shell0DspLpNotchLp1BKxWAdr) &&
				(pFromFpga->addr < (Shell0DspLpNotchLp1BKxWAdr + 2)))
		{
			status = (asynStatus) getIntegerParam((pFromFpga->addr - Shell0DspLpNotchLp1BKxWAdr),
					p_Shell0DspLpNotchLp1BKxW, &valueSet);
			if( (valueSet & TagNowMask) == (pFromFpga->data & TagNowMask))
				asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
					"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
					Shell0DspLpNotchLp1BKxWString, (pFromFpga->addr - Shell0DspLpNotchLp1BKxWAdr), (unsigned ) pFromFpga->data & TagNowMask);
			else
			{
				asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
					"%s: value sent to %s, channel %u, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
					Shell0DspLpNotchLp1BKxWString, (pFromFpga->addr - Shell0DspLpNotchLp1BKxWAdr), valueSet & TagNowMask, (unsigned ) pFromFpga->data & TagNowMask);
				status = asynError;
				setParamStatus(p_Shell0DspLpNotchLp1BKxW, status);
				getIntegerParam(p_CommErrorCount, &errorCount);
				setIntegerParam(p_CommErrorCount, ++errorCount);
			}


		}
		else
		if ((pFromFpga->addr >= Shell0DspLpNotchLp1BKyWAdr) &&
				(pFromFpga->addr < (Shell0DspLpNotchLp1BKyWAdr + 2)))
		{
			status = (asynStatus) getIntegerParam((pFromFpga->addr - Shell0DspLpNotchLp1BKyWAdr),
					p_Shell0DspLpNotchLp1BKyW, &valueSet);
			if( (valueSet & TagNowMask) == (pFromFpga->data & TagNowMask))
				asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
					"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
					Shell0DspLpNotchLp1BKyWString, (pFromFpga->addr - Shell0DspLpNotchLp1BKyWAdr), (unsigned ) pFromFpga->data & TagNowMask);
			else
			{
				asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
					"%s: value sent to %s, channel %u, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
					Shell0DspLpNotchLp1BKyWString, (pFromFpga->addr - Shell0DspLpNotchLp1BKyWAdr), valueSet & TagNowMask, (unsigned ) pFromFpga->data & TagNowMask);
				status = asynError;
				setParamStatus(p_Shell0DspLpNotchLp1BKyW, status);
				getIntegerParam(p_CommErrorCount, &errorCount);
				setIntegerParam(p_CommErrorCount, ++errorCount);
			}


		}
		else
		if ((pFromFpga->addr >= Shell1DspLpNotchLp1AKxWAdr) &&
				(pFromFpga->addr < (Shell1DspLpNotchLp1AKxWAdr + 2)))
		{
			status = (asynStatus) getIntegerParam((pFromFpga->addr - Shell1DspLpNotchLp1AKxWAdr),
					p_Shell1DspLpNotchLp1AKxW, &valueSet);
			if( (valueSet & TagNowMask) == (pFromFpga->data & TagNowMask))
				asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
					"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
					Shell1DspLpNotchLp1AKxWString, (pFromFpga->addr - Shell1DspLpNotchLp1AKxWAdr), (unsigned ) pFromFpga->data & TagNowMask);
			else
			{
				asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
					"%s: value sent to %s, channel %u, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
					Shell1DspLpNotchLp1AKxWString, (pFromFpga->addr - Shell1DspLpNotchLp1AKxWAdr), valueSet & TagNowMask, (unsigned ) pFromFpga->data & TagNowMask);
				status = asynError;
				setParamStatus(p_Shell1DspLpNotchLp1AKxW, status);
				getIntegerParam(p_CommErrorCount, &errorCount);
				setIntegerParam(p_CommErrorCount, ++errorCount);
			}


		}
		else
		if ((pFromFpga->addr >= Shell1DspLpNotchLp1AKyWAdr) &&
				(pFromFpga->addr < (Shell1DspLpNotchLp1AKyWAdr + 2)))
		{
			status = (asynStatus) getIntegerParam((pFromFpga->addr - Shell1DspLpNotchLp1AKyWAdr),
					p_Shell1DspLpNotchLp1AKyW, &valueSet);
			if( (valueSet & TagNowMask) == (pFromFpga->data & TagNowMask))
				asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
					"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
					Shell1DspLpNotchLp1AKyWString, (pFromFpga->addr - Shell1DspLpNotchLp1AKyWAdr), (unsigned ) pFromFpga->data & TagNowMask);
			else
			{
				asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
					"%s: value sent to %s, channel %u, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
					Shell1DspLpNotchLp1AKyWString, (pFromFpga->addr - Shell1DspLpNotchLp1AKyWAdr), valueSet & TagNowMask, (unsigned ) pFromFpga->data & TagNowMask);
				status = asynError;
				setParamStatus(p_Shell1DspLpNotchLp1AKyW, status);
				getIntegerParam(p_CommErrorCount, &errorCount);
				setIntegerParam(p_CommErrorCount, ++errorCount);
			}


		}
		else
		if ((pFromFpga->addr >= Shell1DspLpNotchLp1BKxWAdr) &&
				(pFromFpga->addr < (Shell1DspLpNotchLp1BKxWAdr + 2)))
		{
			status = (asynStatus) getIntegerParam((pFromFpga->addr - Shell1DspLpNotchLp1BKxWAdr),
					p_Shell1DspLpNotchLp1BKxW, &valueSet);
			if( (valueSet & TagNowMask) == (pFromFpga->data & TagNowMask))
				asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
					"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
					Shell1DspLpNotchLp1BKxWString, (pFromFpga->addr - Shell1DspLpNotchLp1BKxWAdr), (unsigned ) pFromFpga->data & TagNowMask);
			else
			{
				asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
					"%s: value sent to %s, channel %u, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
					Shell1DspLpNotchLp1BKxWString, (pFromFpga->addr - Shell1DspLpNotchLp1BKxWAdr), valueSet & TagNowMask, (unsigned ) pFromFpga->data & TagNowMask);
				status = asynError;
				setParamStatus(p_Shell1DspLpNotchLp1BKxW, status);
				getIntegerParam(p_CommErrorCount, &errorCount);
				setIntegerParam(p_CommErrorCount, ++errorCount);
			}


		}
		else
		if ((pFromFpga->addr >= Shell1DspLpNotchLp1BKyWAdr) &&
				(pFromFpga->addr < (Shell1DspLpNotchLp1BKyWAdr + 2)))
		{
			status = (asynStatus) getIntegerParam((pFromFpga->addr - Shell1DspLpNotchLp1BKyWAdr),
					p_Shell1DspLpNotchLp1BKyW, &valueSet);
			if( (valueSet & TagNowMask) == (pFromFpga->data & TagNowMask))
				asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
					"%s: readback for address=%s, channel %u, value=0x%x\n", __PRETTY_FUNCTION__,
					Shell1DspLpNotchLp1BKyWString, (pFromFpga->addr - Shell1DspLpNotchLp1BKyWAdr), (unsigned ) pFromFpga->data & TagNowMask);
			else
			{
				asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
					"%s: value sent to %s, channel %u, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
					Shell1DspLpNotchLp1BKyWString, (pFromFpga->addr - Shell1DspLpNotchLp1BKyWAdr), valueSet & TagNowMask, (unsigned ) pFromFpga->data & TagNowMask);
				status = asynError;
				setParamStatus(p_Shell1DspLpNotchLp1BKyW, status);
				getIntegerParam(p_CommErrorCount, &errorCount);
				setIntegerParam(p_CommErrorCount, ++errorCount);
			}


		}
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: write response from FPGA for unmapped address 0x%X, value=0x%X\n", __PRETTY_FUNCTION__,
				pFromFpga->addr, (unsigned ) pFromFpga->data);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
			status = asynError;
		}

		break;
    }

	// TODO: handle arrays

    return status;
}



extern "C" {

/* Configuration routine.  Called directly, or from the iocsh function below */

/** EPICS iocsh callable function to call constructor for the scllrfPRC class.
 * \param[in] portName The name of the asyn port driver to be created.
 * \param[in] netPortName The name of the asynIPport this will use to communicate */
int scllrfPRCConfigure(const char *drvPortName, const char *netPortName)
{
	//new scllrfPRCDriver(drvPortName, netPortName);
	new scllrfPRCDriver(drvPortName, netPortName, 8, 0);
	return asynSuccess;
}


/* EPICS iocsh shell commands */

static const iocshArg initArg0 = { "drvPortName",iocshArgString};
static const iocshArg initArg1 = { "IP port name",iocshArgString};
static const iocshArg * const initArgs[] = {&initArg0,
		&initArg1};
static const iocshFuncDef initFuncDef = {"scllrfPRCConfigure",2,initArgs};
static void initCallFunc(const iocshArgBuf *args)
{
	scllrfPRCConfigure(args[0].sval, args[1].sval);
}

void scllrfPRCRegister(void)
{
	iocshRegister(&initFuncDef,initCallFunc);
}

epicsExportRegistrar(scllrfPRCRegister);

}




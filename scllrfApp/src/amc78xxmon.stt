/* Poll 9 voltage monitors on the amc78xx ADC board. */

program amc78xxmon

option +r;    /* re-entrant */
option +W; // Initially, extra warnings


%{
	#include <math.h>
	#include <stdio.h>
	#include <errlog.h> /* errlogPrintf */
	#include <unistd.h> /* sleep */
enum { spareAddr, v2p2Addr, v3p7Addr, v12p0Addr,
microphoneAddr, loAddr, iMonAddr, vMonAddr, adcTempAddr };
}%

int saddr;

int spiAddr;
assign spiAddr to "{PREFIX}U15_SPI_ADDR_W";
int spiData;
assign spiData to "{PREFIX}U15_SPI_DATA_W";
int spiStart;
assign spiStart to "{PREFIX}U15_SPI_START_W";

unsigned int spiReady;
assign spiReady to "{PREFIX}U15_SPI_READY_R";
monitor spiReady;
unsigned int getSpiReady;
assign getSpiReady to "{PREFIX}GET_U15_SPI_READY_R.PROC";

int spiRdbk;
assign spiRdbk to "{PREFIX}U15_SPI_RDBK_R";
int getSpiRdbk;
assign getSpiRdbk to "{PREFIX}GET_U15_SPI_RDBK_R.PROC";


/* voltage monitor signals for board health. */
/* for raw voltage, scale by 2.5/2^12 */

float spareV;
assign spareV to "{PREFIX}ADC_SPARE_V";

/* 2.2V supply. Scale by additional x2 */
float v2p2V;
assign v2p2V to "{PREFIX}V2P2V";

/* 3.7V supply. Scale by additional x2 */
float v3p7V;
assign v3p7V to "{PREFIX}V3P7V";

/* 12V supply. Scale by additional /0.1776 */
float v12p0V;
assign v12p0V to "{PREFIX}V12P0V";

/* not using the microphone */
float microphoneV;
assign microphoneV to "{PREFIX}MICROPHONEV";

/* LO voltage monitor */
float loV;
assign loV to "{PREFIX}LO_V";

/* board current monitor, in A (1ohm) */
float iMon;
assign iMon to "{PREFIX}I_MON";

/* board voltge monitor. scale by additional x2 */
float vMon;
assign vMon to "{PREFIX}V_MON";

/* board temperature monitor, not used */
float adcTemp;
assign adcTemp to "{PREFIX}ADC_TEMP";

ss amc78xxmon
{
	state init
	{
		when()
		{
			printf("AMC7823 voltage monitor starting.\n");
		} state idle
	}

	state idle
	{
		/* Update ADC board voltages every 10 seconds */
		when(delay( 10 ))
		{
			printf("AMC7823 voltage monitor starting update cycle.\n");
		} state poll
	}

	state poll
	{
		/* Read U15 SPI register address 0 through 8 */
		when(saddr < 9)
		{
			int rw=1;
			int pg=0;
			int eaddr=0;
			int addr=(rw<<15)+(pg<<12)+(saddr<<6)+eaddr;

			printf("AMC7823 voltage monitor getting SPI addr %d\n", addr);
			spiAddr = addr;
			pvPut(spiAddr, SYNC);
			spiData = 1;
			pvPut(spiData, SYNC);
			spiStart = 0;
			pvPut(spiStart, SYNC);
		} state spiStartRisingEdge

		when(saddr >= 9)
		{
			saddr = 0;
		} state idle
	}
	state spiStartRisingEdge
	{
		when(delay(0.61))
		{
			spiStart = 1;
			pvPut(spiStart, SYNC);
		}state spiStartFallingEdge
	}
	state spiStartFallingEdge
	{
		when(delay(0.61))
		{
			spiStart = 0;
			pvPut(spiStart, SYNC);
		}state readOneV
	}
	state readOneV
	{
		/* Wait for SPI data ready flag */
/*XXXX Is this state a bad idea? SpiReady doesn't work?		when(spiReady == 1)*/
		when(delay(0.61))
		{
			getSpiRdbk = 1;
			pvPut(getSpiRdbk, SYNC);
		} state addrDecode
	}

	state addrDecode
	{
		option -e;    /* execute entry execution for self-state-transition */
		int chan;
		float val;

		/* Double check data is for the right address, then write to corresponding PV */
/*		entry
		{
//			pvGet(spiRdbk);
//			printf("AMC7823 voltage monitor read back %d\n", spiRdbk);
//			chan = spiRdbk >> 12;
		} */

		when(delay(1))
		{
                        pvGet(spiRdbk);
                        printf("AMC7823 voltage monitor read back %d\n", spiRdbk);
                        chan = spiRdbk >> 12;
			val=(spiRdbk&0xfff)*2.5/pow(2,12);
			printf("AMC7823 voltage monitor chan %d raw V = %f\n", chan, val);

			/* map address to PV */
%{
			switch(seqg_var->seqg_vars_amc78xxmon.seqg_vars_addrDecode.chan)
			{
			case spareAddr:
}%				spareV = val;
				pvPut(spareV );%{
				break;
			case v2p2Addr:
}%				v2p2V = 2*val;
				pvPut(v2p2V ); %{
				break;
			case v3p7Addr:
}%				v3p7V = 2*val;
				pvPut(v3p7V ); %{
				break;
			case v12p0Addr:
}%				v12p0V = val/0.1776;
				pvPut(v12p0V ); %{
				break;
			case microphoneAddr:
}%				microphoneV = val;
				pvPut(microphoneV ); %{
				break;
			case loAddr:
}%				loV = val;
				pvPut(loV ); %{
				break;
			case iMonAddr:
}%				iMon = val;
				pvPut(iMon ); %{
				break;
			case vMonAddr:
}%				vMon = 2*val;
				pvPut(vMon ); %{
				break;
			case adcTempAddr:
}%				adcTemp = val;
				pvPut(adcTemp ); %{
				break;
			default:
				/* insert error message here */
				break;
			};
}%
			saddr++;
		} state poll

	}
}

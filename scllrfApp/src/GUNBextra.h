
#ifndef GUNBEXTRA_DRIVER_H
#define GUNBEXTRA_DRIVER_H

/**
 *-----------------------------------------------------------------------------
 * Title      : superconducting low level RF EPICS interface
 * ----------------------------------------------------------------------------
 * File       : scllrfAsynPortDriver.h
 * Author     : Garth Brown, gwbrown@slac.stanford.edu
 * Created    : June 17, 2016
 * Last update: September 6, 2016
 * ----------------------------------------------------------------------------
 * Description:
 * Prototype for FPGA register access to FPGAs using protocol defined in papers
 * given to SLAC by LBNL (Larry Doolittle). Uses asynPortDriver interface. Some of this
 * should eventually be autogenerated from json files or some such, and templates.
 *
 * ----------------------------------------------------------------------------
 * This file is part of LCLS II. It is subject to
 * the license terms in the LICENSE.txt file found in the top-level directory
 * of this distribution and at:
    * https://confluence.slac.stanford.edu/display/ppareg/LICENSE.html.
 * No part of LCLS II, including this file, may be
 * copied, modified, propagated, or distributed except according to the terms
 * contained in the LICENSE.txt file.
 * ----------------------------------------------------------------------------
**/
#include "GUNB.h"
#include <math.h>

#include "../../newmat10/newmat.h"
#include "../../newmat10/newmatap.h"
#include "../../newmat10/newmatio.h"
using namespace NEWMAT;

class GUNBextra;

class TraceData
{
public:

	static const unsigned maxWavesCount = 32; // max channels, max number of waveforms interlaced in waveform buffer
	static const unsigned reqBufSegmentCount; // # of UDP requests, divide and round up
	static const unsigned reqMsgSize; // All register addresses plus nonce space
	static const unsigned TraceDataRegCount=GUNBDriver::TraceDataBufRegCount;  // This will be ok as long as register map has same size for shell 0 and 1

	static const unsigned CIC_PERIOD;
	static const unsigned SHIFT_BASE;
	static const float CLK_FREQ;
	static const unsigned SLOW_OFFSET;

	TraceData(GUNBextra *pDriver, unsigned int waveAddr,
			int *rawParamIndex, int *iParamIndex, int *qParamIndex, int *aParamIndex, int *pParamIndex,
			int *minsParamIndex, int *maxsParamIndex, epicsInt16 *readBuffer, FpgaReg *requestMsg);

	void ReqTraceData();
	int CalcWaveScale(int32_t wave_samp_per);

	unsigned int nChan_;
	epicsUInt32 chanKeep_;
	epicsInt16* waveReadback_;
	uint32_t GetEndAddr(){return regEndAddr_;}
	asynStatus ProcessTraceDataReadback(const FpgaReg *pFromFpga); // parse register data, write to array PV
//	asynStatus ProcessSlowDataReadback(const FpgaReg *pFromFpga); // parse register data, write to various parameters
//	unsigned int nextTag(){tag_ = ((tag_+1-4) % (unsigned int) pow(2,7))+4; return tag_;};

private:
	GUNBextra *pDriver_;
	FpgaReg *pRequestMsg_; // Canned message to request data buffer
	bool readInProgress_;
	uint32_t regStartAddr_;
	uint32_t regEndAddr_;
	int *iParamIndex_;
	int *qParamIndex_;
	int *aParamIndex_;
	int *pParamIndex_;
	int *rawParamIndex_;
    int *minsParamIndex_;
    int *maxsParamIndex_;
	epicsFloat32 gain_;

	float* CavityDecayConstantCompute(int *decay_real, int *decay_imag, unsigned int start);
	Matrix PseudoInverse(const Matrix & m);
	//	epicsInt32 bufTraceData[TraceDataRegCount]; from generated code
	//	epicsInt32 bufShell1CircleData[TraceDataRegCount]; from generated code
	epicsInt32 pIQBuf_[maxWavesCount][TraceDataRegCount]; // Data mapped into channels, I/Q separated
	epicsFloat32 pABuf_[maxWavesCount/2][TraceDataRegCount]; // Amplitude data channels
	epicsFloat32 pPBuf_[maxWavesCount/2][TraceDataRegCount]; // Phase data channels
};

class GUNBextra: public GUNBDriver
{
public:
	GUNBextra(const char *drvPortName, const char *netPortName);
	static const unsigned maxChannel; // for small waveforms, divided into one "channel"/PV per element, this is the size limit
	virtual ~GUNBextra();
	virtual asynStatus writeInt32(asynUser *pasynUser, epicsInt32 value);
	virtual asynStatus writeUInt32Digital(asynUser *pasynUser, epicsUInt32 value, epicsUInt32 mask);


	static const double LOfrequency;
	static const double ADCfrequency;
	static const char *IfFreqString;

	/* Registers */

	// I/Q data
	static const char *TraceDataNActiveString;
	static const char *TraceDataChanEnableString;
	static const char *TraceDataIString;
	static const char *TraceDataQString;
	static const char *TraceDataAString;
	static const char *TraceDataPString;
	static const char *TraceDataMinsRString;
	static const char *TraceDataMaxsRString;
    static const char* TraceDataTimeStepString;

	void TraceDataRequester(); // When signaled that waveforms are waiting, request them.
	static const unsigned TraceDataRegCount; // # data points for I or Q. Half the registers are I data, half Q
	friend class ::TraceData;

protected:
	virtual asynStatus processRegReadback(const FpgaReg *pFromFpga,
			bool &waveIsReady); // parse register data, write to PVs
	virtual asynStatus processRegWriteResponse(const FpgaReg *pFromFpga);
	void testCannedResponse();

	epicsEvent reqTraceDataEvent_; /**< Event to signal the waveform requester */
	unsigned int newTraceDataAvailable_; /**< netSendCount value of the latest response with the "new waveform" flag set */
	unsigned int newTraceDataRead_; /**< netSendCount for the most recent waveform */
	unsigned int phaseStepH, phaseStepL, phaseModulo;
	double iFrequency;

	TraceData traceData_;

	virtual asynStatus StartTraceDataRequester(); // For system startup

	/** Values used for pasynUser->reason, and indexes into the parameter library.
	 * For this prototype, it's read only values that identify the FPGA. */

    // parameters for reading I/Q waveforms
    // Circle buffer I/Q data
    int p_TraceDataNActive;
#define FIRST_GUNBEXTRA_PARAM p_TraceDataNActive
    int p_TraceDataChanEnable;
    int p_TraceDataI;
    int p_TraceDataQ;
    int p_TraceDataA;
    int p_TraceDataP;
    int p_TraceDataMinsR;
    int p_TraceDataMaxsR;
    int p_TraceDataTimeStep;

    int p_IF; // intermediate frequency

    #define LAST_GUNBEXTRA_PARAM p_IF

#define NUM_GUNBEXTRA_PARAMS (&LAST_GUNBEXTRA_PARAM - &FIRST_GUNBEXTRA_PARAM + 1)

private:

    // masks applied to returned register data
    enum ExtraRegMasks
    {
    	TraceKeepRMask = 0x000000FF,
    	TraceKeepWMask = 0x000000FF,
		TraceDataIsReadyMask = 0x40000000, // flag for trace data
		nptMask = 0x3F000000 // for trace status reg
    };
};

#endif


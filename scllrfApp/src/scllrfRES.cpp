/**
 *-----------------------------------------------------------------------------
 * Title      : superconducting low level RF EPICS interface
 * ----------------------------------------------------------------------------
 * File       : scllrfRESDriver.h
 * Author     : Garth Brown, gwbrown@slac.stanford.edu
 * Created    : June 17, 2016
 * Last update: September 6, 2016
 * ----------------------------------------------------------------------------
 * Description:
 * Header defining register interface to scllrfRES, autogenerated from a python
 * dictionary.
 *
 * ----------------------------------------------------------------------------
 * This file is part of LCLS II. It is subject to
 * the license terms in the LICENSE.txt file found in the top-level directory
 * of this distribution and at:
    * https://confluence.slac.stanford.edu/display/ppareg/LICENSE.html.
 * No part of LCLS II, including this file, may be
 * copied, modified, propagated, or distributed except according to the terms
 * contained in the LICENSE.txt file.
 * ----------------------------------------------------------------------------
**/

#include "scllrfRES.h"
#include <asynOctetSyncIO.h>
#include <asynCommonSyncIO.h>
#include <limits>
#include <netinet/in.h>
#include <iostream>
using namespace std;
#include <math.h>

/** Constructor for the scllrfRES class.
 * Calls constructor for the asynPortDriver base class.
 * \param[in] drvPortName The name of the asyn port driver to be created.
 * \param[in] netPortName The name of the asyn port driver to use for the network connection
 * \param[in] maxAddr The number of channels for the paramater with the most channels
 * \paarm[in] paramTableSize The number of asyn params to be created for each device
 *
 * */
//scllrfRESDriver::scllrfRESDriver(const char *drvPortName, const char *netPortName)
//: scllrfAsynPortDriver(drvPortName, netPortName,
//		8, /* maxAddr, i.e. number of channels */
//		NUM_SCLLRFRES_PARAMS)
//{
//	// NUM_SCLLRFPRC_PARAMS is a macro using protected member variables,
//	// which the compiler has problems with..
//	scllrfRESDriver(drvPortName, netPortName, 8, NUM_SCLLRFRES_PARAMS);
//};

scllrfRESDriver::scllrfRESDriver(const char *drvPortName, const char *netPortName, int maxAddr, int paramTableAdds)
: scllrfAsynPortDriver(drvPortName, netPortName,
		maxAddr, /* maxAddr, i.e. number of channels */
		paramTableAdds + NUM_SCLLRFRES_PARAMS)
{
    epicsThreadSleep(defaultPollPeriod);

    createParam(Cavity1DetuneErrRString, asynParamInt32, &p_Cavity1DetuneErrR);
    createParam(Cavity2DetuneErrRString, asynParamInt32, &p_Cavity2DetuneErrR);
    createParam(Cavity3DetuneErrRString, asynParamInt32, &p_Cavity3DetuneErrR);
    createParam(Cavity4DetuneErrRString, asynParamInt32, &p_Cavity4DetuneErrR);
    createParam(Motor1AbsStepsRString, asynParamInt32, &p_Motor1AbsStepsR);
    createParam(Motor1AccRString, asynParamInt32, &p_Motor1AccR);
    createParam(Motor1AccWString, asynParamInt32, &p_Motor1AccW);
    createParam(Motor1BrdTmpRString, asynParamInt32, &p_Motor1BrdTmpR);
    createParam(Motor1CntlRString, asynParamUInt32Digital, &p_Motor1CntlR);
    createParam(Motor1CntlWString, asynParamUInt32Digital, &p_Motor1CntlW);
    createParam(Motor1DrviRString, asynParamInt32, &p_Motor1DrviR);
    createParam(Motor1DrviWString, asynParamInt32, &p_Motor1DrviW);
    createParam(Motor1LaccRString, asynParamInt32, &p_Motor1LaccR);
    createParam(Motor1LstepsRString, asynParamInt32, &p_Motor1LstepsR);
    createParam(Motor1LvlctyRString, asynParamInt32, &p_Motor1LvlctyR);
    createParam(Motor1SgnStepsRString, asynParamInt32, &p_Motor1SgnStepsR);
    createParam(Motor1StatRString, asynParamUInt32Digital, &p_Motor1StatR);
    createParam(Motor1StepsRString, asynParamInt32, &p_Motor1StepsR);
    createParam(Motor1StepsWString, asynParamInt32, &p_Motor1StepsW);
    createParam(Motor1StepsActualRString, asynParamInt32, &p_Motor1StepsActualR);
    createParam(Motor1SubStpRString, asynParamInt32, &p_Motor1SubStpR);
    createParam(Motor1SubStpWString, asynParamInt32, &p_Motor1SubStpW);
    createParam(Motor1VlctyRString, asynParamInt32, &p_Motor1VlctyR);
    createParam(Motor1VlctyWString, asynParamInt32, &p_Motor1VlctyW);
    createParam(Motor2AbsStepsRString, asynParamInt32, &p_Motor2AbsStepsR);
    createParam(Motor2AccRString, asynParamInt32, &p_Motor2AccR);
    createParam(Motor2AccWString, asynParamInt32, &p_Motor2AccW);
    createParam(Motor2BrdTmpRString, asynParamInt32, &p_Motor2BrdTmpR);
    createParam(Motor2CntlRString, asynParamUInt32Digital, &p_Motor2CntlR);
    createParam(Motor2CntlWString, asynParamUInt32Digital, &p_Motor2CntlW);
    createParam(Motor2DrviRString, asynParamInt32, &p_Motor2DrviR);
    createParam(Motor2DrviWString, asynParamInt32, &p_Motor2DrviW);
    createParam(Motor2LaccRString, asynParamInt32, &p_Motor2LaccR);
    createParam(Motor2LstepsRString, asynParamInt32, &p_Motor2LstepsR);
    createParam(Motor2LvlctyRString, asynParamInt32, &p_Motor2LvlctyR);
    createParam(Motor2SgnStepsRString, asynParamInt32, &p_Motor2SgnStepsR);
    createParam(Motor2StatRString, asynParamUInt32Digital, &p_Motor2StatR);
    createParam(Motor2StepsRString, asynParamInt32, &p_Motor2StepsR);
    createParam(Motor2StepsWString, asynParamInt32, &p_Motor2StepsW);
    createParam(Motor2StepsActualRString, asynParamInt32, &p_Motor2StepsActualR);
    createParam(Motor2SubStpRString, asynParamInt32, &p_Motor2SubStpR);
    createParam(Motor2SubStpWString, asynParamInt32, &p_Motor2SubStpW);
    createParam(Motor2VlctyRString, asynParamInt32, &p_Motor2VlctyR);
    createParam(Motor2VlctyWString, asynParamInt32, &p_Motor2VlctyW);
    createParam(Motor3AbsStepsRString, asynParamInt32, &p_Motor3AbsStepsR);
    createParam(Motor3AccRString, asynParamInt32, &p_Motor3AccR);
    createParam(Motor3AccWString, asynParamInt32, &p_Motor3AccW);
    createParam(Motor3BrdTmpRString, asynParamInt32, &p_Motor3BrdTmpR);
    createParam(Motor3CntlRString, asynParamUInt32Digital, &p_Motor3CntlR);
    createParam(Motor3CntlWString, asynParamUInt32Digital, &p_Motor3CntlW);
    createParam(Motor3DrviRString, asynParamInt32, &p_Motor3DrviR);
    createParam(Motor3DrviWString, asynParamInt32, &p_Motor3DrviW);
    createParam(Motor3LaccRString, asynParamInt32, &p_Motor3LaccR);
    createParam(Motor3LstepsRString, asynParamInt32, &p_Motor3LstepsR);
    createParam(Motor3LvlctyRString, asynParamInt32, &p_Motor3LvlctyR);
    createParam(Motor3SgnStepsRString, asynParamInt32, &p_Motor3SgnStepsR);
    createParam(Motor3StatRString, asynParamUInt32Digital, &p_Motor3StatR);
    createParam(Motor3StepsRString, asynParamInt32, &p_Motor3StepsR);
    createParam(Motor3StepsWString, asynParamInt32, &p_Motor3StepsW);
    createParam(Motor3StepsActualRString, asynParamInt32, &p_Motor3StepsActualR);
    createParam(Motor3SubStpRString, asynParamInt32, &p_Motor3SubStpR);
    createParam(Motor3SubStpWString, asynParamInt32, &p_Motor3SubStpW);
    createParam(Motor3VlctyRString, asynParamInt32, &p_Motor3VlctyR);
    createParam(Motor3VlctyWString, asynParamInt32, &p_Motor3VlctyW);
    createParam(Motor4AbsStepsRString, asynParamInt32, &p_Motor4AbsStepsR);
    createParam(Motor4AccRString, asynParamInt32, &p_Motor4AccR);
    createParam(Motor4AccWString, asynParamInt32, &p_Motor4AccW);
    createParam(Motor4BrdTmpRString, asynParamInt32, &p_Motor4BrdTmpR);
    createParam(Motor4CntlRString, asynParamUInt32Digital, &p_Motor4CntlR);
    createParam(Motor4CntlWString, asynParamUInt32Digital, &p_Motor4CntlW);
    createParam(Motor4DrviRString, asynParamInt32, &p_Motor4DrviR);
    createParam(Motor4DrviWString, asynParamInt32, &p_Motor4DrviW);
    createParam(Motor4LaccRString, asynParamInt32, &p_Motor4LaccR);
    createParam(Motor4LstepsRString, asynParamInt32, &p_Motor4LstepsR);
    createParam(Motor4LvlctyRString, asynParamInt32, &p_Motor4LvlctyR);
    createParam(Motor4SgnStepsRString, asynParamInt32, &p_Motor4SgnStepsR);
    createParam(Motor4StatRString, asynParamUInt32Digital, &p_Motor4StatR);
    createParam(Motor4StepsRString, asynParamInt32, &p_Motor4StepsR);
    createParam(Motor4StepsWString, asynParamInt32, &p_Motor4StepsW);
    createParam(Motor4StepsActualRString, asynParamInt32, &p_Motor4StepsActualR);
    createParam(Motor4SubStpRString, asynParamInt32, &p_Motor4SubStpR);
    createParam(Motor4SubStpWString, asynParamInt32, &p_Motor4SubStpW);
    createParam(Motor4VlctyRString, asynParamInt32, &p_Motor4VlctyR);
    createParam(Motor4VlctyWString, asynParamInt32, &p_Motor4VlctyW);
    createParam(Piezo1Adc1RString, asynParamInt32, &p_Piezo1Adc1R);
    createParam(Piezo1Adc2RString, asynParamInt32, &p_Piezo1Adc2R);
    createParam(Piezo1BrdSernumRString, asynParamInt32, &p_Piezo1BrdSernumR);
    createParam(Piezo1BrdTmpRString, asynParamInt32, &p_Piezo1BrdTmpR);
    createParam(Piezo1C1InRString, asynParamInt32, &p_Piezo1C1InR);
    createParam(Piezo1C1IpRString, asynParamInt32, &p_Piezo1C1IpR);
    createParam(Piezo1C1DriveVRString, asynParamInt32, &p_Piezo1C1DriveVR);
    createParam(Piezo1C1OutVRString, asynParamInt32, &p_Piezo1C1OutVR);
    createParam(Piezo1C2InRString, asynParamInt32, &p_Piezo1C2InR);
    createParam(Piezo1C2IpRString, asynParamInt32, &p_Piezo1C2IpR);
    createParam(Piezo1C2DriveVRString, asynParamInt32, &p_Piezo1C2DriveVR);
    createParam(Piezo1C2OutVRString, asynParamInt32, &p_Piezo1C2OutVR);
    createParam(Piezo1CntlRString, asynParamUInt32Digital, &p_Piezo1CntlR);
    createParam(Piezo1CntlWString, asynParamUInt32Digital, &p_Piezo1CntlW);
    createParam(Piezo1Dac1RString, asynParamInt32, &p_Piezo1Dac1R);
    createParam(Piezo1Dac1WString, asynParamInt32, &p_Piezo1Dac1W);
    createParam(Piezo1Dac2RString, asynParamInt32, &p_Piezo1Dac2R);
    createParam(Piezo1Dac2WString, asynParamInt32, &p_Piezo1Dac2W);
    createParam(Piezo1HighWindowRString, asynParamInt32, &p_Piezo1HighWindowR);
    createParam(Piezo1HighWindowWString, asynParamInt32, &p_Piezo1HighWindowW);
    createParam(Piezo1IgainRString, asynParamInt32, &p_Piezo1IgainR);
    createParam(Piezo1IgainWString, asynParamInt32, &p_Piezo1IgainW);
    createParam(Piezo1LowWindowRString, asynParamInt32, &p_Piezo1LowWindowR);
    createParam(Piezo1LowWindowWString, asynParamInt32, &p_Piezo1LowWindowW);
    createParam(Piezo1StatRString, asynParamUInt32Digital, &p_Piezo1StatR);
    createParam(Piezo2Adc1RString, asynParamInt32, &p_Piezo2Adc1R);
    createParam(Piezo2Adc2RString, asynParamInt32, &p_Piezo2Adc2R);
    createParam(Piezo2BrdSernumRString, asynParamInt32, &p_Piezo2BrdSernumR);
    createParam(Piezo2BrdTmpRString, asynParamInt32, &p_Piezo2BrdTmpR);
    createParam(Piezo2C1InRString, asynParamInt32, &p_Piezo2C1InR);
    createParam(Piezo2C1IpRString, asynParamInt32, &p_Piezo2C1IpR);
    createParam(Piezo2C1DriveVRString, asynParamInt32, &p_Piezo2C1DriveVR);
    createParam(Piezo2C1OutVRString, asynParamInt32, &p_Piezo2C1OutVR);
    createParam(Piezo2C2InRString, asynParamInt32, &p_Piezo2C2InR);
    createParam(Piezo2C2IpRString, asynParamInt32, &p_Piezo2C2IpR);
    createParam(Piezo2C2DriveVRString, asynParamInt32, &p_Piezo2C2DriveVR);
    createParam(Piezo2C2OutVRString, asynParamInt32, &p_Piezo2C2OutVR);
    createParam(Piezo2CntlRString, asynParamUInt32Digital, &p_Piezo2CntlR);
    createParam(Piezo2CntlWString, asynParamUInt32Digital, &p_Piezo2CntlW);
    createParam(Piezo2Dac1RString, asynParamInt32, &p_Piezo2Dac1R);
    createParam(Piezo2Dac1WString, asynParamInt32, &p_Piezo2Dac1W);
    createParam(Piezo2Dac2RString, asynParamInt32, &p_Piezo2Dac2R);
    createParam(Piezo2Dac2WString, asynParamInt32, &p_Piezo2Dac2W);
    createParam(Piezo2HighWindowRString, asynParamInt32, &p_Piezo2HighWindowR);
    createParam(Piezo2HighWindowWString, asynParamInt32, &p_Piezo2HighWindowW);
    createParam(Piezo2IgainRString, asynParamInt32, &p_Piezo2IgainR);
    createParam(Piezo2IgainWString, asynParamInt32, &p_Piezo2IgainW);
    createParam(Piezo2LowWindowRString, asynParamInt32, &p_Piezo2LowWindowR);
    createParam(Piezo2LowWindowWString, asynParamInt32, &p_Piezo2LowWindowW);
    createParam(Piezo2StatRString, asynParamUInt32Digital, &p_Piezo2StatR);
    createParam(Piezo3Adc1RString, asynParamInt32, &p_Piezo3Adc1R);
    createParam(Piezo3Adc2RString, asynParamInt32, &p_Piezo3Adc2R);
    createParam(Piezo3BrdSernumRString, asynParamInt32, &p_Piezo3BrdSernumR);
    createParam(Piezo3BrdTmpRString, asynParamInt32, &p_Piezo3BrdTmpR);
    createParam(Piezo3C1InRString, asynParamInt32, &p_Piezo3C1InR);
    createParam(Piezo3C1IpRString, asynParamInt32, &p_Piezo3C1IpR);
    createParam(Piezo3C1DriveVRString, asynParamInt32, &p_Piezo3C1DriveVR);
    createParam(Piezo3C1OutVRString, asynParamInt32, &p_Piezo3C1OutVR);
    createParam(Piezo3C2InRString, asynParamInt32, &p_Piezo3C2InR);
    createParam(Piezo3C2IpRString, asynParamInt32, &p_Piezo3C2IpR);
    createParam(Piezo3C2DriveVRString, asynParamInt32, &p_Piezo3C2DriveVR);
    createParam(Piezo3C2OutVRString, asynParamInt32, &p_Piezo3C2OutVR);
    createParam(Piezo3CntlRString, asynParamUInt32Digital, &p_Piezo3CntlR);
    createParam(Piezo3CntlWString, asynParamUInt32Digital, &p_Piezo3CntlW);
    createParam(Piezo3Dac1RString, asynParamInt32, &p_Piezo3Dac1R);
    createParam(Piezo3Dac1WString, asynParamInt32, &p_Piezo3Dac1W);
    createParam(Piezo3Dac2RString, asynParamInt32, &p_Piezo3Dac2R);
    createParam(Piezo3Dac2WString, asynParamInt32, &p_Piezo3Dac2W);
    createParam(Piezo3HighWindowRString, asynParamInt32, &p_Piezo3HighWindowR);
    createParam(Piezo3HighWindowWString, asynParamInt32, &p_Piezo3HighWindowW);
    createParam(Piezo3IgainRString, asynParamInt32, &p_Piezo3IgainR);
    createParam(Piezo3IgainWString, asynParamInt32, &p_Piezo3IgainW);
    createParam(Piezo3LowWindowRString, asynParamInt32, &p_Piezo3LowWindowR);
    createParam(Piezo3LowWindowWString, asynParamInt32, &p_Piezo3LowWindowW);
    createParam(Piezo3StatRString, asynParamUInt32Digital, &p_Piezo3StatR);
    createParam(Piezo4Adc1RString, asynParamInt32, &p_Piezo4Adc1R);
    createParam(Piezo4Adc2RString, asynParamInt32, &p_Piezo4Adc2R);
    createParam(Piezo4BrdSernumRString, asynParamInt32, &p_Piezo4BrdSernumR);
    createParam(Piezo4BrdTmpRString, asynParamInt32, &p_Piezo4BrdTmpR);
    createParam(Piezo4C1InRString, asynParamInt32, &p_Piezo4C1InR);
    createParam(Piezo4C1IpRString, asynParamInt32, &p_Piezo4C1IpR);
    createParam(Piezo4C1DriveVRString, asynParamInt32, &p_Piezo4C1DriveVR);
    createParam(Piezo4C1OutVRString, asynParamInt32, &p_Piezo4C1OutVR);
    createParam(Piezo4C2InRString, asynParamInt32, &p_Piezo4C2InR);
    createParam(Piezo4C2IpRString, asynParamInt32, &p_Piezo4C2IpR);
    createParam(Piezo4C2DriveVRString, asynParamInt32, &p_Piezo4C2DriveVR);
    createParam(Piezo4C2OutVRString, asynParamInt32, &p_Piezo4C2OutVR);
    createParam(Piezo4CntlRString, asynParamUInt32Digital, &p_Piezo4CntlR);
    createParam(Piezo4CntlWString, asynParamUInt32Digital, &p_Piezo4CntlW);
    createParam(Piezo4Dac1RString, asynParamInt32, &p_Piezo4Dac1R);
    createParam(Piezo4Dac1WString, asynParamInt32, &p_Piezo4Dac1W);
    createParam(Piezo4Dac2RString, asynParamInt32, &p_Piezo4Dac2R);
    createParam(Piezo4Dac2WString, asynParamInt32, &p_Piezo4Dac2W);
    createParam(Piezo4HighWindowRString, asynParamInt32, &p_Piezo4HighWindowR);
    createParam(Piezo4HighWindowWString, asynParamInt32, &p_Piezo4HighWindowW);
    createParam(Piezo4IgainRString, asynParamInt32, &p_Piezo4IgainR);
    createParam(Piezo4IgainWString, asynParamInt32, &p_Piezo4IgainW);
    createParam(Piezo4LowWindowRString, asynParamInt32, &p_Piezo4LowWindowR);
    createParam(Piezo4LowWindowWString, asynParamInt32, &p_Piezo4LowWindowW);
    createParam(Piezo4StatRString, asynParamUInt32Digital, &p_Piezo4StatR);
    createParam(PztWaveAvailRString, asynParamInt32, &p_PztWaveAvailR);
    createParam(Reserved0RString, asynParamInt32, &p_Reserved0R);
    createParam(Reserved0WString, asynParamInt32, &p_Reserved0W);
    createParam(Reserved1RString, asynParamInt32, &p_Reserved1R);
    createParam(Reserved1WString, asynParamInt32, &p_Reserved1W);
    createParam(Reserved2RString, asynParamInt32, &p_Reserved2R);
    createParam(Reserved2WString, asynParamInt32, &p_Reserved2W);
    createParam(Reserved3RString, asynParamInt32, &p_Reserved3R);
    createParam(Reserved3WString, asynParamInt32, &p_Reserved3W);
    createParam(Reserved4RString, asynParamInt32, &p_Reserved4R);
    createParam(Reserved4WString, asynParamInt32, &p_Reserved4W);

    // Message size is the number of read registers, plus 1 nonce for every 175 read registers
    PolledRegMsgSize_ = scllrfRESPolledRegCount + (scllrfRESPolledRegCount / 175) + 1;
	// A canned request to read all registers
    pPolledRegMsg_ = new FpgaReg[PolledRegMsgSize_]
	{
		{ 0, 0 },
		{ (flagReadMask | Motor1AccRAdr), blankData },
		{ (flagReadMask | Motor1VlctyRAdr), blankData },
		{ (flagReadMask | Motor1StepsRAdr), blankData },
		{ (flagReadMask | Motor1SgnStepsRAdr), blankData },
		{ (flagReadMask | Motor1AbsStepsRAdr), blankData },
		{ (flagReadMask | Motor1LaccRAdr), blankData },
		{ (flagReadMask | Motor1LvlctyRAdr), blankData },
		{ (flagReadMask | Motor1LstepsRAdr), blankData },
		{ (flagReadMask | Motor1DrviRAdr), blankData },
		{ (flagReadMask | Motor1BrdTmpRAdr), blankData },
		{ (flagReadMask | Motor1CntlRAdr), blankData },
		{ (flagReadMask | Motor1StatRAdr), blankData },
		{ (flagReadMask | Piezo1Dac1RAdr), blankData },
		{ (flagReadMask | Piezo1Dac2RAdr), blankData },
		{ (flagReadMask | Piezo1Adc1RAdr), blankData },
		{ (flagReadMask | Piezo1Adc2RAdr), blankData },
		{ (flagReadMask | Piezo1HighWindowRAdr), blankData },
		{ (flagReadMask | Piezo1LowWindowRAdr), blankData },
		{ (flagReadMask | Piezo1CntlRAdr), blankData },
		{ (flagReadMask | Piezo1StatRAdr), blankData },
		{ (flagReadMask | Piezo1BrdTmpRAdr), blankData },
		{ (flagReadMask | Piezo1BrdSernumRAdr), blankData },
		{ (flagReadMask | Piezo1IgainRAdr), blankData },
		{ (flagReadMask | Cavity1DetuneErrRAdr), blankData },
		{ (flagReadMask | Motor2AccRAdr), blankData },
		{ (flagReadMask | Motor2VlctyRAdr), blankData },
		{ (flagReadMask | Motor2StepsRAdr), blankData },
		{ (flagReadMask | Motor2SgnStepsRAdr), blankData },
		{ (flagReadMask | Motor2AbsStepsRAdr), blankData },
		{ (flagReadMask | Motor2LaccRAdr), blankData },
		{ (flagReadMask | Motor2LvlctyRAdr), blankData },
		{ (flagReadMask | Motor2LstepsRAdr), blankData },
		{ (flagReadMask | Motor2DrviRAdr), blankData },
		{ (flagReadMask | Motor2BrdTmpRAdr), blankData },
		{ (flagReadMask | Motor2CntlRAdr), blankData },
		{ (flagReadMask | Motor2StatRAdr), blankData },
		{ (flagReadMask | Piezo2Dac1RAdr), blankData },
		{ (flagReadMask | Piezo2Dac2RAdr), blankData },
		{ (flagReadMask | Piezo2Adc1RAdr), blankData },
		{ (flagReadMask | Piezo2Adc2RAdr), blankData },
		{ (flagReadMask | Piezo2HighWindowRAdr), blankData },
		{ (flagReadMask | Piezo2LowWindowRAdr), blankData },
		{ (flagReadMask | Piezo2CntlRAdr), blankData },
		{ (flagReadMask | Piezo2StatRAdr), blankData },
		{ (flagReadMask | Piezo2BrdTmpRAdr), blankData },
		{ (flagReadMask | Piezo2BrdSernumRAdr), blankData },
		{ (flagReadMask | Piezo2IgainRAdr), blankData },
		{ (flagReadMask | Cavity2DetuneErrRAdr), blankData },
		{ (flagReadMask | Motor3AccRAdr), blankData },
		{ (flagReadMask | Motor3VlctyRAdr), blankData },
		{ (flagReadMask | Motor3StepsRAdr), blankData },
		{ (flagReadMask | Motor3SgnStepsRAdr), blankData },
		{ (flagReadMask | Motor3AbsStepsRAdr), blankData },
		{ (flagReadMask | Motor3LaccRAdr), blankData },
		{ (flagReadMask | Motor3LvlctyRAdr), blankData },
		{ (flagReadMask | Motor3LstepsRAdr), blankData },
		{ (flagReadMask | Motor3DrviRAdr), blankData },
		{ (flagReadMask | Motor3BrdTmpRAdr), blankData },
		{ (flagReadMask | Motor3CntlRAdr), blankData },
		{ (flagReadMask | Motor3StatRAdr), blankData },
		{ (flagReadMask | Piezo3Dac1RAdr), blankData },
		{ (flagReadMask | Piezo3Dac2RAdr), blankData },
		{ (flagReadMask | Piezo3Adc1RAdr), blankData },
		{ (flagReadMask | Piezo3Adc2RAdr), blankData },
		{ (flagReadMask | Piezo3HighWindowRAdr), blankData },
		{ (flagReadMask | Piezo3LowWindowRAdr), blankData },
		{ (flagReadMask | Piezo3CntlRAdr), blankData },
		{ (flagReadMask | Piezo3StatRAdr), blankData },
		{ (flagReadMask | Piezo3BrdTmpRAdr), blankData },
		{ (flagReadMask | Piezo3BrdSernumRAdr), blankData },
		{ (flagReadMask | Piezo3IgainRAdr), blankData },
		{ (flagReadMask | Cavity3DetuneErrRAdr), blankData },
		{ (flagReadMask | Motor4AccRAdr), blankData },
		{ (flagReadMask | Motor4VlctyRAdr), blankData },
		{ (flagReadMask | Motor4StepsRAdr), blankData },
		{ (flagReadMask | Motor4SgnStepsRAdr), blankData },
		{ (flagReadMask | Motor4AbsStepsRAdr), blankData },
		{ (flagReadMask | Motor4LaccRAdr), blankData },
		{ (flagReadMask | Motor4LvlctyRAdr), blankData },
		{ (flagReadMask | Motor4LstepsRAdr), blankData },
		{ (flagReadMask | Motor4DrviRAdr), blankData },
		{ (flagReadMask | Motor4BrdTmpRAdr), blankData },
		{ (flagReadMask | Motor4CntlRAdr), blankData },
		{ (flagReadMask | Motor4StatRAdr), blankData },
		{ (flagReadMask | Piezo4Dac1RAdr), blankData },
		{ (flagReadMask | Piezo4Dac2RAdr), blankData },
		{ (flagReadMask | Piezo4Adc1RAdr), blankData },
		{ (flagReadMask | Piezo4Adc2RAdr), blankData },
		{ (flagReadMask | Piezo4HighWindowRAdr), blankData },
		{ (flagReadMask | Piezo4LowWindowRAdr), blankData },
		{ (flagReadMask | Piezo4CntlRAdr), blankData },
		{ (flagReadMask | Piezo4StatRAdr), blankData },
		{ (flagReadMask | Piezo4BrdTmpRAdr), blankData },
		{ (flagReadMask | Piezo4BrdSernumRAdr), blankData },
		{ (flagReadMask | Piezo4IgainRAdr), blankData },
		{ (flagReadMask | Cavity4DetuneErrRAdr), blankData },
		{ (flagReadMask | Motor1SubStpRAdr), blankData },
		{ (flagReadMask | Motor2SubStpRAdr), blankData },
		{ (flagReadMask | Motor3SubStpRAdr), blankData },
		{ (flagReadMask | Motor4SubStpRAdr), blankData },
		{ (flagReadMask | Reserved0RAdr), blankData },
		{ (flagReadMask | Reserved1RAdr), blankData },
		{ (flagReadMask | Reserved2RAdr), blankData },
		{ (flagReadMask | Reserved3RAdr), blankData },
		{ (flagReadMask | Reserved4RAdr), blankData },
		{ (flagReadMask | Motor1StepsActualRAdr), blankData },
		{ (flagReadMask | Motor2StepsActualRAdr), blankData },
		{ (flagReadMask | Motor3StepsActualRAdr), blankData },
		{ (flagReadMask | Motor4StepsActualRAdr), blankData },
		{ (flagReadMask | PztWaveAvailRAdr), blankData },
		{ (flagReadMask | Piezo1C1InRAdr), blankData },
		{ (flagReadMask | Piezo1C1IpRAdr), blankData },
		{ (flagReadMask | Piezo1C1OutVRAdr), blankData },
		{ (flagReadMask | Piezo1C1DriveVRAdr), blankData },
		{ (flagReadMask | Piezo1C2InRAdr), blankData },
		{ (flagReadMask | Piezo1C2IpRAdr), blankData },
		{ (flagReadMask | Piezo1C2OutVRAdr), blankData },
		{ (flagReadMask | Piezo1C2DriveVRAdr), blankData },
		{ (flagReadMask | Piezo2C1InRAdr), blankData },
		{ (flagReadMask | Piezo2C1IpRAdr), blankData },
		{ (flagReadMask | Piezo2C1OutVRAdr), blankData },
		{ (flagReadMask | Piezo2C1DriveVRAdr), blankData },
		{ (flagReadMask | Piezo2C2InRAdr), blankData },
		{ (flagReadMask | Piezo2C2IpRAdr), blankData },
		{ (flagReadMask | Piezo2C2OutVRAdr), blankData },
		{ (flagReadMask | Piezo2C2DriveVRAdr), blankData },
		{ (flagReadMask | Piezo3C1InRAdr), blankData },
		{ (flagReadMask | Piezo3C1IpRAdr), blankData },
		{ (flagReadMask | Piezo3C1OutVRAdr), blankData },
		{ (flagReadMask | Piezo3C1DriveVRAdr), blankData },
		{ (flagReadMask | Piezo3C2InRAdr), blankData },
		{ (flagReadMask | Piezo3C2IpRAdr), blankData },
		{ (flagReadMask | Piezo3C2OutVRAdr), blankData },
		{ (flagReadMask | Piezo3C2DriveVRAdr), blankData },
		{ (flagReadMask | Piezo4C1InRAdr), blankData },
		{ (flagReadMask | Piezo4C1IpRAdr), blankData },
		{ (flagReadMask | Piezo4C1OutVRAdr), blankData },
		{ (flagReadMask | Piezo4C1DriveVRAdr), blankData },
		{ (flagReadMask | Piezo4C2InRAdr), blankData },
		{ (flagReadMask | Piezo4C2IpRAdr), blankData },
		{ (flagReadMask | Piezo4C2OutVRAdr), blankData },
		{ (flagReadMask | Piezo4C2DriveVRAdr), blankData },
	};

	htonFpgaRegArray(pPolledRegMsg_, PolledRegMsgSize_);

    epicsThreadSleep(defaultPollPeriod);
    printf("%s created %ld of %ld parameters.\n",__PRETTY_FUNCTION__,NUM_SCLLRFRES_PARAMS, paramTableAdds+NUM_SCLLRFRES_PARAMS);

    wakeupPoller();
    wakeupReader();
}

scllrfRESDriver::~scllrfRESDriver()
{
	isShuttingDown_ = true;
	epicsThreadSleep(0.1); // Allow threads to run and exit
	wakeupPoller();
	wakeupReader();
	epicsThreadSleep(0.1); // Allow threads to run and exit
	wakeupPoller(); // call this twice in case the poller was never set to run
	wakeupReader();
	epicsThreadSleep(0.1); // Allow threads to run and exit
	wakeupReader();
	pasynOctetSyncIO->disconnect(pOctetAsynUser_);
	pasynCommonSyncIO->disconnectDevice(pCommonAsynUser_);
	pasynCommonSyncIO->disconnect(pCommonAsynUser_);
}

/** Called when you have the asyn parameter name and want the corresponding
 * register address.
  * \param[in] function From pAsynUser->reason, corresponding to a registered parameter.
  * \param[in] pToFpga Pointer to the {Address, Data} structure where the register address will be written
  * \param[in] nElements Number of elements to read. */
asynStatus scllrfRESDriver::functionToRegister(const int function, FpgaReg *pToFpga)
{
	asynStatus status = asynSuccess;

    if( function == p_Cavity1DetuneErrR )
    {
		pToFpga->addr = Cavity1DetuneErrRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity2DetuneErrR )
    {
		pToFpga->addr = Cavity2DetuneErrRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity3DetuneErrR )
    {
		pToFpga->addr = Cavity3DetuneErrRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity4DetuneErrR )
    {
		pToFpga->addr = Cavity4DetuneErrRAdr|flagReadMask;
    }
    else
    if( function == p_Motor1AbsStepsR )
    {
		pToFpga->addr = Motor1AbsStepsRAdr|flagReadMask;
    }
    else
    if( function == p_Motor1AccR )
    {
		pToFpga->addr = Motor1AccRAdr|flagReadMask;
    }
    else
    if( function == p_Motor1AccW )
    {
		pToFpga->addr = Motor1AccWAdr;
    }
    else
    if( function == p_Motor1BrdTmpR )
    {
		pToFpga->addr = Motor1BrdTmpRAdr|flagReadMask;
    }
    else
    if( function == p_Motor1CntlR )
    {
		pToFpga->addr = Motor1CntlRAdr|flagReadMask;
    }
    else
    if( function == p_Motor1CntlW )
    {
		pToFpga->addr = Motor1CntlWAdr;
    }
    else
    if( function == p_Motor1DrviR )
    {
		pToFpga->addr = Motor1DrviRAdr|flagReadMask;
    }
    else
    if( function == p_Motor1DrviW )
    {
		pToFpga->addr = Motor1DrviWAdr;
    }
    else
    if( function == p_Motor1LaccR )
    {
		pToFpga->addr = Motor1LaccRAdr|flagReadMask;
    }
    else
    if( function == p_Motor1LstepsR )
    {
		pToFpga->addr = Motor1LstepsRAdr|flagReadMask;
    }
    else
    if( function == p_Motor1LvlctyR )
    {
		pToFpga->addr = Motor1LvlctyRAdr|flagReadMask;
    }
    else
    if( function == p_Motor1SgnStepsR )
    {
		pToFpga->addr = Motor1SgnStepsRAdr|flagReadMask;
    }
    else
    if( function == p_Motor1StatR )
    {
		pToFpga->addr = Motor1StatRAdr|flagReadMask;
    }
    else
    if( function == p_Motor1StepsR )
    {
		pToFpga->addr = Motor1StepsRAdr|flagReadMask;
    }
    else
    if( function == p_Motor1StepsW )
    {
		pToFpga->addr = Motor1StepsWAdr;
    }
    else
    if( function == p_Motor1StepsActualR )
    {
		pToFpga->addr = Motor1StepsActualRAdr|flagReadMask;
    }
    else
    if( function == p_Motor1SubStpR )
    {
		pToFpga->addr = Motor1SubStpRAdr|flagReadMask;
    }
    else
    if( function == p_Motor1SubStpW )
    {
		pToFpga->addr = Motor1SubStpWAdr;
    }
    else
    if( function == p_Motor1VlctyR )
    {
		pToFpga->addr = Motor1VlctyRAdr|flagReadMask;
    }
    else
    if( function == p_Motor1VlctyW )
    {
		pToFpga->addr = Motor1VlctyWAdr;
    }
    else
    if( function == p_Motor2AbsStepsR )
    {
		pToFpga->addr = Motor2AbsStepsRAdr|flagReadMask;
    }
    else
    if( function == p_Motor2AccR )
    {
		pToFpga->addr = Motor2AccRAdr|flagReadMask;
    }
    else
    if( function == p_Motor2AccW )
    {
		pToFpga->addr = Motor2AccWAdr;
    }
    else
    if( function == p_Motor2BrdTmpR )
    {
		pToFpga->addr = Motor2BrdTmpRAdr|flagReadMask;
    }
    else
    if( function == p_Motor2CntlR )
    {
		pToFpga->addr = Motor2CntlRAdr|flagReadMask;
    }
    else
    if( function == p_Motor2CntlW )
    {
		pToFpga->addr = Motor2CntlWAdr;
    }
    else
    if( function == p_Motor2DrviR )
    {
		pToFpga->addr = Motor2DrviRAdr|flagReadMask;
    }
    else
    if( function == p_Motor2DrviW )
    {
		pToFpga->addr = Motor2DrviWAdr;
    }
    else
    if( function == p_Motor2LaccR )
    {
		pToFpga->addr = Motor2LaccRAdr|flagReadMask;
    }
    else
    if( function == p_Motor2LstepsR )
    {
		pToFpga->addr = Motor2LstepsRAdr|flagReadMask;
    }
    else
    if( function == p_Motor2LvlctyR )
    {
		pToFpga->addr = Motor2LvlctyRAdr|flagReadMask;
    }
    else
    if( function == p_Motor2SgnStepsR )
    {
		pToFpga->addr = Motor2SgnStepsRAdr|flagReadMask;
    }
    else
    if( function == p_Motor2StatR )
    {
		pToFpga->addr = Motor2StatRAdr|flagReadMask;
    }
    else
    if( function == p_Motor2StepsR )
    {
		pToFpga->addr = Motor2StepsRAdr|flagReadMask;
    }
    else
    if( function == p_Motor2StepsW )
    {
		pToFpga->addr = Motor2StepsWAdr;
    }
    else
    if( function == p_Motor2StepsActualR )
    {
		pToFpga->addr = Motor2StepsActualRAdr|flagReadMask;
    }
    else
    if( function == p_Motor2SubStpR )
    {
		pToFpga->addr = Motor2SubStpRAdr|flagReadMask;
    }
    else
    if( function == p_Motor2SubStpW )
    {
		pToFpga->addr = Motor2SubStpWAdr;
    }
    else
    if( function == p_Motor2VlctyR )
    {
		pToFpga->addr = Motor2VlctyRAdr|flagReadMask;
    }
    else
    if( function == p_Motor2VlctyW )
    {
		pToFpga->addr = Motor2VlctyWAdr;
    }
    else
    if( function == p_Motor3AbsStepsR )
    {
		pToFpga->addr = Motor3AbsStepsRAdr|flagReadMask;
    }
    else
    if( function == p_Motor3AccR )
    {
		pToFpga->addr = Motor3AccRAdr|flagReadMask;
    }
    else
    if( function == p_Motor3AccW )
    {
		pToFpga->addr = Motor3AccWAdr;
    }
    else
    if( function == p_Motor3BrdTmpR )
    {
		pToFpga->addr = Motor3BrdTmpRAdr|flagReadMask;
    }
    else
    if( function == p_Motor3CntlR )
    {
		pToFpga->addr = Motor3CntlRAdr|flagReadMask;
    }
    else
    if( function == p_Motor3CntlW )
    {
		pToFpga->addr = Motor3CntlWAdr;
    }
    else
    if( function == p_Motor3DrviR )
    {
		pToFpga->addr = Motor3DrviRAdr|flagReadMask;
    }
    else
    if( function == p_Motor3DrviW )
    {
		pToFpga->addr = Motor3DrviWAdr;
    }
    else
    if( function == p_Motor3LaccR )
    {
		pToFpga->addr = Motor3LaccRAdr|flagReadMask;
    }
    else
    if( function == p_Motor3LstepsR )
    {
		pToFpga->addr = Motor3LstepsRAdr|flagReadMask;
    }
    else
    if( function == p_Motor3LvlctyR )
    {
		pToFpga->addr = Motor3LvlctyRAdr|flagReadMask;
    }
    else
    if( function == p_Motor3SgnStepsR )
    {
		pToFpga->addr = Motor3SgnStepsRAdr|flagReadMask;
    }
    else
    if( function == p_Motor3StatR )
    {
		pToFpga->addr = Motor3StatRAdr|flagReadMask;
    }
    else
    if( function == p_Motor3StepsR )
    {
		pToFpga->addr = Motor3StepsRAdr|flagReadMask;
    }
    else
    if( function == p_Motor3StepsW )
    {
		pToFpga->addr = Motor3StepsWAdr;
    }
    else
    if( function == p_Motor3StepsActualR )
    {
		pToFpga->addr = Motor3StepsActualRAdr|flagReadMask;
    }
    else
    if( function == p_Motor3SubStpR )
    {
		pToFpga->addr = Motor3SubStpRAdr|flagReadMask;
    }
    else
    if( function == p_Motor3SubStpW )
    {
		pToFpga->addr = Motor3SubStpWAdr;
    }
    else
    if( function == p_Motor3VlctyR )
    {
		pToFpga->addr = Motor3VlctyRAdr|flagReadMask;
    }
    else
    if( function == p_Motor3VlctyW )
    {
		pToFpga->addr = Motor3VlctyWAdr;
    }
    else
    if( function == p_Motor4AbsStepsR )
    {
		pToFpga->addr = Motor4AbsStepsRAdr|flagReadMask;
    }
    else
    if( function == p_Motor4AccR )
    {
		pToFpga->addr = Motor4AccRAdr|flagReadMask;
    }
    else
    if( function == p_Motor4AccW )
    {
		pToFpga->addr = Motor4AccWAdr;
    }
    else
    if( function == p_Motor4BrdTmpR )
    {
		pToFpga->addr = Motor4BrdTmpRAdr|flagReadMask;
    }
    else
    if( function == p_Motor4CntlR )
    {
		pToFpga->addr = Motor4CntlRAdr|flagReadMask;
    }
    else
    if( function == p_Motor4CntlW )
    {
		pToFpga->addr = Motor4CntlWAdr;
    }
    else
    if( function == p_Motor4DrviR )
    {
		pToFpga->addr = Motor4DrviRAdr|flagReadMask;
    }
    else
    if( function == p_Motor4DrviW )
    {
		pToFpga->addr = Motor4DrviWAdr;
    }
    else
    if( function == p_Motor4LaccR )
    {
		pToFpga->addr = Motor4LaccRAdr|flagReadMask;
    }
    else
    if( function == p_Motor4LstepsR )
    {
		pToFpga->addr = Motor4LstepsRAdr|flagReadMask;
    }
    else
    if( function == p_Motor4LvlctyR )
    {
		pToFpga->addr = Motor4LvlctyRAdr|flagReadMask;
    }
    else
    if( function == p_Motor4SgnStepsR )
    {
		pToFpga->addr = Motor4SgnStepsRAdr|flagReadMask;
    }
    else
    if( function == p_Motor4StatR )
    {
		pToFpga->addr = Motor4StatRAdr|flagReadMask;
    }
    else
    if( function == p_Motor4StepsR )
    {
		pToFpga->addr = Motor4StepsRAdr|flagReadMask;
    }
    else
    if( function == p_Motor4StepsW )
    {
		pToFpga->addr = Motor4StepsWAdr;
    }
    else
    if( function == p_Motor4StepsActualR )
    {
		pToFpga->addr = Motor4StepsActualRAdr|flagReadMask;
    }
    else
    if( function == p_Motor4SubStpR )
    {
		pToFpga->addr = Motor4SubStpRAdr|flagReadMask;
    }
    else
    if( function == p_Motor4SubStpW )
    {
		pToFpga->addr = Motor4SubStpWAdr;
    }
    else
    if( function == p_Motor4VlctyR )
    {
		pToFpga->addr = Motor4VlctyRAdr|flagReadMask;
    }
    else
    if( function == p_Motor4VlctyW )
    {
		pToFpga->addr = Motor4VlctyWAdr;
    }
    else
    if( function == p_Piezo1Adc1R )
    {
		pToFpga->addr = Piezo1Adc1RAdr|flagReadMask;
    }
    else
    if( function == p_Piezo1Adc2R )
    {
		pToFpga->addr = Piezo1Adc2RAdr|flagReadMask;
    }
    else
    if( function == p_Piezo1BrdSernumR )
    {
		pToFpga->addr = Piezo1BrdSernumRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo1BrdTmpR )
    {
		pToFpga->addr = Piezo1BrdTmpRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo1C1InR )
    {
		pToFpga->addr = Piezo1C1InRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo1C1IpR )
    {
		pToFpga->addr = Piezo1C1IpRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo1C1DriveVR )
    {
		pToFpga->addr = Piezo1C1DriveVRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo1C1OutVR )
    {
		pToFpga->addr = Piezo1C1OutVRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo1C2InR )
    {
		pToFpga->addr = Piezo1C2InRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo1C2IpR )
    {
		pToFpga->addr = Piezo1C2IpRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo1C2DriveVR )
    {
		pToFpga->addr = Piezo1C2DriveVRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo1C2OutVR )
    {
		pToFpga->addr = Piezo1C2OutVRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo1CntlR )
    {
		pToFpga->addr = Piezo1CntlRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo1CntlW )
    {
		pToFpga->addr = Piezo1CntlWAdr;
    }
    else
    if( function == p_Piezo1Dac1R )
    {
		pToFpga->addr = Piezo1Dac1RAdr|flagReadMask;
    }
    else
    if( function == p_Piezo1Dac1W )
    {
		pToFpga->addr = Piezo1Dac1WAdr;
    }
    else
    if( function == p_Piezo1Dac2R )
    {
		pToFpga->addr = Piezo1Dac2RAdr|flagReadMask;
    }
    else
    if( function == p_Piezo1Dac2W )
    {
		pToFpga->addr = Piezo1Dac2WAdr;
    }
    else
    if( function == p_Piezo1HighWindowR )
    {
		pToFpga->addr = Piezo1HighWindowRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo1HighWindowW )
    {
		pToFpga->addr = Piezo1HighWindowWAdr;
    }
    else
    if( function == p_Piezo1IgainR )
    {
		pToFpga->addr = Piezo1IgainRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo1IgainW )
    {
		pToFpga->addr = Piezo1IgainWAdr;
    }
    else
    if( function == p_Piezo1LowWindowR )
    {
		pToFpga->addr = Piezo1LowWindowRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo1LowWindowW )
    {
		pToFpga->addr = Piezo1LowWindowWAdr;
    }
    else
    if( function == p_Piezo1StatR )
    {
		pToFpga->addr = Piezo1StatRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo2Adc1R )
    {
		pToFpga->addr = Piezo2Adc1RAdr|flagReadMask;
    }
    else
    if( function == p_Piezo2Adc2R )
    {
		pToFpga->addr = Piezo2Adc2RAdr|flagReadMask;
    }
    else
    if( function == p_Piezo2BrdSernumR )
    {
		pToFpga->addr = Piezo2BrdSernumRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo2BrdTmpR )
    {
		pToFpga->addr = Piezo2BrdTmpRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo2C1InR )
    {
		pToFpga->addr = Piezo2C1InRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo2C1IpR )
    {
		pToFpga->addr = Piezo2C1IpRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo2C1DriveVR )
    {
		pToFpga->addr = Piezo2C1DriveVRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo2C1OutVR )
    {
		pToFpga->addr = Piezo2C1OutVRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo2C2InR )
    {
		pToFpga->addr = Piezo2C2InRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo2C2IpR )
    {
		pToFpga->addr = Piezo2C2IpRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo2C2DriveVR )
    {
		pToFpga->addr = Piezo2C2DriveVRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo2C2OutVR )
    {
		pToFpga->addr = Piezo2C2OutVRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo2CntlR )
    {
		pToFpga->addr = Piezo2CntlRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo2CntlW )
    {
		pToFpga->addr = Piezo2CntlWAdr;
    }
    else
    if( function == p_Piezo2Dac1R )
    {
		pToFpga->addr = Piezo2Dac1RAdr|flagReadMask;
    }
    else
    if( function == p_Piezo2Dac1W )
    {
		pToFpga->addr = Piezo2Dac1WAdr;
    }
    else
    if( function == p_Piezo2Dac2R )
    {
		pToFpga->addr = Piezo2Dac2RAdr|flagReadMask;
    }
    else
    if( function == p_Piezo2Dac2W )
    {
		pToFpga->addr = Piezo2Dac2WAdr;
    }
    else
    if( function == p_Piezo2HighWindowR )
    {
		pToFpga->addr = Piezo2HighWindowRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo2HighWindowW )
    {
		pToFpga->addr = Piezo2HighWindowWAdr;
    }
    else
    if( function == p_Piezo2IgainR )
    {
		pToFpga->addr = Piezo2IgainRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo2IgainW )
    {
		pToFpga->addr = Piezo2IgainWAdr;
    }
    else
    if( function == p_Piezo2LowWindowR )
    {
		pToFpga->addr = Piezo2LowWindowRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo2LowWindowW )
    {
		pToFpga->addr = Piezo2LowWindowWAdr;
    }
    else
    if( function == p_Piezo2StatR )
    {
		pToFpga->addr = Piezo2StatRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo3Adc1R )
    {
		pToFpga->addr = Piezo3Adc1RAdr|flagReadMask;
    }
    else
    if( function == p_Piezo3Adc2R )
    {
		pToFpga->addr = Piezo3Adc2RAdr|flagReadMask;
    }
    else
    if( function == p_Piezo3BrdSernumR )
    {
		pToFpga->addr = Piezo3BrdSernumRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo3BrdTmpR )
    {
		pToFpga->addr = Piezo3BrdTmpRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo3C1InR )
    {
		pToFpga->addr = Piezo3C1InRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo3C1IpR )
    {
		pToFpga->addr = Piezo3C1IpRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo3C1DriveVR )
    {
		pToFpga->addr = Piezo3C1DriveVRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo3C1OutVR )
    {
		pToFpga->addr = Piezo3C1OutVRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo3C2InR )
    {
		pToFpga->addr = Piezo3C2InRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo3C2IpR )
    {
		pToFpga->addr = Piezo3C2IpRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo3C2DriveVR )
    {
		pToFpga->addr = Piezo3C2DriveVRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo3C2OutVR )
    {
		pToFpga->addr = Piezo3C2OutVRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo3CntlR )
    {
		pToFpga->addr = Piezo3CntlRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo3CntlW )
    {
		pToFpga->addr = Piezo3CntlWAdr;
    }
    else
    if( function == p_Piezo3Dac1R )
    {
		pToFpga->addr = Piezo3Dac1RAdr|flagReadMask;
    }
    else
    if( function == p_Piezo3Dac1W )
    {
		pToFpga->addr = Piezo3Dac1WAdr;
    }
    else
    if( function == p_Piezo3Dac2R )
    {
		pToFpga->addr = Piezo3Dac2RAdr|flagReadMask;
    }
    else
    if( function == p_Piezo3Dac2W )
    {
		pToFpga->addr = Piezo3Dac2WAdr;
    }
    else
    if( function == p_Piezo3HighWindowR )
    {
		pToFpga->addr = Piezo3HighWindowRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo3HighWindowW )
    {
		pToFpga->addr = Piezo3HighWindowWAdr;
    }
    else
    if( function == p_Piezo3IgainR )
    {
		pToFpga->addr = Piezo3IgainRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo3IgainW )
    {
		pToFpga->addr = Piezo3IgainWAdr;
    }
    else
    if( function == p_Piezo3LowWindowR )
    {
		pToFpga->addr = Piezo3LowWindowRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo3LowWindowW )
    {
		pToFpga->addr = Piezo3LowWindowWAdr;
    }
    else
    if( function == p_Piezo3StatR )
    {
		pToFpga->addr = Piezo3StatRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo4Adc1R )
    {
		pToFpga->addr = Piezo4Adc1RAdr|flagReadMask;
    }
    else
    if( function == p_Piezo4Adc2R )
    {
		pToFpga->addr = Piezo4Adc2RAdr|flagReadMask;
    }
    else
    if( function == p_Piezo4BrdSernumR )
    {
		pToFpga->addr = Piezo4BrdSernumRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo4BrdTmpR )
    {
		pToFpga->addr = Piezo4BrdTmpRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo4C1InR )
    {
		pToFpga->addr = Piezo4C1InRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo4C1IpR )
    {
		pToFpga->addr = Piezo4C1IpRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo4C1DriveVR )
    {
		pToFpga->addr = Piezo4C1DriveVRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo4C1OutVR )
    {
		pToFpga->addr = Piezo4C1OutVRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo4C2InR )
    {
		pToFpga->addr = Piezo4C2InRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo4C2IpR )
    {
		pToFpga->addr = Piezo4C2IpRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo4C2DriveVR )
    {
		pToFpga->addr = Piezo4C2DriveVRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo4C2OutVR )
    {
		pToFpga->addr = Piezo4C2OutVRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo4CntlR )
    {
		pToFpga->addr = Piezo4CntlRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo4CntlW )
    {
		pToFpga->addr = Piezo4CntlWAdr;
    }
    else
    if( function == p_Piezo4Dac1R )
    {
		pToFpga->addr = Piezo4Dac1RAdr|flagReadMask;
    }
    else
    if( function == p_Piezo4Dac1W )
    {
		pToFpga->addr = Piezo4Dac1WAdr;
    }
    else
    if( function == p_Piezo4Dac2R )
    {
		pToFpga->addr = Piezo4Dac2RAdr|flagReadMask;
    }
    else
    if( function == p_Piezo4Dac2W )
    {
		pToFpga->addr = Piezo4Dac2WAdr;
    }
    else
    if( function == p_Piezo4HighWindowR )
    {
		pToFpga->addr = Piezo4HighWindowRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo4HighWindowW )
    {
		pToFpga->addr = Piezo4HighWindowWAdr;
    }
    else
    if( function == p_Piezo4IgainR )
    {
		pToFpga->addr = Piezo4IgainRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo4IgainW )
    {
		pToFpga->addr = Piezo4IgainWAdr;
    }
    else
    if( function == p_Piezo4LowWindowR )
    {
		pToFpga->addr = Piezo4LowWindowRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo4LowWindowW )
    {
		pToFpga->addr = Piezo4LowWindowWAdr;
    }
    else
    if( function == p_Piezo4StatR )
    {
		pToFpga->addr = Piezo4StatRAdr|flagReadMask;
    }
    else
    if( function == p_PztWaveAvailR )
    {
		pToFpga->addr = PztWaveAvailRAdr|flagReadMask;
    }
    else
    if( function == p_Reserved0R )
    {
		pToFpga->addr = Reserved0RAdr|flagReadMask;
    }
    else
    if( function == p_Reserved0W )
    {
		pToFpga->addr = Reserved0WAdr;
    }
    else
    if( function == p_Reserved1R )
    {
		pToFpga->addr = Reserved1RAdr|flagReadMask;
    }
    else
    if( function == p_Reserved1W )
    {
		pToFpga->addr = Reserved1WAdr;
    }
    else
    if( function == p_Reserved2R )
    {
		pToFpga->addr = Reserved2RAdr|flagReadMask;
    }
    else
    if( function == p_Reserved2W )
    {
		pToFpga->addr = Reserved2WAdr;
    }
    else
    if( function == p_Reserved3R )
    {
		pToFpga->addr = Reserved3RAdr|flagReadMask;
    }
    else
    if( function == p_Reserved3W )
    {
		pToFpga->addr = Reserved3WAdr;
    }
    else
    if( function == p_Reserved4R )
    {
		pToFpga->addr = Reserved4RAdr|flagReadMask;
    }
    else
    if( function == p_Reserved4W )
    {
		pToFpga->addr = Reserved4WAdr;
    }
    else
    	status = asynError;

    return status;
}

/**  Extract register address and data from the received message and set the appropriate
 * asyn parameter.
 * Some registers have a "new waveform data ready" flag. If they have this and it is set,
 * set weveIsReady to true.
 * Note: This function should not set waveIsReady to false. That is done by a loop in the
 * calling function.
* \param[in] pFromFpga Data returned from the FPGA for a single register
* \param[in] waveIsReady A flag that gets set to true if the appropriate bit was set by the FPGA
*/
asynStatus scllrfRESDriver::processRegReadback(const FpgaReg *pFromFpga, bool &waveIsReady)
{
	asynStatus status = asynSuccess;
	assert(pFromFpga->addr&flagReadMask); // This function is only for read registers
	epicsInt32 errorCount;
	int32_t signExtBits = 0;
	int chan;

	/* Map address to parameter, set the parameter in the parameter library. */
	switch (pFromFpga->addr)
    {
	break;

    case Motor1AccRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Motor1AccR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor1AccRString, (unsigned ) pFromFpga->data);
	break;

    case Motor1VlctyRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Motor1VlctyR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor1VlctyRString, (unsigned ) pFromFpga->data);
	break;

    case Motor1StepsRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Motor1StepsR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor1StepsRString, (unsigned ) pFromFpga->data);
	break;

    case Motor1SgnStepsRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Motor1SgnStepsR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor1SgnStepsRString, (unsigned ) pFromFpga->data);
	break;

    case Motor1AbsStepsRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Motor1AbsStepsR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor1AbsStepsRString, (unsigned ) pFromFpga->data);
	break;

    case Motor1LaccRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Motor1LaccR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor1LaccRString, (unsigned ) pFromFpga->data);
	break;

    case Motor1LvlctyRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Motor1LvlctyR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor1LvlctyRString, (unsigned ) pFromFpga->data);
	break;

    case Motor1LstepsRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Motor1LstepsR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor1LstepsRString, (unsigned ) pFromFpga->data);
	break;

    case Motor1DrviRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Motor1DrviR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor1DrviRString, (unsigned ) pFromFpga->data);
	break;

    case Motor1BrdTmpRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Motor1BrdTmpR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor1BrdTmpRString, (unsigned ) pFromFpga->data);
	break;

    case Motor1CntlRAdr|flagReadMask:

		status = (asynStatus) setUIntDigitalParam(p_Motor1CntlR,
				pFromFpga->data , Motor1CntlMask);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor1CntlRString, (unsigned ) pFromFpga->data);
	break;

    case Motor1StatRAdr|flagReadMask:

		status = (asynStatus) setUIntDigitalParam(p_Motor1StatR,
				pFromFpga->data , Motor1StatMask);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor1StatRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo1Dac1RAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo1Dac1R,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1Dac1RString, (unsigned ) pFromFpga->data);
	break;

    case Piezo1Dac2RAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo1Dac2R,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1Dac2RString, (unsigned ) pFromFpga->data);
	break;

    case Piezo1Adc1RAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo1Adc1R,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1Adc1RString, (unsigned ) pFromFpga->data);
	break;

    case Piezo1Adc2RAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo1Adc2R,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1Adc2RString, (unsigned ) pFromFpga->data);
	break;

    case Piezo1HighWindowRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo1HighWindowR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1HighWindowRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo1LowWindowRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo1LowWindowR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1LowWindowRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo1CntlRAdr|flagReadMask:

		status = (asynStatus) setUIntDigitalParam(p_Piezo1CntlR,
				pFromFpga->data , Piezo1CntlMask);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1CntlRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo1StatRAdr|flagReadMask:

		status = (asynStatus) setUIntDigitalParam(p_Piezo1StatR,
				pFromFpga->data , Piezo1StatMask);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1StatRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo1BrdTmpRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo1BrdTmpR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1BrdTmpRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo1BrdSernumRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo1BrdSernumR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1BrdSernumRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo1IgainRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo1IgainR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1IgainRString, (unsigned ) pFromFpga->data);
	break;

    case Cavity1DetuneErrRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Cavity1DetuneErrR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1DetuneErrRString, (unsigned ) pFromFpga->data);
	break;

    case Motor2AccRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Motor2AccR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor2AccRString, (unsigned ) pFromFpga->data);
	break;

    case Motor2VlctyRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Motor2VlctyR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor2VlctyRString, (unsigned ) pFromFpga->data);
	break;

    case Motor2StepsRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Motor2StepsR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor2StepsRString, (unsigned ) pFromFpga->data);
	break;

    case Motor2SgnStepsRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Motor2SgnStepsR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor2SgnStepsRString, (unsigned ) pFromFpga->data);
	break;

    case Motor2AbsStepsRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Motor2AbsStepsR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor2AbsStepsRString, (unsigned ) pFromFpga->data);
	break;

    case Motor2LaccRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Motor2LaccR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor2LaccRString, (unsigned ) pFromFpga->data);
	break;

    case Motor2LvlctyRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Motor2LvlctyR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor2LvlctyRString, (unsigned ) pFromFpga->data);
	break;

    case Motor2LstepsRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Motor2LstepsR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor2LstepsRString, (unsigned ) pFromFpga->data);
	break;

    case Motor2DrviRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Motor2DrviR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor2DrviRString, (unsigned ) pFromFpga->data);
	break;

    case Motor2BrdTmpRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Motor2BrdTmpR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor2BrdTmpRString, (unsigned ) pFromFpga->data);
	break;

    case Motor2CntlRAdr|flagReadMask:

		status = (asynStatus) setUIntDigitalParam(p_Motor2CntlR,
				pFromFpga->data , Motor2CntlMask);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor2CntlRString, (unsigned ) pFromFpga->data);
	break;

    case Motor2StatRAdr|flagReadMask:

		status = (asynStatus) setUIntDigitalParam(p_Motor2StatR,
				pFromFpga->data , Motor2StatMask);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor2StatRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo2Dac1RAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo2Dac1R,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2Dac1RString, (unsigned ) pFromFpga->data);
	break;

    case Piezo2Dac2RAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo2Dac2R,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2Dac2RString, (unsigned ) pFromFpga->data);
	break;

    case Piezo2Adc1RAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo2Adc1R,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2Adc1RString, (unsigned ) pFromFpga->data);
	break;

    case Piezo2Adc2RAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo2Adc2R,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2Adc2RString, (unsigned ) pFromFpga->data);
	break;

    case Piezo2HighWindowRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo2HighWindowR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2HighWindowRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo2LowWindowRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo2LowWindowR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2LowWindowRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo2CntlRAdr|flagReadMask:

		status = (asynStatus) setUIntDigitalParam(p_Piezo2CntlR,
				pFromFpga->data , Piezo2CntlMask);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2CntlRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo2StatRAdr|flagReadMask:

		status = (asynStatus) setUIntDigitalParam(p_Piezo2StatR,
				pFromFpga->data , Piezo2StatMask);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2StatRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo2BrdTmpRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo2BrdTmpR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2BrdTmpRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo2BrdSernumRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo2BrdSernumR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2BrdSernumRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo2IgainRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo2IgainR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2IgainRString, (unsigned ) pFromFpga->data);
	break;

    case Cavity2DetuneErrRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Cavity2DetuneErrR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity2DetuneErrRString, (unsigned ) pFromFpga->data);
	break;

    case Motor3AccRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Motor3AccR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor3AccRString, (unsigned ) pFromFpga->data);
	break;

    case Motor3VlctyRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Motor3VlctyR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor3VlctyRString, (unsigned ) pFromFpga->data);
	break;

    case Motor3StepsRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Motor3StepsR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor3StepsRString, (unsigned ) pFromFpga->data);
	break;

    case Motor3SgnStepsRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Motor3SgnStepsR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor3SgnStepsRString, (unsigned ) pFromFpga->data);
	break;

    case Motor3AbsStepsRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Motor3AbsStepsR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor3AbsStepsRString, (unsigned ) pFromFpga->data);
	break;

    case Motor3LaccRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Motor3LaccR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor3LaccRString, (unsigned ) pFromFpga->data);
	break;

    case Motor3LvlctyRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Motor3LvlctyR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor3LvlctyRString, (unsigned ) pFromFpga->data);
	break;

    case Motor3LstepsRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Motor3LstepsR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor3LstepsRString, (unsigned ) pFromFpga->data);
	break;

    case Motor3DrviRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Motor3DrviR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor3DrviRString, (unsigned ) pFromFpga->data);
	break;

    case Motor3BrdTmpRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Motor3BrdTmpR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor3BrdTmpRString, (unsigned ) pFromFpga->data);
	break;

    case Motor3CntlRAdr|flagReadMask:

		status = (asynStatus) setUIntDigitalParam(p_Motor3CntlR,
				pFromFpga->data , Motor3CntlMask);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor3CntlRString, (unsigned ) pFromFpga->data);
	break;

    case Motor3StatRAdr|flagReadMask:

		status = (asynStatus) setUIntDigitalParam(p_Motor3StatR,
				pFromFpga->data , Motor3StatMask);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor3StatRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo3Dac1RAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo3Dac1R,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3Dac1RString, (unsigned ) pFromFpga->data);
	break;

    case Piezo3Dac2RAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo3Dac2R,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3Dac2RString, (unsigned ) pFromFpga->data);
	break;

    case Piezo3Adc1RAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo3Adc1R,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3Adc1RString, (unsigned ) pFromFpga->data);
	break;

    case Piezo3Adc2RAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo3Adc2R,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3Adc2RString, (unsigned ) pFromFpga->data);
	break;

    case Piezo3HighWindowRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo3HighWindowR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3HighWindowRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo3LowWindowRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo3LowWindowR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3LowWindowRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo3CntlRAdr|flagReadMask:

		status = (asynStatus) setUIntDigitalParam(p_Piezo3CntlR,
				pFromFpga->data , Piezo3CntlMask);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3CntlRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo3StatRAdr|flagReadMask:

		status = (asynStatus) setUIntDigitalParam(p_Piezo3StatR,
				pFromFpga->data , Piezo3StatMask);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3StatRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo3BrdTmpRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo3BrdTmpR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3BrdTmpRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo3BrdSernumRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo3BrdSernumR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3BrdSernumRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo3IgainRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo3IgainR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3IgainRString, (unsigned ) pFromFpga->data);
	break;

    case Cavity3DetuneErrRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Cavity3DetuneErrR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity3DetuneErrRString, (unsigned ) pFromFpga->data);
	break;

    case Motor4AccRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Motor4AccR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor4AccRString, (unsigned ) pFromFpga->data);
	break;

    case Motor4VlctyRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Motor4VlctyR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor4VlctyRString, (unsigned ) pFromFpga->data);
	break;

    case Motor4StepsRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Motor4StepsR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor4StepsRString, (unsigned ) pFromFpga->data);
	break;

    case Motor4SgnStepsRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Motor4SgnStepsR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor4SgnStepsRString, (unsigned ) pFromFpga->data);
	break;

    case Motor4AbsStepsRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Motor4AbsStepsR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor4AbsStepsRString, (unsigned ) pFromFpga->data);
	break;

    case Motor4LaccRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Motor4LaccR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor4LaccRString, (unsigned ) pFromFpga->data);
	break;

    case Motor4LvlctyRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Motor4LvlctyR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor4LvlctyRString, (unsigned ) pFromFpga->data);
	break;

    case Motor4LstepsRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Motor4LstepsR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor4LstepsRString, (unsigned ) pFromFpga->data);
	break;

    case Motor4DrviRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Motor4DrviR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor4DrviRString, (unsigned ) pFromFpga->data);
	break;

    case Motor4BrdTmpRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Motor4BrdTmpR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor4BrdTmpRString, (unsigned ) pFromFpga->data);
	break;

    case Motor4CntlRAdr|flagReadMask:

		status = (asynStatus) setUIntDigitalParam(p_Motor4CntlR,
				pFromFpga->data , Motor4CntlMask);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor4CntlRString, (unsigned ) pFromFpga->data);
	break;

    case Motor4StatRAdr|flagReadMask:

		status = (asynStatus) setUIntDigitalParam(p_Motor4StatR,
				pFromFpga->data , Motor4StatMask);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor4StatRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo4Dac1RAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo4Dac1R,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4Dac1RString, (unsigned ) pFromFpga->data);
	break;

    case Piezo4Dac2RAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo4Dac2R,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4Dac2RString, (unsigned ) pFromFpga->data);
	break;

    case Piezo4Adc1RAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo4Adc1R,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4Adc1RString, (unsigned ) pFromFpga->data);
	break;

    case Piezo4Adc2RAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo4Adc2R,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4Adc2RString, (unsigned ) pFromFpga->data);
	break;

    case Piezo4HighWindowRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo4HighWindowR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4HighWindowRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo4LowWindowRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo4LowWindowR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4LowWindowRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo4CntlRAdr|flagReadMask:

		status = (asynStatus) setUIntDigitalParam(p_Piezo4CntlR,
				pFromFpga->data , Piezo4CntlMask);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4CntlRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo4StatRAdr|flagReadMask:

		status = (asynStatus) setUIntDigitalParam(p_Piezo4StatR,
				pFromFpga->data , Piezo4StatMask);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4StatRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo4BrdTmpRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo4BrdTmpR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4BrdTmpRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo4BrdSernumRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo4BrdSernumR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4BrdSernumRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo4IgainRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo4IgainR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4IgainRString, (unsigned ) pFromFpga->data);
	break;

    case Cavity4DetuneErrRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Cavity4DetuneErrR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity4DetuneErrRString, (unsigned ) pFromFpga->data);
	break;

    case Motor1SubStpRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Motor1SubStpR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor1SubStpRString, (unsigned ) pFromFpga->data);
	break;

    case Motor2SubStpRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Motor2SubStpR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor2SubStpRString, (unsigned ) pFromFpga->data);
	break;

    case Motor3SubStpRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Motor3SubStpR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor3SubStpRString, (unsigned ) pFromFpga->data);
	break;

    case Motor4SubStpRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Motor4SubStpR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor4SubStpRString, (unsigned ) pFromFpga->data);
	break;

    case Reserved0RAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Reserved0R,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Reserved0RString, (unsigned ) pFromFpga->data);
	break;

    case Reserved1RAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Reserved1R,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Reserved1RString, (unsigned ) pFromFpga->data);
	break;

    case Reserved2RAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Reserved2R,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Reserved2RString, (unsigned ) pFromFpga->data);
	break;

    case Reserved3RAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Reserved3R,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Reserved3RString, (unsigned ) pFromFpga->data);
	break;

    case Reserved4RAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Reserved4R,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Reserved4RString, (unsigned ) pFromFpga->data);
	break;

    case Motor1StepsActualRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Motor1StepsActualR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor1StepsActualRString, (unsigned ) pFromFpga->data);
	break;

    case Motor2StepsActualRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Motor2StepsActualR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor2StepsActualRString, (unsigned ) pFromFpga->data);
	break;

    case Motor3StepsActualRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Motor3StepsActualR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor3StepsActualRString, (unsigned ) pFromFpga->data);
	break;

    case Motor4StepsActualRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Motor4StepsActualR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor4StepsActualRString, (unsigned ) pFromFpga->data);
	break;

    case PztWaveAvailRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_PztWaveAvailR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				PztWaveAvailRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo1C1InRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo1C1InR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1C1InRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo1C1IpRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo1C1IpR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1C1IpRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo1C1OutVRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo1C1OutVR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1C1OutVRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo1C1DriveVRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo1C1DriveVR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1C1DriveVRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo1C2InRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo1C2InR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1C2InRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo1C2IpRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo1C2IpR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1C2IpRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo1C2OutVRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo1C2OutVR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1C2OutVRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo1C2DriveVRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo1C2DriveVR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1C2DriveVRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo2C1InRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo2C1InR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2C1InRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo2C1IpRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo2C1IpR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2C1IpRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo2C1OutVRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo2C1OutVR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2C1OutVRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo2C1DriveVRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo2C1DriveVR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2C1DriveVRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo2C2InRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo2C2InR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2C2InRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo2C2IpRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo2C2IpR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2C2IpRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo2C2OutVRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo2C2OutVR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2C2OutVRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo2C2DriveVRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo2C2DriveVR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2C2DriveVRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo3C1InRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo3C1InR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3C1InRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo3C1IpRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo3C1IpR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3C1IpRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo3C1OutVRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo3C1OutVR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3C1OutVRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo3C1DriveVRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo3C1DriveVR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3C1DriveVRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo3C2InRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo3C2InR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3C2InRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo3C2IpRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo3C2IpR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3C2IpRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo3C2OutVRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo3C2OutVR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3C2OutVRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo3C2DriveVRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo3C2DriveVR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3C2DriveVRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo4C1InRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo4C1InR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4C1InRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo4C1IpRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo4C1IpR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4C1IpRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo4C1OutVRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo4C1OutVR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4C1OutVRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo4C1DriveVRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo4C1DriveVR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4C1DriveVRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo4C2InRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo4C2InR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4C2InRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo4C2IpRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo4C2IpR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4C2IpRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo4C2OutVRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo4C2OutVR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4C2OutVRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo4C2DriveVRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_Piezo4C2DriveVR,
				pFromFpga->data );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4C2DriveVRString, (unsigned ) pFromFpga->data);
		break;

	default:
		// Arrays larger than 16 elements should be handled in a subclass, generally more complicated
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value read from unmapped address 0x%X, value=0x%X\n", __PRETTY_FUNCTION__,
				pFromFpga->addr, (unsigned ) pFromFpga->data);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
			status = asynError;
		}

		break;
    }

    return status;
}


/**  Extract register address and data from the received message and set the appropriate
 * asyn parameter.
 * Some registers have a "new waveform data ready" flag. If they have this and it is set,
 * set weveIsReady to true.
 * Note: This function should not set waveIsReady to false. That is done by a loop in the
 * calling function.
* \param[in] pFromFpga Data returned from the FPGA for a single register
* \param[in] waveIsReady A flag that gets set to true if the appropriate bit was set by the FPGA
*/
asynStatus scllrfRESDriver::processRegWriteResponse(const FpgaReg *pFromFpga)
{
	asynStatus status = asynSuccess;
	epicsInt32 valueSet; // Put the value sent to the FPGA here for comparison
	epicsUInt32 uValueSet;
	epicsInt32 errorCount;
//  variables that may be useful for checking array data
//	asynUser *pAsynArrayUser;
//	unsigned int i;

	/* Map address to parameter, set the parameter in the parameter library. */
	switch (pFromFpga->addr)
    {
    case Motor1AccWAdr:
		status = (asynStatus) getIntegerParam(p_Motor1AccW, &valueSet );
		if( (int32_t)(valueSet ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor1AccWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Motor1AccWString, valueSet , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Motor1AccW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Motor1VlctyWAdr:
		status = (asynStatus) getIntegerParam(p_Motor1VlctyW, &valueSet );
		if( (int32_t)(valueSet ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor1VlctyWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Motor1VlctyWString, valueSet , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Motor1VlctyW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Motor1StepsWAdr:
		status = (asynStatus) getIntegerParam(p_Motor1StepsW, &valueSet );
		if( (int32_t)(valueSet ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor1StepsWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Motor1StepsWString, valueSet , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Motor1StepsW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Motor1DrviWAdr:
		status = (asynStatus) getIntegerParam(p_Motor1DrviW, &valueSet );
		if( (int32_t)(valueSet ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor1DrviWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Motor1DrviWString, valueSet , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Motor1DrviW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Motor1CntlWAdr:
		status = (asynStatus) getUIntDigitalParam(p_Motor1CntlW, &uValueSet , Motor1CntlMask);
		if( (int32_t)(uValueSet ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor1CntlWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Motor1CntlWString, uValueSet , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Motor1CntlW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Piezo1Dac1WAdr:
		status = (asynStatus) getIntegerParam(p_Piezo1Dac1W, &valueSet );
		if( (int32_t)(valueSet ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1Dac1WString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1Dac1WString, valueSet , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Piezo1Dac1W, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Piezo1Dac2WAdr:
		status = (asynStatus) getIntegerParam(p_Piezo1Dac2W, &valueSet );
		if( (int32_t)(valueSet ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1Dac2WString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1Dac2WString, valueSet , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Piezo1Dac2W, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Piezo1HighWindowWAdr:
		status = (asynStatus) getIntegerParam(p_Piezo1HighWindowW, &valueSet );
		if( (int32_t)(valueSet ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1HighWindowWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1HighWindowWString, valueSet , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Piezo1HighWindowW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Piezo1LowWindowWAdr:
		status = (asynStatus) getIntegerParam(p_Piezo1LowWindowW, &valueSet );
		if( (int32_t)(valueSet ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1LowWindowWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1LowWindowWString, valueSet , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Piezo1LowWindowW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Piezo1CntlWAdr:
		status = (asynStatus) getUIntDigitalParam(p_Piezo1CntlW, &uValueSet , Piezo1CntlMask);
		if( (int32_t)(uValueSet ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1CntlWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1CntlWString, uValueSet , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Piezo1CntlW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Piezo1IgainWAdr:
		status = (asynStatus) getIntegerParam(p_Piezo1IgainW, &valueSet );
		if( (int32_t)(valueSet ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1IgainWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1IgainWString, valueSet , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Piezo1IgainW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Motor2AccWAdr:
		status = (asynStatus) getIntegerParam(p_Motor2AccW, &valueSet );
		if( (int32_t)(valueSet ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor2AccWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Motor2AccWString, valueSet , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Motor2AccW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Motor2VlctyWAdr:
		status = (asynStatus) getIntegerParam(p_Motor2VlctyW, &valueSet );
		if( (int32_t)(valueSet ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor2VlctyWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Motor2VlctyWString, valueSet , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Motor2VlctyW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Motor2StepsWAdr:
		status = (asynStatus) getIntegerParam(p_Motor2StepsW, &valueSet );
		if( (int32_t)(valueSet ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor2StepsWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Motor2StepsWString, valueSet , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Motor2StepsW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Motor2DrviWAdr:
		status = (asynStatus) getIntegerParam(p_Motor2DrviW, &valueSet );
		if( (int32_t)(valueSet ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor2DrviWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Motor2DrviWString, valueSet , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Motor2DrviW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Motor2CntlWAdr:
		status = (asynStatus) getUIntDigitalParam(p_Motor2CntlW, &uValueSet , Motor2CntlMask);
		if( (int32_t)(uValueSet ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor2CntlWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Motor2CntlWString, uValueSet , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Motor2CntlW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Piezo2Dac1WAdr:
		status = (asynStatus) getIntegerParam(p_Piezo2Dac1W, &valueSet );
		if( (int32_t)(valueSet ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2Dac1WString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2Dac1WString, valueSet , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Piezo2Dac1W, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Piezo2Dac2WAdr:
		status = (asynStatus) getIntegerParam(p_Piezo2Dac2W, &valueSet );
		if( (int32_t)(valueSet ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2Dac2WString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2Dac2WString, valueSet , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Piezo2Dac2W, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Piezo2HighWindowWAdr:
		status = (asynStatus) getIntegerParam(p_Piezo2HighWindowW, &valueSet );
		if( (int32_t)(valueSet ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2HighWindowWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2HighWindowWString, valueSet , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Piezo2HighWindowW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Piezo2LowWindowWAdr:
		status = (asynStatus) getIntegerParam(p_Piezo2LowWindowW, &valueSet );
		if( (int32_t)(valueSet ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2LowWindowWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2LowWindowWString, valueSet , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Piezo2LowWindowW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Piezo2CntlWAdr:
		status = (asynStatus) getUIntDigitalParam(p_Piezo2CntlW, &uValueSet , Piezo2CntlMask);
		if( (int32_t)(uValueSet ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2CntlWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2CntlWString, uValueSet , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Piezo2CntlW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Piezo2IgainWAdr:
		status = (asynStatus) getIntegerParam(p_Piezo2IgainW, &valueSet );
		if( (int32_t)(valueSet ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2IgainWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2IgainWString, valueSet , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Piezo2IgainW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Motor3AccWAdr:
		status = (asynStatus) getIntegerParam(p_Motor3AccW, &valueSet );
		if( (int32_t)(valueSet ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor3AccWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Motor3AccWString, valueSet , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Motor3AccW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Motor3VlctyWAdr:
		status = (asynStatus) getIntegerParam(p_Motor3VlctyW, &valueSet );
		if( (int32_t)(valueSet ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor3VlctyWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Motor3VlctyWString, valueSet , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Motor3VlctyW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Motor3StepsWAdr:
		status = (asynStatus) getIntegerParam(p_Motor3StepsW, &valueSet );
		if( (int32_t)(valueSet ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor3StepsWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Motor3StepsWString, valueSet , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Motor3StepsW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Motor3DrviWAdr:
		status = (asynStatus) getIntegerParam(p_Motor3DrviW, &valueSet );
		if( (int32_t)(valueSet ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor3DrviWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Motor3DrviWString, valueSet , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Motor3DrviW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Motor3CntlWAdr:
		status = (asynStatus) getUIntDigitalParam(p_Motor3CntlW, &uValueSet , Motor3CntlMask);
		if( (int32_t)(uValueSet ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor3CntlWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Motor3CntlWString, uValueSet , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Motor3CntlW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Piezo3Dac1WAdr:
		status = (asynStatus) getIntegerParam(p_Piezo3Dac1W, &valueSet );
		if( (int32_t)(valueSet ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3Dac1WString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3Dac1WString, valueSet , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Piezo3Dac1W, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Piezo3Dac2WAdr:
		status = (asynStatus) getIntegerParam(p_Piezo3Dac2W, &valueSet );
		if( (int32_t)(valueSet ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3Dac2WString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3Dac2WString, valueSet , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Piezo3Dac2W, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Piezo3HighWindowWAdr:
		status = (asynStatus) getIntegerParam(p_Piezo3HighWindowW, &valueSet );
		if( (int32_t)(valueSet ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3HighWindowWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3HighWindowWString, valueSet , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Piezo3HighWindowW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Piezo3LowWindowWAdr:
		status = (asynStatus) getIntegerParam(p_Piezo3LowWindowW, &valueSet );
		if( (int32_t)(valueSet ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3LowWindowWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3LowWindowWString, valueSet , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Piezo3LowWindowW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Piezo3CntlWAdr:
		status = (asynStatus) getUIntDigitalParam(p_Piezo3CntlW, &uValueSet , Piezo3CntlMask);
		if( (int32_t)(uValueSet ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3CntlWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3CntlWString, uValueSet , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Piezo3CntlW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Piezo3IgainWAdr:
		status = (asynStatus) getIntegerParam(p_Piezo3IgainW, &valueSet );
		if( (int32_t)(valueSet ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3IgainWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3IgainWString, valueSet , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Piezo3IgainW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Motor4AccWAdr:
		status = (asynStatus) getIntegerParam(p_Motor4AccW, &valueSet );
		if( (int32_t)(valueSet ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor4AccWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Motor4AccWString, valueSet , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Motor4AccW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Motor4VlctyWAdr:
		status = (asynStatus) getIntegerParam(p_Motor4VlctyW, &valueSet );
		if( (int32_t)(valueSet ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor4VlctyWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Motor4VlctyWString, valueSet , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Motor4VlctyW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Motor4StepsWAdr:
		status = (asynStatus) getIntegerParam(p_Motor4StepsW, &valueSet );
		if( (int32_t)(valueSet ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor4StepsWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Motor4StepsWString, valueSet , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Motor4StepsW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Motor4DrviWAdr:
		status = (asynStatus) getIntegerParam(p_Motor4DrviW, &valueSet );
		if( (int32_t)(valueSet ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor4DrviWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Motor4DrviWString, valueSet , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Motor4DrviW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Motor4CntlWAdr:
		status = (asynStatus) getUIntDigitalParam(p_Motor4CntlW, &uValueSet , Motor4CntlMask);
		if( (int32_t)(uValueSet ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor4CntlWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Motor4CntlWString, uValueSet , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Motor4CntlW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Piezo4Dac1WAdr:
		status = (asynStatus) getIntegerParam(p_Piezo4Dac1W, &valueSet );
		if( (int32_t)(valueSet ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4Dac1WString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4Dac1WString, valueSet , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Piezo4Dac1W, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Piezo4Dac2WAdr:
		status = (asynStatus) getIntegerParam(p_Piezo4Dac2W, &valueSet );
		if( (int32_t)(valueSet ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4Dac2WString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4Dac2WString, valueSet , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Piezo4Dac2W, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Piezo4HighWindowWAdr:
		status = (asynStatus) getIntegerParam(p_Piezo4HighWindowW, &valueSet );
		if( (int32_t)(valueSet ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4HighWindowWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4HighWindowWString, valueSet , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Piezo4HighWindowW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Piezo4LowWindowWAdr:
		status = (asynStatus) getIntegerParam(p_Piezo4LowWindowW, &valueSet );
		if( (int32_t)(valueSet ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4LowWindowWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4LowWindowWString, valueSet , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Piezo4LowWindowW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Piezo4CntlWAdr:
		status = (asynStatus) getUIntDigitalParam(p_Piezo4CntlW, &uValueSet , Piezo4CntlMask);
		if( (int32_t)(uValueSet ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4CntlWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4CntlWString, uValueSet , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Piezo4CntlW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Piezo4IgainWAdr:
		status = (asynStatus) getIntegerParam(p_Piezo4IgainW, &valueSet );
		if( (int32_t)(valueSet ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4IgainWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4IgainWString, valueSet , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Piezo4IgainW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Motor1SubStpWAdr:
		status = (asynStatus) getIntegerParam(p_Motor1SubStpW, &valueSet );
		if( (int32_t)(valueSet ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor1SubStpWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Motor1SubStpWString, valueSet , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Motor1SubStpW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Motor2SubStpWAdr:
		status = (asynStatus) getIntegerParam(p_Motor2SubStpW, &valueSet );
		if( (int32_t)(valueSet ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor2SubStpWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Motor2SubStpWString, valueSet , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Motor2SubStpW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Motor3SubStpWAdr:
		status = (asynStatus) getIntegerParam(p_Motor3SubStpW, &valueSet );
		if( (int32_t)(valueSet ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor3SubStpWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Motor3SubStpWString, valueSet , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Motor3SubStpW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Motor4SubStpWAdr:
		status = (asynStatus) getIntegerParam(p_Motor4SubStpW, &valueSet );
		if( (int32_t)(valueSet ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor4SubStpWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Motor4SubStpWString, valueSet , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Motor4SubStpW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Reserved0WAdr:
		status = (asynStatus) getIntegerParam(p_Reserved0W, &valueSet );
		if( (int32_t)(valueSet ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Reserved0WString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Reserved0WString, valueSet , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Reserved0W, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Reserved1WAdr:
		status = (asynStatus) getIntegerParam(p_Reserved1W, &valueSet );
		if( (int32_t)(valueSet ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Reserved1WString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Reserved1WString, valueSet , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Reserved1W, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Reserved2WAdr:
		status = (asynStatus) getIntegerParam(p_Reserved2W, &valueSet );
		if( (int32_t)(valueSet ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Reserved2WString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Reserved2WString, valueSet , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Reserved2W, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Reserved3WAdr:
		status = (asynStatus) getIntegerParam(p_Reserved3W, &valueSet );
		if( (int32_t)(valueSet ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Reserved3WString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Reserved3WString, valueSet , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Reserved3W, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Reserved4WAdr:
		status = (asynStatus) getIntegerParam(p_Reserved4W, &valueSet );
		if( (int32_t)(valueSet ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Reserved4WString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Reserved4WString, valueSet , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Reserved4W, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
	default:
		// Arrays larger than 16 elements should be handled in a subclass, generally more complicated
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: write response from FPGA for unmapped address 0x%X, value=0x%X\n", __PRETTY_FUNCTION__,
				pFromFpga->addr, (unsigned ) pFromFpga->data);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
			status = asynError;
		}

		break;
    }

	// TODO: handle arrays

    return status;
}



extern "C" {

/* Configuration routine.  Called directly, or from the iocsh function below */

/** EPICS iocsh callable function to call constructor for the scllrfRES class.
 * \param[in] portName The name of the asyn port driver to be created.
 * \param[in] netPortName The name of the asynIPport this will use to communicate */
int scllrfRESConfigure(const char *drvPortName, const char *netPortName)
{
	//new scllrfRESDriver(drvPortName, netPortName);
	new scllrfRESDriver(drvPortName, netPortName, 8, 0);
	return asynSuccess;
}


/* EPICS iocsh shell commands */

static const iocshArg initArg0 = { "drvPortName",iocshArgString};
static const iocshArg initArg1 = { "IP port name",iocshArgString};
static const iocshArg * const initArgs[] = {&initArg0,
		&initArg1};
static const iocshFuncDef initFuncDef = {"scllrfRESConfigure",2,initArgs};
static void initCallFunc(const iocshArgBuf *args)
{
	scllrfRESConfigure(args[0].sval, args[1].sval);
}

void scllrfRESRegister(void)
{
	iocshRegister(&initFuncDef,initCallFunc);
}

epicsExportRegistrar(scllrfRESRegister);

}




/**
 *-----------------------------------------------------------------------------
 * Title      : superconducting low level RF EPICS interface
 * ----------------------------------------------------------------------------
 * File       : templateScllrfDriver.h
 * Author     : Garth Brown, gwbrown@slac.stanford.edu
 * Created    : June 17, 2016
 * Last update: September 6, 2016
 * ----------------------------------------------------------------------------
 * Description:
 * Header defining register interface to scllrfRES, autogenerated from a python
 * dictionary.
 *
 * ----------------------------------------------------------------------------
 * This file is part of LCLS II. It is subject to
 * the license terms in the LICENSE.txt file found in the top-level directory
 * of this distribution and at:
    * https://confluence.slac.stanford.edu/display/ppareg/LICENSE.html.
 * No part of LCLS II, including this file, may be
 * copied, modified, propagated, or distributed except according to the terms
 * contained in the LICENSE.txt file.
 * ----------------------------------------------------------------------------
**/

#include "scllrfRES.h"
#include <asynOctetSyncIO.h>
#include <asynCommonSyncIO.h>
#include <limits>
#include <netinet/in.h>
#include <iostream>
using namespace std;
#include <math.h>

/** Constructor for the scllrfRES class.
 * Calls constructor for the asynPortDriver base class.
 * \param[in] portName The name of the asyn port driver to be created.
 * \param[in] path The path to the peripherial as built by the builder api
 * \param[in] nelms The number of elements of this device (max addr)
 * \paarm[in] nEntries The number of asyn params to be created for each device
 *
 * */
scllrfRESDriver::scllrfRESDriver(const char *drvPortName, const char *netPortName)
: scllrfAsynPortDriver(drvPortName, netPortName,
		1, /* maxAddr, i.e. number of channels */
		NUM_SCLLRFRES_PARAMS)
{
	asynStatus status = asynSuccess;

    epicsThreadSleep(defaultPollPeriod);

    createParam(Cavity1DetuneErrRString, asynParamInt32, &p_Cavity1DetuneErrR);
    createParam(Cavity2DetuneErrRString, asynParamInt32, &p_Cavity2DetuneErrR);
    createParam(Cavity3DetuneErrRString, asynParamInt32, &p_Cavity3DetuneErrR);
    createParam(Cavity4DetuneErrRString, asynParamInt32, &p_Cavity4DetuneErrR);
    createParam(Motor1AbsStepsRString, asynParamInt32, &p_Motor1AbsStepsR);
    createParam(Motor1AccRString, asynParamInt32, &p_Motor1AccR);
    createParam(Motor1AccWString, asynParamInt32, &p_Motor1AccW);
    createParam(Motor1BrdTmpRString, asynParamInt32, &p_Motor1BrdTmpR);
    createParam(Motor1CntlRString, asynParamInt32, &p_Motor1CntlR);
	createParam(Motor1CntlBit1RString, asynParamUInt32Digital, &p_Motor1CntlBit1R);
	createParam(Motor1CntlBit2RString, asynParamUInt32Digital, &p_Motor1CntlBit2R);
    createParam(Motor1CntlWString, asynParamInt32, &p_Motor1CntlW);
    createParam(Motor1CntlBit1WString, asynParamUInt32Digital, &p_Motor1CntlBit1W);
    createParam(Motor1CntlBit2WString, asynParamUInt32Digital, &p_Motor1CntlBit2W);
    createParam(Motor1DrviRString, asynParamInt32, &p_Motor1DrviR);
    createParam(Motor1DrviWString, asynParamInt32, &p_Motor1DrviW);
    createParam(Motor1LaccRString, asynParamInt32, &p_Motor1LaccR);
    createParam(Motor1LstepsRString, asynParamInt32, &p_Motor1LstepsR);
    createParam(Motor1LvlctyRString, asynParamInt32, &p_Motor1LvlctyR);
    createParam(Motor1SgnStepsRString, asynParamInt32, &p_Motor1SgnStepsR);
    createParam(Motor1StatRString, asynParamInt32, &p_Motor1StatR);
	createParam(Motor1StatBit1RString, asynParamUInt32Digital, &p_Motor1StatBit1R);
	createParam(Motor1StatBit2RString, asynParamUInt32Digital, &p_Motor1StatBit2R);
    createParam(Motor1StepsRString, asynParamInt32, &p_Motor1StepsR);
    createParam(Motor1StepsWString, asynParamInt32, &p_Motor1StepsW);
    createParam(Motor1VlctyRString, asynParamInt32, &p_Motor1VlctyR);
    createParam(Motor1VlctyWString, asynParamInt32, &p_Motor1VlctyW);
    createParam(Motor2AbsStepsRString, asynParamInt32, &p_Motor2AbsStepsR);
    createParam(Motor2AccRString, asynParamInt32, &p_Motor2AccR);
    createParam(Motor2AccWString, asynParamInt32, &p_Motor2AccW);
    createParam(Motor2BrdTmpRString, asynParamInt32, &p_Motor2BrdTmpR);
    createParam(Motor2CntlRString, asynParamInt32, &p_Motor2CntlR);
	createParam(Motor2CntlBit1RString, asynParamUInt32Digital, &p_Motor2CntlBit1R);
	createParam(Motor2CntlBit2RString, asynParamUInt32Digital, &p_Motor2CntlBit2R);
    createParam(Motor2CntlWString, asynParamInt32, &p_Motor2CntlW);
    createParam(Motor2CntlBit1WString, asynParamUInt32Digital, &p_Motor2CntlBit1W);
    createParam(Motor2CntlBit2WString, asynParamUInt32Digital, &p_Motor2CntlBit2W);
    createParam(Motor2DrviRString, asynParamInt32, &p_Motor2DrviR);
    createParam(Motor2DrviWString, asynParamInt32, &p_Motor2DrviW);
    createParam(Motor2LaccRString, asynParamInt32, &p_Motor2LaccR);
    createParam(Motor2LstepsRString, asynParamInt32, &p_Motor2LstepsR);
    createParam(Motor2LvlctyRString, asynParamInt32, &p_Motor2LvlctyR);
    createParam(Motor2SgnStepsRString, asynParamInt32, &p_Motor2SgnStepsR);
    createParam(Motor2StatRString, asynParamInt32, &p_Motor2StatR);
	createParam(Motor2StatBit1RString, asynParamUInt32Digital, &p_Motor2StatBit1R);
	createParam(Motor2StatBit2RString, asynParamUInt32Digital, &p_Motor2StatBit2R);
    createParam(Motor2StepsRString, asynParamInt32, &p_Motor2StepsR);
    createParam(Motor2StepsWString, asynParamInt32, &p_Motor2StepsW);
    createParam(Motor2VlctyRString, asynParamInt32, &p_Motor2VlctyR);
    createParam(Motor2VlctyWString, asynParamInt32, &p_Motor2VlctyW);
    createParam(Motor3AbsStepsRString, asynParamInt32, &p_Motor3AbsStepsR);
    createParam(Motor3AccRString, asynParamInt32, &p_Motor3AccR);
    createParam(Motor3AccWString, asynParamInt32, &p_Motor3AccW);
    createParam(Motor3BrdTmpRString, asynParamInt32, &p_Motor3BrdTmpR);
    createParam(Motor3CntlRString, asynParamInt32, &p_Motor3CntlR);
	createParam(Motor3CntlBit1RString, asynParamUInt32Digital, &p_Motor3CntlBit1R);
	createParam(Motor3CntlBit2RString, asynParamUInt32Digital, &p_Motor3CntlBit2R);
    createParam(Motor3CntlWString, asynParamInt32, &p_Motor3CntlW);
    createParam(Motor3CntlBit1WString, asynParamUInt32Digital, &p_Motor3CntlBit1W);
    createParam(Motor3CntlBit2WString, asynParamUInt32Digital, &p_Motor3CntlBit2W);
    createParam(Motor3DrviRString, asynParamInt32, &p_Motor3DrviR);
    createParam(Motor3DrviWString, asynParamInt32, &p_Motor3DrviW);
    createParam(Motor3LaccRString, asynParamInt32, &p_Motor3LaccR);
    createParam(Motor3LstepsRString, asynParamInt32, &p_Motor3LstepsR);
    createParam(Motor3LvlctyRString, asynParamInt32, &p_Motor3LvlctyR);
    createParam(Motor3SgnStepsRString, asynParamInt32, &p_Motor3SgnStepsR);
    createParam(Motor3StatRString, asynParamInt32, &p_Motor3StatR);
	createParam(Motor3StatBit1RString, asynParamUInt32Digital, &p_Motor3StatBit1R);
	createParam(Motor3StatBit2RString, asynParamUInt32Digital, &p_Motor3StatBit2R);
    createParam(Motor3StepsRString, asynParamInt32, &p_Motor3StepsR);
    createParam(Motor3StepsWString, asynParamInt32, &p_Motor3StepsW);
    createParam(Motor3VlctyRString, asynParamInt32, &p_Motor3VlctyR);
    createParam(Motor3VlctyWString, asynParamInt32, &p_Motor3VlctyW);
    createParam(Motor4AbsStepsRString, asynParamInt32, &p_Motor4AbsStepsR);
    createParam(Motor4AccRString, asynParamInt32, &p_Motor4AccR);
    createParam(Motor4AccWString, asynParamInt32, &p_Motor4AccW);
    createParam(Motor4BrdTmpRString, asynParamInt32, &p_Motor4BrdTmpR);
    createParam(Motor4CntlRString, asynParamInt32, &p_Motor4CntlR);
	createParam(Motor4CntlBit1RString, asynParamUInt32Digital, &p_Motor4CntlBit1R);
	createParam(Motor4CntlBit2RString, asynParamUInt32Digital, &p_Motor4CntlBit2R);
    createParam(Motor4CntlWString, asynParamInt32, &p_Motor4CntlW);
    createParam(Motor4CntlBit1WString, asynParamUInt32Digital, &p_Motor4CntlBit1W);
    createParam(Motor4CntlBit2WString, asynParamUInt32Digital, &p_Motor4CntlBit2W);
    createParam(Motor4DrviRString, asynParamInt32, &p_Motor4DrviR);
    createParam(Motor4DrviWString, asynParamInt32, &p_Motor4DrviW);
    createParam(Motor4LaccRString, asynParamInt32, &p_Motor4LaccR);
    createParam(Motor4LstepsRString, asynParamInt32, &p_Motor4LstepsR);
    createParam(Motor4LvlctyRString, asynParamInt32, &p_Motor4LvlctyR);
    createParam(Motor4SgnStepsRString, asynParamInt32, &p_Motor4SgnStepsR);
    createParam(Motor4StatRString, asynParamInt32, &p_Motor4StatR);
	createParam(Motor4StatBit1RString, asynParamUInt32Digital, &p_Motor4StatBit1R);
	createParam(Motor4StatBit2RString, asynParamUInt32Digital, &p_Motor4StatBit2R);
    createParam(Motor4StepsRString, asynParamInt32, &p_Motor4StepsR);
    createParam(Motor4StepsWString, asynParamInt32, &p_Motor4StepsW);
    createParam(Motor4VlctyRString, asynParamInt32, &p_Motor4VlctyR);
    createParam(Motor4VlctyWString, asynParamInt32, &p_Motor4VlctyW);
    createParam(Piezo1Adc1RString, asynParamInt32, &p_Piezo1Adc1R);
    createParam(Piezo1Adc2RString, asynParamInt32, &p_Piezo1Adc2R);
    createParam(Piezo1BrdSernumRString, asynParamInt32, &p_Piezo1BrdSernumR);
    createParam(Piezo1BrdTmpRString, asynParamInt32, &p_Piezo1BrdTmpR);
    createParam(Piezo1CntlRString, asynParamInt32, &p_Piezo1CntlR);
	createParam(Piezo1CntlBit1RString, asynParamUInt32Digital, &p_Piezo1CntlBit1R);
	createParam(Piezo1CntlBit2RString, asynParamUInt32Digital, &p_Piezo1CntlBit2R);
    createParam(Piezo1CntlWString, asynParamInt32, &p_Piezo1CntlW);
    createParam(Piezo1CntlBit1WString, asynParamUInt32Digital, &p_Piezo1CntlBit1W);
    createParam(Piezo1CntlBit2WString, asynParamUInt32Digital, &p_Piezo1CntlBit2W);
    createParam(Piezo1Dac1RString, asynParamInt32, &p_Piezo1Dac1R);
    createParam(Piezo1Dac1WString, asynParamInt32, &p_Piezo1Dac1W);
    createParam(Piezo1Dac2RString, asynParamInt32, &p_Piezo1Dac2R);
    createParam(Piezo1Dac2WString, asynParamInt32, &p_Piezo1Dac2W);
    createParam(Piezo1HighWindowRString, asynParamInt32, &p_Piezo1HighWindowR);
    createParam(Piezo1HighWindowWString, asynParamInt32, &p_Piezo1HighWindowW);
    createParam(Piezo1IgainRString, asynParamInt32, &p_Piezo1IgainR);
    createParam(Piezo1IgainWString, asynParamInt32, &p_Piezo1IgainW);
    createParam(Piezo1LowWindowRString, asynParamInt32, &p_Piezo1LowWindowR);
    createParam(Piezo1LowWindowWString, asynParamInt32, &p_Piezo1LowWindowW);
    createParam(Piezo1StatRString, asynParamInt32, &p_Piezo1StatR);
	createParam(Piezo1StatBit1RString, asynParamUInt32Digital, &p_Piezo1StatBit1R);
	createParam(Piezo1StatBit2RString, asynParamUInt32Digital, &p_Piezo1StatBit2R);
    createParam(Piezo2Adc1RString, asynParamInt32, &p_Piezo2Adc1R);
    createParam(Piezo2Adc2RString, asynParamInt32, &p_Piezo2Adc2R);
    createParam(Piezo2BrdSernumRString, asynParamInt32, &p_Piezo2BrdSernumR);
    createParam(Piezo2BrdTmpRString, asynParamInt32, &p_Piezo2BrdTmpR);
    createParam(Piezo2CntlRString, asynParamInt32, &p_Piezo2CntlR);
	createParam(Piezo2CntlBit1RString, asynParamUInt32Digital, &p_Piezo2CntlBit1R);
	createParam(Piezo2CntlBit2RString, asynParamUInt32Digital, &p_Piezo2CntlBit2R);
    createParam(Piezo2CntlWString, asynParamInt32, &p_Piezo2CntlW);
    createParam(Piezo2CntlBit1WString, asynParamUInt32Digital, &p_Piezo2CntlBit1W);
    createParam(Piezo2CntlBit2WString, asynParamUInt32Digital, &p_Piezo2CntlBit2W);
    createParam(Piezo2Dac1RString, asynParamInt32, &p_Piezo2Dac1R);
    createParam(Piezo2Dac1WString, asynParamInt32, &p_Piezo2Dac1W);
    createParam(Piezo2Dac2RString, asynParamInt32, &p_Piezo2Dac2R);
    createParam(Piezo2Dac2WString, asynParamInt32, &p_Piezo2Dac2W);
    createParam(Piezo2HighWindowRString, asynParamInt32, &p_Piezo2HighWindowR);
    createParam(Piezo2HighWindowWString, asynParamInt32, &p_Piezo2HighWindowW);
    createParam(Piezo2IgainRString, asynParamInt32, &p_Piezo2IgainR);
    createParam(Piezo2IgainWString, asynParamInt32, &p_Piezo2IgainW);
    createParam(Piezo2LowWindowRString, asynParamInt32, &p_Piezo2LowWindowR);
    createParam(Piezo2LowWindowWString, asynParamInt32, &p_Piezo2LowWindowW);
    createParam(Piezo2StatRString, asynParamInt32, &p_Piezo2StatR);
	createParam(Piezo2StatBit1RString, asynParamUInt32Digital, &p_Piezo2StatBit1R);
	createParam(Piezo2StatBit2RString, asynParamUInt32Digital, &p_Piezo2StatBit2R);
    createParam(Piezo3Adc1RString, asynParamInt32, &p_Piezo3Adc1R);
    createParam(Piezo3Adc2RString, asynParamInt32, &p_Piezo3Adc2R);
    createParam(Piezo3BrdSernumRString, asynParamInt32, &p_Piezo3BrdSernumR);
    createParam(Piezo3BrdTmpRString, asynParamInt32, &p_Piezo3BrdTmpR);
    createParam(Piezo3CntlRString, asynParamInt32, &p_Piezo3CntlR);
	createParam(Piezo3CntlBit1RString, asynParamUInt32Digital, &p_Piezo3CntlBit1R);
	createParam(Piezo3CntlBit2RString, asynParamUInt32Digital, &p_Piezo3CntlBit2R);
    createParam(Piezo3CntlWString, asynParamInt32, &p_Piezo3CntlW);
    createParam(Piezo3CntlBit1WString, asynParamUInt32Digital, &p_Piezo3CntlBit1W);
    createParam(Piezo3CntlBit2WString, asynParamUInt32Digital, &p_Piezo3CntlBit2W);
    createParam(Piezo3Dac1RString, asynParamInt32, &p_Piezo3Dac1R);
    createParam(Piezo3Dac1WString, asynParamInt32, &p_Piezo3Dac1W);
    createParam(Piezo3Dac2RString, asynParamInt32, &p_Piezo3Dac2R);
    createParam(Piezo3Dac2WString, asynParamInt32, &p_Piezo3Dac2W);
    createParam(Piezo3HighWindowRString, asynParamInt32, &p_Piezo3HighWindowR);
    createParam(Piezo3HighWindowWString, asynParamInt32, &p_Piezo3HighWindowW);
    createParam(Piezo3IgainRString, asynParamInt32, &p_Piezo3IgainR);
    createParam(Piezo3IgainWString, asynParamInt32, &p_Piezo3IgainW);
    createParam(Piezo3LowWindowRString, asynParamInt32, &p_Piezo3LowWindowR);
    createParam(Piezo3LowWindowWString, asynParamInt32, &p_Piezo3LowWindowW);
    createParam(Piezo3StatRString, asynParamInt32, &p_Piezo3StatR);
	createParam(Piezo3StatBit1RString, asynParamUInt32Digital, &p_Piezo3StatBit1R);
	createParam(Piezo3StatBit2RString, asynParamUInt32Digital, &p_Piezo3StatBit2R);
    createParam(Piezo4Adc1RString, asynParamInt32, &p_Piezo4Adc1R);
    createParam(Piezo4Adc2RString, asynParamInt32, &p_Piezo4Adc2R);
    createParam(Piezo4BrdSernumRString, asynParamInt32, &p_Piezo4BrdSernumR);
    createParam(Piezo4BrdTmpRString, asynParamInt32, &p_Piezo4BrdTmpR);
    createParam(Piezo4CntlRString, asynParamInt32, &p_Piezo4CntlR);
	createParam(Piezo4CntlBit1RString, asynParamUInt32Digital, &p_Piezo4CntlBit1R);
	createParam(Piezo4CntlBit2RString, asynParamUInt32Digital, &p_Piezo4CntlBit2R);
    createParam(Piezo4CntlWString, asynParamInt32, &p_Piezo4CntlW);
    createParam(Piezo4CntlBit1WString, asynParamUInt32Digital, &p_Piezo4CntlBit1W);
    createParam(Piezo4CntlBit2WString, asynParamUInt32Digital, &p_Piezo4CntlBit2W);
    createParam(Piezo4Dac1RString, asynParamInt32, &p_Piezo4Dac1R);
    createParam(Piezo4Dac1WString, asynParamInt32, &p_Piezo4Dac1W);
    createParam(Piezo4Dac2RString, asynParamInt32, &p_Piezo4Dac2R);
    createParam(Piezo4Dac2WString, asynParamInt32, &p_Piezo4Dac2W);
    createParam(Piezo4HighWindowRString, asynParamInt32, &p_Piezo4HighWindowR);
    createParam(Piezo4HighWindowWString, asynParamInt32, &p_Piezo4HighWindowW);
    createParam(Piezo4IgainRString, asynParamInt32, &p_Piezo4IgainR);
    createParam(Piezo4IgainWString, asynParamInt32, &p_Piezo4IgainW);
    createParam(Piezo4LowWindowRString, asynParamInt32, &p_Piezo4LowWindowR);
    createParam(Piezo4LowWindowWString, asynParamInt32, &p_Piezo4LowWindowW);
    createParam(Piezo4StatRString, asynParamInt32, &p_Piezo4StatR);
	createParam(Piezo4StatBit1RString, asynParamUInt32Digital, &p_Piezo4StatBit1R);
	createParam(Piezo4StatBit2RString, asynParamUInt32Digital, &p_Piezo4StatBit2R);

	// A canned request to read all registers
    pPolledRegMsg_ = new FpgaReg[readRegCount + 1]
	{
			{ 0, 0 },
			{ flagReadMask | Motor1AccRAdr, blankData },
			{ flagReadMask | Motor1VlctyRAdr, blankData },
			{ flagReadMask | Motor1StepsRAdr, blankData },
			{ flagReadMask | Motor1SgnStepsRAdr, blankData },
			{ flagReadMask | Motor1AbsStepsRAdr, blankData },
			{ flagReadMask | Motor1LaccRAdr, blankData },
			{ flagReadMask | Motor1LvlctyRAdr, blankData },
			{ flagReadMask | Motor1LstepsRAdr, blankData },
			{ flagReadMask | Motor1DrviRAdr, blankData },
			{ flagReadMask | Motor1BrdTmpRAdr, blankData },
			{ flagReadMask | Motor1CntlRAdr, blankData },
			{ flagReadMask | Motor1StatRAdr, blankData },
			{ flagReadMask | Piezo1Dac1RAdr, blankData },
			{ flagReadMask | Piezo1Dac2RAdr, blankData },
			{ flagReadMask | Piezo1Adc1RAdr, blankData },
			{ flagReadMask | Piezo1Adc2RAdr, blankData },
			{ flagReadMask | Piezo1HighWindowRAdr, blankData },
			{ flagReadMask | Piezo1LowWindowRAdr, blankData },
			{ flagReadMask | Piezo1CntlRAdr, blankData },
			{ flagReadMask | Piezo1StatRAdr, blankData },
			{ flagReadMask | Piezo1BrdTmpRAdr, blankData },
			{ flagReadMask | Piezo1BrdSernumRAdr, blankData },
			{ flagReadMask | Piezo1IgainRAdr, blankData },
			{ flagReadMask | Cavity1DetuneErrRAdr, blankData },
			{ flagReadMask | Motor2AccRAdr, blankData },
			{ flagReadMask | Motor2VlctyRAdr, blankData },
			{ flagReadMask | Motor2StepsRAdr, blankData },
			{ flagReadMask | Motor2SgnStepsRAdr, blankData },
			{ flagReadMask | Motor2AbsStepsRAdr, blankData },
			{ flagReadMask | Motor2LaccRAdr, blankData },
			{ flagReadMask | Motor2LvlctyRAdr, blankData },
			{ flagReadMask | Motor2LstepsRAdr, blankData },
			{ flagReadMask | Motor2DrviRAdr, blankData },
			{ flagReadMask | Motor2BrdTmpRAdr, blankData },
			{ flagReadMask | Motor2CntlRAdr, blankData },
			{ flagReadMask | Motor2StatRAdr, blankData },
			{ flagReadMask | Piezo2Dac1RAdr, blankData },
			{ flagReadMask | Piezo2Dac2RAdr, blankData },
			{ flagReadMask | Piezo2Adc1RAdr, blankData },
			{ flagReadMask | Piezo2Adc2RAdr, blankData },
			{ flagReadMask | Piezo2HighWindowRAdr, blankData },
			{ flagReadMask | Piezo2LowWindowRAdr, blankData },
			{ flagReadMask | Piezo2CntlRAdr, blankData },
			{ flagReadMask | Piezo2StatRAdr, blankData },
			{ flagReadMask | Piezo2BrdTmpRAdr, blankData },
			{ flagReadMask | Piezo2BrdSernumRAdr, blankData },
			{ flagReadMask | Piezo2IgainRAdr, blankData },
			{ flagReadMask | Cavity2DetuneErrRAdr, blankData },
			{ flagReadMask | Motor3AccRAdr, blankData },
			{ flagReadMask | Motor3VlctyRAdr, blankData },
			{ flagReadMask | Motor3StepsRAdr, blankData },
			{ flagReadMask | Motor3SgnStepsRAdr, blankData },
			{ flagReadMask | Motor3AbsStepsRAdr, blankData },
			{ flagReadMask | Motor3LaccRAdr, blankData },
			{ flagReadMask | Motor3LvlctyRAdr, blankData },
			{ flagReadMask | Motor3LstepsRAdr, blankData },
			{ flagReadMask | Motor3DrviRAdr, blankData },
			{ flagReadMask | Motor3BrdTmpRAdr, blankData },
			{ flagReadMask | Motor3CntlRAdr, blankData },
			{ flagReadMask | Motor3StatRAdr, blankData },
			{ flagReadMask | Piezo3Dac1RAdr, blankData },
			{ flagReadMask | Piezo3Dac2RAdr, blankData },
			{ flagReadMask | Piezo3Adc1RAdr, blankData },
			{ flagReadMask | Piezo3Adc2RAdr, blankData },
			{ flagReadMask | Piezo3HighWindowRAdr, blankData },
			{ flagReadMask | Piezo3LowWindowRAdr, blankData },
			{ flagReadMask | Piezo3CntlRAdr, blankData },
			{ flagReadMask | Piezo3StatRAdr, blankData },
			{ flagReadMask | Piezo3BrdTmpRAdr, blankData },
			{ flagReadMask | Piezo3BrdSernumRAdr, blankData },
			{ flagReadMask | Piezo3IgainRAdr, blankData },
			{ flagReadMask | Cavity3DetuneErrRAdr, blankData },
			{ flagReadMask | Motor4AccRAdr, blankData },
			{ flagReadMask | Motor4VlctyRAdr, blankData },
			{ flagReadMask | Motor4StepsRAdr, blankData },
			{ flagReadMask | Motor4SgnStepsRAdr, blankData },
			{ flagReadMask | Motor4AbsStepsRAdr, blankData },
			{ flagReadMask | Motor4LaccRAdr, blankData },
			{ flagReadMask | Motor4LvlctyRAdr, blankData },
			{ flagReadMask | Motor4LstepsRAdr, blankData },
			{ flagReadMask | Motor4DrviRAdr, blankData },
			{ flagReadMask | Motor4BrdTmpRAdr, blankData },
			{ flagReadMask | Motor4CntlRAdr, blankData },
			{ flagReadMask | Motor4StatRAdr, blankData },
			{ flagReadMask | Piezo4Dac1RAdr, blankData },
			{ flagReadMask | Piezo4Dac2RAdr, blankData },
			{ flagReadMask | Piezo4Adc1RAdr, blankData },
			{ flagReadMask | Piezo4Adc2RAdr, blankData },
			{ flagReadMask | Piezo4HighWindowRAdr, blankData },
			{ flagReadMask | Piezo4LowWindowRAdr, blankData },
			{ flagReadMask | Piezo4CntlRAdr, blankData },
			{ flagReadMask | Piezo4StatRAdr, blankData },
			{ flagReadMask | Piezo4BrdTmpRAdr, blankData },
			{ flagReadMask | Piezo4BrdSernumRAdr, blankData },
			{ flagReadMask | Piezo4IgainRAdr, blankData },
			{ flagReadMask | Cavity4DetuneErrRAdr, blankData },
	};

	htonFpgaRegArray(pPolledRegMsg_, readRegCount + 1);
    PolledRegMsgSize_ = readRegCount + 1;

    epicsThreadSleep(defaultPollPeriod);
    printf("%s created %ld parameters.\n",__PRETTY_FUNCTION__,NUM_SCLLRFRES_PARAMS);

    wakeupPoller();
    wakeupReader();
}

scllrfRESDriver::~scllrfRESDriver()
{
	isShuttingDown_ = true;
	epicsThreadSleep(0.1); // Allow threads to run and exit
	wakeupPoller();
	wakeupReader();
	epicsThreadSleep(0.1); // Allow threads to run and exit
	wakeupPoller(); // call this twice in case the poller was never set to run
	wakeupReader();
	epicsThreadSleep(0.1); // Allow threads to run and exit
	wakeupReader();
	pasynOctetSyncIO->disconnect(pOctetAsynUser_);
	pasynCommonSyncIO->disconnectDevice(pCommonAsynUser_);
	pasynCommonSyncIO->disconnect(pCommonAsynUser_);
}

/** Called when you have the asyn parameter name and want the corresponding
 * register address.
  * \param[in] function From pAsynUser->reason, corresponding to a registered parameter.
  * \param[in] pToFpga Pointer to the {Address, Data} structure where the register address will be written
  * \param[in] nElements Number of elements to read. */
asynStatus scllrfRESDriver::functionToRegister(const int function, FpgaReg *pToFpga)
{
	asynStatus status = asynSuccess;

    if( function == p_Cavity1DetuneErrR )
    {
		pToFpga->addr = Cavity1DetuneErrRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity2DetuneErrR )
    {
		pToFpga->addr = Cavity2DetuneErrRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity3DetuneErrR )
    {
		pToFpga->addr = Cavity3DetuneErrRAdr|flagReadMask;
    }
    else
    if( function == p_Cavity4DetuneErrR )
    {
		pToFpga->addr = Cavity4DetuneErrRAdr|flagReadMask;
    }
    else
    if( function == p_Motor1AbsStepsR )
    {
		pToFpga->addr = Motor1AbsStepsRAdr|flagReadMask;
    }
    else
    if( function == p_Motor1AccR )
    {
		pToFpga->addr = Motor1AccRAdr|flagReadMask;
    }
    else
    if( function == p_Motor1AccW )
    {
		pToFpga->addr = Motor1AccWAdr;
    }
    else
    if( function == p_Motor1BrdTmpR )
    {
		pToFpga->addr = Motor1BrdTmpRAdr|flagReadMask;
    }
    else
    if( function == p_Motor1CntlR )
    {
		pToFpga->addr = Motor1CntlRAdr|flagReadMask;
    }
    else
    if( function == p_Motor1CntlW )
    {
		pToFpga->addr = Motor1CntlWAdr;
    }
    else
    if( function == p_Motor1DrviR )
    {
		pToFpga->addr = Motor1DrviRAdr|flagReadMask;
    }
    else
    if( function == p_Motor1DrviW )
    {
		pToFpga->addr = Motor1DrviWAdr;
    }
    else
    if( function == p_Motor1LaccR )
    {
		pToFpga->addr = Motor1LaccRAdr|flagReadMask;
    }
    else
    if( function == p_Motor1LstepsR )
    {
		pToFpga->addr = Motor1LstepsRAdr|flagReadMask;
    }
    else
    if( function == p_Motor1LvlctyR )
    {
		pToFpga->addr = Motor1LvlctyRAdr|flagReadMask;
    }
    else
    if( function == p_Motor1SgnStepsR )
    {
		pToFpga->addr = Motor1SgnStepsRAdr|flagReadMask;
    }
    else
    if( function == p_Motor1StatR )
    {
		pToFpga->addr = Motor1StatRAdr|flagReadMask;
    }
    else
    if( function == p_Motor1StepsR )
    {
		pToFpga->addr = Motor1StepsRAdr|flagReadMask;
    }
    else
    if( function == p_Motor1StepsW )
    {
		pToFpga->addr = Motor1StepsWAdr;
    }
    else
    if( function == p_Motor1VlctyR )
    {
		pToFpga->addr = Motor1VlctyRAdr|flagReadMask;
    }
    else
    if( function == p_Motor1VlctyW )
    {
		pToFpga->addr = Motor1VlctyWAdr;
    }
    else
    if( function == p_Motor2AbsStepsR )
    {
		pToFpga->addr = Motor2AbsStepsRAdr|flagReadMask;
    }
    else
    if( function == p_Motor2AccR )
    {
		pToFpga->addr = Motor2AccRAdr|flagReadMask;
    }
    else
    if( function == p_Motor2AccW )
    {
		pToFpga->addr = Motor2AccWAdr;
    }
    else
    if( function == p_Motor2BrdTmpR )
    {
		pToFpga->addr = Motor2BrdTmpRAdr|flagReadMask;
    }
    else
    if( function == p_Motor2CntlR )
    {
		pToFpga->addr = Motor2CntlRAdr|flagReadMask;
    }
    else
    if( function == p_Motor2CntlW )
    {
		pToFpga->addr = Motor2CntlWAdr;
    }
    else
    if( function == p_Motor2DrviR )
    {
		pToFpga->addr = Motor2DrviRAdr|flagReadMask;
    }
    else
    if( function == p_Motor2DrviW )
    {
		pToFpga->addr = Motor2DrviWAdr;
    }
    else
    if( function == p_Motor2LaccR )
    {
		pToFpga->addr = Motor2LaccRAdr|flagReadMask;
    }
    else
    if( function == p_Motor2LstepsR )
    {
		pToFpga->addr = Motor2LstepsRAdr|flagReadMask;
    }
    else
    if( function == p_Motor2LvlctyR )
    {
		pToFpga->addr = Motor2LvlctyRAdr|flagReadMask;
    }
    else
    if( function == p_Motor2SgnStepsR )
    {
		pToFpga->addr = Motor2SgnStepsRAdr|flagReadMask;
    }
    else
    if( function == p_Motor2StatR )
    {
		pToFpga->addr = Motor2StatRAdr|flagReadMask;
    }
    else
    if( function == p_Motor2StepsR )
    {
		pToFpga->addr = Motor2StepsRAdr|flagReadMask;
    }
    else
    if( function == p_Motor2StepsW )
    {
		pToFpga->addr = Motor2StepsWAdr;
    }
    else
    if( function == p_Motor2VlctyR )
    {
		pToFpga->addr = Motor2VlctyRAdr|flagReadMask;
    }
    else
    if( function == p_Motor2VlctyW )
    {
		pToFpga->addr = Motor2VlctyWAdr;
    }
    else
    if( function == p_Motor3AbsStepsR )
    {
		pToFpga->addr = Motor3AbsStepsRAdr|flagReadMask;
    }
    else
    if( function == p_Motor3AccR )
    {
		pToFpga->addr = Motor3AccRAdr|flagReadMask;
    }
    else
    if( function == p_Motor3AccW )
    {
		pToFpga->addr = Motor3AccWAdr;
    }
    else
    if( function == p_Motor3BrdTmpR )
    {
		pToFpga->addr = Motor3BrdTmpRAdr|flagReadMask;
    }
    else
    if( function == p_Motor3CntlR )
    {
		pToFpga->addr = Motor3CntlRAdr|flagReadMask;
    }
    else
    if( function == p_Motor3CntlW )
    {
		pToFpga->addr = Motor3CntlWAdr;
    }
    else
    if( function == p_Motor3DrviR )
    {
		pToFpga->addr = Motor3DrviRAdr|flagReadMask;
    }
    else
    if( function == p_Motor3DrviW )
    {
		pToFpga->addr = Motor3DrviWAdr;
    }
    else
    if( function == p_Motor3LaccR )
    {
		pToFpga->addr = Motor3LaccRAdr|flagReadMask;
    }
    else
    if( function == p_Motor3LstepsR )
    {
		pToFpga->addr = Motor3LstepsRAdr|flagReadMask;
    }
    else
    if( function == p_Motor3LvlctyR )
    {
		pToFpga->addr = Motor3LvlctyRAdr|flagReadMask;
    }
    else
    if( function == p_Motor3SgnStepsR )
    {
		pToFpga->addr = Motor3SgnStepsRAdr|flagReadMask;
    }
    else
    if( function == p_Motor3StatR )
    {
		pToFpga->addr = Motor3StatRAdr|flagReadMask;
    }
    else
    if( function == p_Motor3StepsR )
    {
		pToFpga->addr = Motor3StepsRAdr|flagReadMask;
    }
    else
    if( function == p_Motor3StepsW )
    {
		pToFpga->addr = Motor3StepsWAdr;
    }
    else
    if( function == p_Motor3VlctyR )
    {
		pToFpga->addr = Motor3VlctyRAdr|flagReadMask;
    }
    else
    if( function == p_Motor3VlctyW )
    {
		pToFpga->addr = Motor3VlctyWAdr;
    }
    else
    if( function == p_Motor4AbsStepsR )
    {
		pToFpga->addr = Motor4AbsStepsRAdr|flagReadMask;
    }
    else
    if( function == p_Motor4AccR )
    {
		pToFpga->addr = Motor4AccRAdr|flagReadMask;
    }
    else
    if( function == p_Motor4AccW )
    {
		pToFpga->addr = Motor4AccWAdr;
    }
    else
    if( function == p_Motor4BrdTmpR )
    {
		pToFpga->addr = Motor4BrdTmpRAdr|flagReadMask;
    }
    else
    if( function == p_Motor4CntlR )
    {
		pToFpga->addr = Motor4CntlRAdr|flagReadMask;
    }
    else
    if( function == p_Motor4CntlW )
    {
		pToFpga->addr = Motor4CntlWAdr;
    }
    else
    if( function == p_Motor4DrviR )
    {
		pToFpga->addr = Motor4DrviRAdr|flagReadMask;
    }
    else
    if( function == p_Motor4DrviW )
    {
		pToFpga->addr = Motor4DrviWAdr;
    }
    else
    if( function == p_Motor4LaccR )
    {
		pToFpga->addr = Motor4LaccRAdr|flagReadMask;
    }
    else
    if( function == p_Motor4LstepsR )
    {
		pToFpga->addr = Motor4LstepsRAdr|flagReadMask;
    }
    else
    if( function == p_Motor4LvlctyR )
    {
		pToFpga->addr = Motor4LvlctyRAdr|flagReadMask;
    }
    else
    if( function == p_Motor4SgnStepsR )
    {
		pToFpga->addr = Motor4SgnStepsRAdr|flagReadMask;
    }
    else
    if( function == p_Motor4StatR )
    {
		pToFpga->addr = Motor4StatRAdr|flagReadMask;
    }
    else
    if( function == p_Motor4StepsR )
    {
		pToFpga->addr = Motor4StepsRAdr|flagReadMask;
    }
    else
    if( function == p_Motor4StepsW )
    {
		pToFpga->addr = Motor4StepsWAdr;
    }
    else
    if( function == p_Motor4VlctyR )
    {
		pToFpga->addr = Motor4VlctyRAdr|flagReadMask;
    }
    else
    if( function == p_Motor4VlctyW )
    {
		pToFpga->addr = Motor4VlctyWAdr;
    }
    else
    if( function == p_Piezo1Adc1R )
    {
		pToFpga->addr = Piezo1Adc1RAdr|flagReadMask;
    }
    else
    if( function == p_Piezo1Adc2R )
    {
		pToFpga->addr = Piezo1Adc2RAdr|flagReadMask;
    }
    else
    if( function == p_Piezo1BrdSernumR )
    {
		pToFpga->addr = Piezo1BrdSernumRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo1BrdTmpR )
    {
		pToFpga->addr = Piezo1BrdTmpRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo1CntlR )
    {
		pToFpga->addr = Piezo1CntlRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo1CntlW )
    {
		pToFpga->addr = Piezo1CntlWAdr;
    }
    else
    if( function == p_Piezo1Dac1R )
    {
		pToFpga->addr = Piezo1Dac1RAdr|flagReadMask;
    }
    else
    if( function == p_Piezo1Dac1W )
    {
		pToFpga->addr = Piezo1Dac1WAdr;
    }
    else
    if( function == p_Piezo1Dac2R )
    {
		pToFpga->addr = Piezo1Dac2RAdr|flagReadMask;
    }
    else
    if( function == p_Piezo1Dac2W )
    {
		pToFpga->addr = Piezo1Dac2WAdr;
    }
    else
    if( function == p_Piezo1HighWindowR )
    {
		pToFpga->addr = Piezo1HighWindowRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo1HighWindowW )
    {
		pToFpga->addr = Piezo1HighWindowWAdr;
    }
    else
    if( function == p_Piezo1IgainR )
    {
		pToFpga->addr = Piezo1IgainRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo1IgainW )
    {
		pToFpga->addr = Piezo1IgainWAdr;
    }
    else
    if( function == p_Piezo1LowWindowR )
    {
		pToFpga->addr = Piezo1LowWindowRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo1LowWindowW )
    {
		pToFpga->addr = Piezo1LowWindowWAdr;
    }
    else
    if( function == p_Piezo1StatR )
    {
		pToFpga->addr = Piezo1StatRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo2Adc1R )
    {
		pToFpga->addr = Piezo2Adc1RAdr|flagReadMask;
    }
    else
    if( function == p_Piezo2Adc2R )
    {
		pToFpga->addr = Piezo2Adc2RAdr|flagReadMask;
    }
    else
    if( function == p_Piezo2BrdSernumR )
    {
		pToFpga->addr = Piezo2BrdSernumRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo2BrdTmpR )
    {
		pToFpga->addr = Piezo2BrdTmpRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo2CntlR )
    {
		pToFpga->addr = Piezo2CntlRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo2CntlW )
    {
		pToFpga->addr = Piezo2CntlWAdr;
    }
    else
    if( function == p_Piezo2Dac1R )
    {
		pToFpga->addr = Piezo2Dac1RAdr|flagReadMask;
    }
    else
    if( function == p_Piezo2Dac1W )
    {
		pToFpga->addr = Piezo2Dac1WAdr;
    }
    else
    if( function == p_Piezo2Dac2R )
    {
		pToFpga->addr = Piezo2Dac2RAdr|flagReadMask;
    }
    else
    if( function == p_Piezo2Dac2W )
    {
		pToFpga->addr = Piezo2Dac2WAdr;
    }
    else
    if( function == p_Piezo2HighWindowR )
    {
		pToFpga->addr = Piezo2HighWindowRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo2HighWindowW )
    {
		pToFpga->addr = Piezo2HighWindowWAdr;
    }
    else
    if( function == p_Piezo2IgainR )
    {
		pToFpga->addr = Piezo2IgainRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo2IgainW )
    {
		pToFpga->addr = Piezo2IgainWAdr;
    }
    else
    if( function == p_Piezo2LowWindowR )
    {
		pToFpga->addr = Piezo2LowWindowRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo2LowWindowW )
    {
		pToFpga->addr = Piezo2LowWindowWAdr;
    }
    else
    if( function == p_Piezo2StatR )
    {
		pToFpga->addr = Piezo2StatRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo3Adc1R )
    {
		pToFpga->addr = Piezo3Adc1RAdr|flagReadMask;
    }
    else
    if( function == p_Piezo3Adc2R )
    {
		pToFpga->addr = Piezo3Adc2RAdr|flagReadMask;
    }
    else
    if( function == p_Piezo3BrdSernumR )
    {
		pToFpga->addr = Piezo3BrdSernumRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo3BrdTmpR )
    {
		pToFpga->addr = Piezo3BrdTmpRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo3CntlR )
    {
		pToFpga->addr = Piezo3CntlRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo3CntlW )
    {
		pToFpga->addr = Piezo3CntlWAdr;
    }
    else
    if( function == p_Piezo3Dac1R )
    {
		pToFpga->addr = Piezo3Dac1RAdr|flagReadMask;
    }
    else
    if( function == p_Piezo3Dac1W )
    {
		pToFpga->addr = Piezo3Dac1WAdr;
    }
    else
    if( function == p_Piezo3Dac2R )
    {
		pToFpga->addr = Piezo3Dac2RAdr|flagReadMask;
    }
    else
    if( function == p_Piezo3Dac2W )
    {
		pToFpga->addr = Piezo3Dac2WAdr;
    }
    else
    if( function == p_Piezo3HighWindowR )
    {
		pToFpga->addr = Piezo3HighWindowRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo3HighWindowW )
    {
		pToFpga->addr = Piezo3HighWindowWAdr;
    }
    else
    if( function == p_Piezo3IgainR )
    {
		pToFpga->addr = Piezo3IgainRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo3IgainW )
    {
		pToFpga->addr = Piezo3IgainWAdr;
    }
    else
    if( function == p_Piezo3LowWindowR )
    {
		pToFpga->addr = Piezo3LowWindowRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo3LowWindowW )
    {
		pToFpga->addr = Piezo3LowWindowWAdr;
    }
    else
    if( function == p_Piezo3StatR )
    {
		pToFpga->addr = Piezo3StatRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo4Adc1R )
    {
		pToFpga->addr = Piezo4Adc1RAdr|flagReadMask;
    }
    else
    if( function == p_Piezo4Adc2R )
    {
		pToFpga->addr = Piezo4Adc2RAdr|flagReadMask;
    }
    else
    if( function == p_Piezo4BrdSernumR )
    {
		pToFpga->addr = Piezo4BrdSernumRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo4BrdTmpR )
    {
		pToFpga->addr = Piezo4BrdTmpRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo4CntlR )
    {
		pToFpga->addr = Piezo4CntlRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo4CntlW )
    {
		pToFpga->addr = Piezo4CntlWAdr;
    }
    else
    if( function == p_Piezo4Dac1R )
    {
		pToFpga->addr = Piezo4Dac1RAdr|flagReadMask;
    }
    else
    if( function == p_Piezo4Dac1W )
    {
		pToFpga->addr = Piezo4Dac1WAdr;
    }
    else
    if( function == p_Piezo4Dac2R )
    {
		pToFpga->addr = Piezo4Dac2RAdr|flagReadMask;
    }
    else
    if( function == p_Piezo4Dac2W )
    {
		pToFpga->addr = Piezo4Dac2WAdr;
    }
    else
    if( function == p_Piezo4HighWindowR )
    {
		pToFpga->addr = Piezo4HighWindowRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo4HighWindowW )
    {
		pToFpga->addr = Piezo4HighWindowWAdr;
    }
    else
    if( function == p_Piezo4IgainR )
    {
		pToFpga->addr = Piezo4IgainRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo4IgainW )
    {
		pToFpga->addr = Piezo4IgainWAdr;
    }
    else
    if( function == p_Piezo4LowWindowR )
    {
		pToFpga->addr = Piezo4LowWindowRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo4LowWindowW )
    {
		pToFpga->addr = Piezo4LowWindowWAdr;
    }
    else
    if( function == p_Piezo4StatR )
    {
		pToFpga->addr = Piezo4StatRAdr|flagReadMask;
    }
    else
    	status = asynError;

    return status;
}

/**  Extract register address and data from the received message and set the appropriate
 * asyn parameter.
 * Some registers have a "new waveform data ready" flag. If they have this and it is set,
 * set weveIsReady to true.
 * Note: This function should not set waveIsReady to false. That is done by a loop in the
 * calling function.
* \param[in] pFromFpga Data returned from the FPGA for a single register
* \param[in] waveIsReady A flag that gets set to true if the appropriate bit was set by the FPGA
*/
asynStatus scllrfRESDriver::processRegReadback(const FpgaReg *pFromFpga, bool &waveIsReady)
{
	unsigned int i;
	asynStatus status = asynSuccess;
	assert(pFromFpga->addr&flagReadMask); // This function is only for read registers
	epicsInt32 errorCount;
	int32_t signExtBits = 0;

	/* Map address to parameter, set the parameter in the parameter library. */
	switch (pFromFpga->addr)
    {
    case Motor1AccRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Motor1AccR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor1AccRString, (unsigned ) pFromFpga->data);
	break;

    case Motor1VlctyRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Motor1VlctyR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor1VlctyRString, (unsigned ) pFromFpga->data);
	break;

    case Motor1StepsRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Motor1StepsR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor1StepsRString, (unsigned ) pFromFpga->data);
	break;

    case Motor1SgnStepsRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Motor1SgnStepsR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor1SgnStepsRString, (unsigned ) pFromFpga->data);
	break;

    case Motor1AbsStepsRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Motor1AbsStepsR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor1AbsStepsRString, (unsigned ) pFromFpga->data);
	break;

    case Motor1LaccRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Motor1LaccR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor1LaccRString, (unsigned ) pFromFpga->data);
	break;

    case Motor1LvlctyRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Motor1LvlctyR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor1LvlctyRString, (unsigned ) pFromFpga->data);
	break;

    case Motor1LstepsRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Motor1LstepsR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor1LstepsRString, (unsigned ) pFromFpga->data);
	break;

    case Motor1DrviRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Motor1DrviR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor1DrviRString, (unsigned ) pFromFpga->data);
	break;

    case Motor1BrdTmpRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Motor1BrdTmpR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor1BrdTmpRString, (unsigned ) pFromFpga->data);
	break;

    case Motor1CntlRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Motor1CntlR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor1CntlRString, (unsigned ) pFromFpga->data);

		status = (asynStatus) setUIntDigitalParam(p_Motor1CntlBit1R,
				pFromFpga->data, Motor1CntlBit1Mask);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor1CntlBit1RString,
				(unsigned ) pFromFpga->data & Motor1CntlBit1Mask);

		status = (asynStatus) setUIntDigitalParam(p_Motor1CntlBit2R,
				pFromFpga->data, Motor1CntlBit2Mask);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor1CntlBit2RString,
				(unsigned ) pFromFpga->data & Motor1CntlBit2Mask);
	break;

    case Motor1StatRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Motor1StatR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor1StatRString, (unsigned ) pFromFpga->data);

		status = (asynStatus) setUIntDigitalParam(p_Motor1StatBit1R,
				pFromFpga->data, Motor1StatBit1Mask);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor1StatBit1RString,
				(unsigned ) pFromFpga->data & Motor1StatBit1Mask);

		status = (asynStatus) setUIntDigitalParam(p_Motor1StatBit2R,
				pFromFpga->data, Motor1StatBit2Mask);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor1StatBit2RString,
				(unsigned ) pFromFpga->data & Motor1StatBit2Mask);
	break;

    case Piezo1Dac1RAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo1Dac1R,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1Dac1RString, (unsigned ) pFromFpga->data);
	break;

    case Piezo1Dac2RAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo1Dac2R,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1Dac2RString, (unsigned ) pFromFpga->data);
	break;

    case Piezo1Adc1RAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo1Adc1R,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1Adc1RString, (unsigned ) pFromFpga->data);
	break;

    case Piezo1Adc2RAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo1Adc2R,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1Adc2RString, (unsigned ) pFromFpga->data);
	break;

    case Piezo1HighWindowRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo1HighWindowR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1HighWindowRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo1LowWindowRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo1LowWindowR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1LowWindowRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo1CntlRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo1CntlR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1CntlRString, (unsigned ) pFromFpga->data);

		status = (asynStatus) setUIntDigitalParam(p_Piezo1CntlBit1R,
				pFromFpga->data, Piezo1CntlBit1Mask);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1CntlBit1RString,
				(unsigned ) pFromFpga->data & Piezo1CntlBit1Mask);

		status = (asynStatus) setUIntDigitalParam(p_Piezo1CntlBit2R,
				pFromFpga->data, Piezo1CntlBit2Mask);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1CntlBit2RString,
				(unsigned ) pFromFpga->data & Piezo1CntlBit2Mask);
	break;

    case Piezo1StatRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo1StatR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1StatRString, (unsigned ) pFromFpga->data);

		status = (asynStatus) setUIntDigitalParam(p_Piezo1StatBit1R,
				pFromFpga->data, Piezo1StatBit1Mask);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1StatBit1RString,
				(unsigned ) pFromFpga->data & Piezo1StatBit1Mask);

		status = (asynStatus) setUIntDigitalParam(p_Piezo1StatBit2R,
				pFromFpga->data, Piezo1StatBit2Mask);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1StatBit2RString,
				(unsigned ) pFromFpga->data & Piezo1StatBit2Mask);
	break;

    case Piezo1BrdTmpRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo1BrdTmpR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1BrdTmpRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo1BrdSernumRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo1BrdSernumR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1BrdSernumRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo1IgainRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo1IgainR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1IgainRString, (unsigned ) pFromFpga->data);
	break;

    case Cavity1DetuneErrRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Cavity1DetuneErrR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity1DetuneErrRString, (unsigned ) pFromFpga->data);
	break;

    case Motor2AccRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Motor2AccR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor2AccRString, (unsigned ) pFromFpga->data);
	break;

    case Motor2VlctyRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Motor2VlctyR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor2VlctyRString, (unsigned ) pFromFpga->data);
	break;

    case Motor2StepsRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Motor2StepsR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor2StepsRString, (unsigned ) pFromFpga->data);
	break;

    case Motor2SgnStepsRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Motor2SgnStepsR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor2SgnStepsRString, (unsigned ) pFromFpga->data);
	break;

    case Motor2AbsStepsRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Motor2AbsStepsR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor2AbsStepsRString, (unsigned ) pFromFpga->data);
	break;

    case Motor2LaccRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Motor2LaccR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor2LaccRString, (unsigned ) pFromFpga->data);
	break;

    case Motor2LvlctyRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Motor2LvlctyR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor2LvlctyRString, (unsigned ) pFromFpga->data);
	break;

    case Motor2LstepsRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Motor2LstepsR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor2LstepsRString, (unsigned ) pFromFpga->data);
	break;

    case Motor2DrviRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Motor2DrviR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor2DrviRString, (unsigned ) pFromFpga->data);
	break;

    case Motor2BrdTmpRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Motor2BrdTmpR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor2BrdTmpRString, (unsigned ) pFromFpga->data);
	break;

    case Motor2CntlRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Motor2CntlR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor2CntlRString, (unsigned ) pFromFpga->data);

		status = (asynStatus) setUIntDigitalParam(p_Motor2CntlBit1R,
				pFromFpga->data, Motor2CntlBit1Mask);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor2CntlBit1RString,
				(unsigned ) pFromFpga->data & Motor2CntlBit1Mask);

		status = (asynStatus) setUIntDigitalParam(p_Motor2CntlBit2R,
				pFromFpga->data, Motor2CntlBit2Mask);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor2CntlBit2RString,
				(unsigned ) pFromFpga->data & Motor2CntlBit2Mask);
	break;

    case Motor2StatRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Motor2StatR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor2StatRString, (unsigned ) pFromFpga->data);

		status = (asynStatus) setUIntDigitalParam(p_Motor2StatBit1R,
				pFromFpga->data, Motor2StatBit1Mask);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor2StatBit1RString,
				(unsigned ) pFromFpga->data & Motor2StatBit1Mask);

		status = (asynStatus) setUIntDigitalParam(p_Motor2StatBit2R,
				pFromFpga->data, Motor2StatBit2Mask);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor2StatBit2RString,
				(unsigned ) pFromFpga->data & Motor2StatBit2Mask);
	break;

    case Piezo2Dac1RAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo2Dac1R,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2Dac1RString, (unsigned ) pFromFpga->data);
	break;

    case Piezo2Dac2RAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo2Dac2R,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2Dac2RString, (unsigned ) pFromFpga->data);
	break;

    case Piezo2Adc1RAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo2Adc1R,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2Adc1RString, (unsigned ) pFromFpga->data);
	break;

    case Piezo2Adc2RAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo2Adc2R,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2Adc2RString, (unsigned ) pFromFpga->data);
	break;

    case Piezo2HighWindowRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo2HighWindowR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2HighWindowRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo2LowWindowRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo2LowWindowR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2LowWindowRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo2CntlRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo2CntlR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2CntlRString, (unsigned ) pFromFpga->data);

		status = (asynStatus) setUIntDigitalParam(p_Piezo2CntlBit1R,
				pFromFpga->data, Piezo2CntlBit1Mask);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2CntlBit1RString,
				(unsigned ) pFromFpga->data & Piezo2CntlBit1Mask);

		status = (asynStatus) setUIntDigitalParam(p_Piezo2CntlBit2R,
				pFromFpga->data, Piezo2CntlBit2Mask);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2CntlBit2RString,
				(unsigned ) pFromFpga->data & Piezo2CntlBit2Mask);
	break;

    case Piezo2StatRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo2StatR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2StatRString, (unsigned ) pFromFpga->data);

		status = (asynStatus) setUIntDigitalParam(p_Piezo2StatBit1R,
				pFromFpga->data, Piezo2StatBit1Mask);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2StatBit1RString,
				(unsigned ) pFromFpga->data & Piezo2StatBit1Mask);

		status = (asynStatus) setUIntDigitalParam(p_Piezo2StatBit2R,
				pFromFpga->data, Piezo2StatBit2Mask);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2StatBit2RString,
				(unsigned ) pFromFpga->data & Piezo2StatBit2Mask);
	break;

    case Piezo2BrdTmpRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo2BrdTmpR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2BrdTmpRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo2BrdSernumRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo2BrdSernumR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2BrdSernumRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo2IgainRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo2IgainR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2IgainRString, (unsigned ) pFromFpga->data);
	break;

    case Cavity2DetuneErrRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Cavity2DetuneErrR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity2DetuneErrRString, (unsigned ) pFromFpga->data);
	break;

    case Motor3AccRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Motor3AccR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor3AccRString, (unsigned ) pFromFpga->data);
	break;

    case Motor3VlctyRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Motor3VlctyR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor3VlctyRString, (unsigned ) pFromFpga->data);
	break;

    case Motor3StepsRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Motor3StepsR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor3StepsRString, (unsigned ) pFromFpga->data);
	break;

    case Motor3SgnStepsRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Motor3SgnStepsR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor3SgnStepsRString, (unsigned ) pFromFpga->data);
	break;

    case Motor3AbsStepsRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Motor3AbsStepsR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor3AbsStepsRString, (unsigned ) pFromFpga->data);
	break;

    case Motor3LaccRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Motor3LaccR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor3LaccRString, (unsigned ) pFromFpga->data);
	break;

    case Motor3LvlctyRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Motor3LvlctyR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor3LvlctyRString, (unsigned ) pFromFpga->data);
	break;

    case Motor3LstepsRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Motor3LstepsR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor3LstepsRString, (unsigned ) pFromFpga->data);
	break;

    case Motor3DrviRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Motor3DrviR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor3DrviRString, (unsigned ) pFromFpga->data);
	break;

    case Motor3BrdTmpRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Motor3BrdTmpR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor3BrdTmpRString, (unsigned ) pFromFpga->data);
	break;

    case Motor3CntlRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Motor3CntlR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor3CntlRString, (unsigned ) pFromFpga->data);

		status = (asynStatus) setUIntDigitalParam(p_Motor3CntlBit1R,
				pFromFpga->data, Motor3CntlBit1Mask);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor3CntlBit1RString,
				(unsigned ) pFromFpga->data & Motor3CntlBit1Mask);

		status = (asynStatus) setUIntDigitalParam(p_Motor3CntlBit2R,
				pFromFpga->data, Motor3CntlBit2Mask);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor3CntlBit2RString,
				(unsigned ) pFromFpga->data & Motor3CntlBit2Mask);
	break;

    case Motor3StatRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Motor3StatR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor3StatRString, (unsigned ) pFromFpga->data);

		status = (asynStatus) setUIntDigitalParam(p_Motor3StatBit1R,
				pFromFpga->data, Motor3StatBit1Mask);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor3StatBit1RString,
				(unsigned ) pFromFpga->data & Motor3StatBit1Mask);

		status = (asynStatus) setUIntDigitalParam(p_Motor3StatBit2R,
				pFromFpga->data, Motor3StatBit2Mask);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor3StatBit2RString,
				(unsigned ) pFromFpga->data & Motor3StatBit2Mask);
	break;

    case Piezo3Dac1RAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo3Dac1R,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3Dac1RString, (unsigned ) pFromFpga->data);
	break;

    case Piezo3Dac2RAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo3Dac2R,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3Dac2RString, (unsigned ) pFromFpga->data);
	break;

    case Piezo3Adc1RAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo3Adc1R,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3Adc1RString, (unsigned ) pFromFpga->data);
	break;

    case Piezo3Adc2RAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo3Adc2R,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3Adc2RString, (unsigned ) pFromFpga->data);
	break;

    case Piezo3HighWindowRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo3HighWindowR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3HighWindowRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo3LowWindowRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo3LowWindowR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3LowWindowRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo3CntlRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo3CntlR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3CntlRString, (unsigned ) pFromFpga->data);

		status = (asynStatus) setUIntDigitalParam(p_Piezo3CntlBit1R,
				pFromFpga->data, Piezo3CntlBit1Mask);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3CntlBit1RString,
				(unsigned ) pFromFpga->data & Piezo3CntlBit1Mask);

		status = (asynStatus) setUIntDigitalParam(p_Piezo3CntlBit2R,
				pFromFpga->data, Piezo3CntlBit2Mask);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3CntlBit2RString,
				(unsigned ) pFromFpga->data & Piezo3CntlBit2Mask);
	break;

    case Piezo3StatRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo3StatR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3StatRString, (unsigned ) pFromFpga->data);

		status = (asynStatus) setUIntDigitalParam(p_Piezo3StatBit1R,
				pFromFpga->data, Piezo3StatBit1Mask);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3StatBit1RString,
				(unsigned ) pFromFpga->data & Piezo3StatBit1Mask);

		status = (asynStatus) setUIntDigitalParam(p_Piezo3StatBit2R,
				pFromFpga->data, Piezo3StatBit2Mask);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3StatBit2RString,
				(unsigned ) pFromFpga->data & Piezo3StatBit2Mask);
	break;

    case Piezo3BrdTmpRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo3BrdTmpR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3BrdTmpRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo3BrdSernumRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo3BrdSernumR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3BrdSernumRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo3IgainRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo3IgainR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3IgainRString, (unsigned ) pFromFpga->data);
	break;

    case Cavity3DetuneErrRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Cavity3DetuneErrR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity3DetuneErrRString, (unsigned ) pFromFpga->data);
	break;

    case Motor4AccRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Motor4AccR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor4AccRString, (unsigned ) pFromFpga->data);
	break;

    case Motor4VlctyRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Motor4VlctyR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor4VlctyRString, (unsigned ) pFromFpga->data);
	break;

    case Motor4StepsRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Motor4StepsR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor4StepsRString, (unsigned ) pFromFpga->data);
	break;

    case Motor4SgnStepsRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Motor4SgnStepsR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor4SgnStepsRString, (unsigned ) pFromFpga->data);
	break;

    case Motor4AbsStepsRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Motor4AbsStepsR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor4AbsStepsRString, (unsigned ) pFromFpga->data);
	break;

    case Motor4LaccRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Motor4LaccR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor4LaccRString, (unsigned ) pFromFpga->data);
	break;

    case Motor4LvlctyRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Motor4LvlctyR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor4LvlctyRString, (unsigned ) pFromFpga->data);
	break;

    case Motor4LstepsRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Motor4LstepsR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor4LstepsRString, (unsigned ) pFromFpga->data);
	break;

    case Motor4DrviRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Motor4DrviR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor4DrviRString, (unsigned ) pFromFpga->data);
	break;

    case Motor4BrdTmpRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Motor4BrdTmpR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor4BrdTmpRString, (unsigned ) pFromFpga->data);
	break;

    case Motor4CntlRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Motor4CntlR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor4CntlRString, (unsigned ) pFromFpga->data);

		status = (asynStatus) setUIntDigitalParam(p_Motor4CntlBit1R,
				pFromFpga->data, Motor4CntlBit1Mask);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor4CntlBit1RString,
				(unsigned ) pFromFpga->data & Motor4CntlBit1Mask);

		status = (asynStatus) setUIntDigitalParam(p_Motor4CntlBit2R,
				pFromFpga->data, Motor4CntlBit2Mask);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor4CntlBit2RString,
				(unsigned ) pFromFpga->data & Motor4CntlBit2Mask);
	break;

    case Motor4StatRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Motor4StatR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor4StatRString, (unsigned ) pFromFpga->data);

		status = (asynStatus) setUIntDigitalParam(p_Motor4StatBit1R,
				pFromFpga->data, Motor4StatBit1Mask);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor4StatBit1RString,
				(unsigned ) pFromFpga->data & Motor4StatBit1Mask);

		status = (asynStatus) setUIntDigitalParam(p_Motor4StatBit2R,
				pFromFpga->data, Motor4StatBit2Mask);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor4StatBit2RString,
				(unsigned ) pFromFpga->data & Motor4StatBit2Mask);
	break;

    case Piezo4Dac1RAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo4Dac1R,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4Dac1RString, (unsigned ) pFromFpga->data);
	break;

    case Piezo4Dac2RAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo4Dac2R,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4Dac2RString, (unsigned ) pFromFpga->data);
	break;

    case Piezo4Adc1RAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo4Adc1R,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4Adc1RString, (unsigned ) pFromFpga->data);
	break;

    case Piezo4Adc2RAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo4Adc2R,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4Adc2RString, (unsigned ) pFromFpga->data);
	break;

    case Piezo4HighWindowRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo4HighWindowR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4HighWindowRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo4LowWindowRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo4LowWindowR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4LowWindowRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo4CntlRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo4CntlR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4CntlRString, (unsigned ) pFromFpga->data);

		status = (asynStatus) setUIntDigitalParam(p_Piezo4CntlBit1R,
				pFromFpga->data, Piezo4CntlBit1Mask);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4CntlBit1RString,
				(unsigned ) pFromFpga->data & Piezo4CntlBit1Mask);

		status = (asynStatus) setUIntDigitalParam(p_Piezo4CntlBit2R,
				pFromFpga->data, Piezo4CntlBit2Mask);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4CntlBit2RString,
				(unsigned ) pFromFpga->data & Piezo4CntlBit2Mask);
	break;

    case Piezo4StatRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo4StatR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4StatRString, (unsigned ) pFromFpga->data);

		status = (asynStatus) setUIntDigitalParam(p_Piezo4StatBit1R,
				pFromFpga->data, Piezo4StatBit1Mask);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4StatBit1RString,
				(unsigned ) pFromFpga->data & Piezo4StatBit1Mask);

		status = (asynStatus) setUIntDigitalParam(p_Piezo4StatBit2R,
				pFromFpga->data, Piezo4StatBit2Mask);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4StatBit2RString,
				(unsigned ) pFromFpga->data & Piezo4StatBit2Mask);
	break;

    case Piezo4BrdTmpRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo4BrdTmpR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4BrdTmpRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo4BrdSernumRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo4BrdSernumR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4BrdSernumRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo4IgainRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo4IgainR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4IgainRString, (unsigned ) pFromFpga->data);
	break;

    case Cavity4DetuneErrRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Cavity4DetuneErrR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Cavity4DetuneErrRString, (unsigned ) pFromFpga->data);
	break;

	default:
		getIntegerParam(p_CommErrorCount, &errorCount);
		setIntegerParam(p_CommErrorCount, ++errorCount);

		status = asynError;
		break;
    }

    return status;
}


/**  Extract register address and data from the received message and set the appropriate
 * asyn parameter.
 * Some registers have a "new waveform data ready" flag. If they have this and it is set,
 * set weveIsReady to true.
 * Note: This function should not set waveIsReady to false. That is done by a loop in the
 * calling function.
* \param[in] pFromFpga Data returned from the FPGA for a single register
* \param[in] waveIsReady A flag that gets set to true if the appropriate bit was set by the FPGA
*/
asynStatus scllrfRESDriver::processRegWriteResponse(const FpgaReg *pFromFpga)
{
	asynStatus status = asynSuccess;
	epicsInt32 valueSet[maxMsgSize/sizeof(FpgaReg)]; // Put the value sent to the FPGA here for comparison
	epicsInt32 errorCount;
//  variables that may be useful for checking array data
//	asynUser *pAsynArrayUser;
//	unsigned int i;

	/* Map address to parameter, set the parameter in the parameter library. */
	switch (pFromFpga->addr)
    {
    case Motor1AccWAdr:
		status = (asynStatus) getIntegerParam(p_Motor1AccW, valueSet);
		if( (valueSet[0] ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor1AccWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Motor1AccWString, valueSet[0] , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Motor1AccW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Motor1VlctyWAdr:
		status = (asynStatus) getIntegerParam(p_Motor1VlctyW, valueSet);
		if( (valueSet[0] ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor1VlctyWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Motor1VlctyWString, valueSet[0] , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Motor1VlctyW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Motor1StepsWAdr:
		status = (asynStatus) getIntegerParam(p_Motor1StepsW, valueSet);
		if( (valueSet[0] ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor1StepsWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Motor1StepsWString, valueSet[0] , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Motor1StepsW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Motor1DrviWAdr:
		status = (asynStatus) getIntegerParam(p_Motor1DrviW, valueSet);
		if( (valueSet[0] ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor1DrviWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Motor1DrviWString, valueSet[0] , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Motor1DrviW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Motor1CntlWAdr:
		status = (asynStatus) getIntegerParam(p_Motor1CntlW, valueSet);
		if( (valueSet[0] ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor1CntlWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Motor1CntlWString, valueSet[0] , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Motor1CntlW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Piezo1Dac1WAdr:
		status = (asynStatus) getIntegerParam(p_Piezo1Dac1W, valueSet);
		if( (valueSet[0] ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1Dac1WString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1Dac1WString, valueSet[0] , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Piezo1Dac1W, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Piezo1Dac2WAdr:
		status = (asynStatus) getIntegerParam(p_Piezo1Dac2W, valueSet);
		if( (valueSet[0] ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1Dac2WString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1Dac2WString, valueSet[0] , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Piezo1Dac2W, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Piezo1HighWindowWAdr:
		status = (asynStatus) getIntegerParam(p_Piezo1HighWindowW, valueSet);
		if( (valueSet[0] ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1HighWindowWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1HighWindowWString, valueSet[0] , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Piezo1HighWindowW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Piezo1LowWindowWAdr:
		status = (asynStatus) getIntegerParam(p_Piezo1LowWindowW, valueSet);
		if( (valueSet[0] ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1LowWindowWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1LowWindowWString, valueSet[0] , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Piezo1LowWindowW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Piezo1CntlWAdr:
		status = (asynStatus) getIntegerParam(p_Piezo1CntlW, valueSet);
		if( (valueSet[0] ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1CntlWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1CntlWString, valueSet[0] , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Piezo1CntlW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Piezo1IgainWAdr:
		status = (asynStatus) getIntegerParam(p_Piezo1IgainW, valueSet);
		if( (valueSet[0] ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1IgainWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1IgainWString, valueSet[0] , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Piezo1IgainW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Motor2AccWAdr:
		status = (asynStatus) getIntegerParam(p_Motor2AccW, valueSet);
		if( (valueSet[0] ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor2AccWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Motor2AccWString, valueSet[0] , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Motor2AccW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Motor2VlctyWAdr:
		status = (asynStatus) getIntegerParam(p_Motor2VlctyW, valueSet);
		if( (valueSet[0] ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor2VlctyWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Motor2VlctyWString, valueSet[0] , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Motor2VlctyW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Motor2StepsWAdr:
		status = (asynStatus) getIntegerParam(p_Motor2StepsW, valueSet);
		if( (valueSet[0] ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor2StepsWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Motor2StepsWString, valueSet[0] , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Motor2StepsW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Motor2DrviWAdr:
		status = (asynStatus) getIntegerParam(p_Motor2DrviW, valueSet);
		if( (valueSet[0] ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor2DrviWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Motor2DrviWString, valueSet[0] , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Motor2DrviW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Motor2CntlWAdr:
		status = (asynStatus) getIntegerParam(p_Motor2CntlW, valueSet);
		if( (valueSet[0] ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor2CntlWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Motor2CntlWString, valueSet[0] , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Motor2CntlW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Piezo2Dac1WAdr:
		status = (asynStatus) getIntegerParam(p_Piezo2Dac1W, valueSet);
		if( (valueSet[0] ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2Dac1WString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2Dac1WString, valueSet[0] , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Piezo2Dac1W, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Piezo2Dac2WAdr:
		status = (asynStatus) getIntegerParam(p_Piezo2Dac2W, valueSet);
		if( (valueSet[0] ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2Dac2WString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2Dac2WString, valueSet[0] , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Piezo2Dac2W, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Piezo2HighWindowWAdr:
		status = (asynStatus) getIntegerParam(p_Piezo2HighWindowW, valueSet);
		if( (valueSet[0] ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2HighWindowWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2HighWindowWString, valueSet[0] , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Piezo2HighWindowW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Piezo2LowWindowWAdr:
		status = (asynStatus) getIntegerParam(p_Piezo2LowWindowW, valueSet);
		if( (valueSet[0] ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2LowWindowWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2LowWindowWString, valueSet[0] , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Piezo2LowWindowW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Piezo2CntlWAdr:
		status = (asynStatus) getIntegerParam(p_Piezo2CntlW, valueSet);
		if( (valueSet[0] ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2CntlWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2CntlWString, valueSet[0] , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Piezo2CntlW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Piezo2IgainWAdr:
		status = (asynStatus) getIntegerParam(p_Piezo2IgainW, valueSet);
		if( (valueSet[0] ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2IgainWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2IgainWString, valueSet[0] , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Piezo2IgainW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Motor3AccWAdr:
		status = (asynStatus) getIntegerParam(p_Motor3AccW, valueSet);
		if( (valueSet[0] ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor3AccWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Motor3AccWString, valueSet[0] , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Motor3AccW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Motor3VlctyWAdr:
		status = (asynStatus) getIntegerParam(p_Motor3VlctyW, valueSet);
		if( (valueSet[0] ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor3VlctyWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Motor3VlctyWString, valueSet[0] , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Motor3VlctyW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Motor3StepsWAdr:
		status = (asynStatus) getIntegerParam(p_Motor3StepsW, valueSet);
		if( (valueSet[0] ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor3StepsWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Motor3StepsWString, valueSet[0] , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Motor3StepsW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Motor3DrviWAdr:
		status = (asynStatus) getIntegerParam(p_Motor3DrviW, valueSet);
		if( (valueSet[0] ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor3DrviWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Motor3DrviWString, valueSet[0] , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Motor3DrviW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Motor3CntlWAdr:
		status = (asynStatus) getIntegerParam(p_Motor3CntlW, valueSet);
		if( (valueSet[0] ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor3CntlWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Motor3CntlWString, valueSet[0] , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Motor3CntlW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Piezo3Dac1WAdr:
		status = (asynStatus) getIntegerParam(p_Piezo3Dac1W, valueSet);
		if( (valueSet[0] ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3Dac1WString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3Dac1WString, valueSet[0] , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Piezo3Dac1W, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Piezo3Dac2WAdr:
		status = (asynStatus) getIntegerParam(p_Piezo3Dac2W, valueSet);
		if( (valueSet[0] ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3Dac2WString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3Dac2WString, valueSet[0] , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Piezo3Dac2W, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Piezo3HighWindowWAdr:
		status = (asynStatus) getIntegerParam(p_Piezo3HighWindowW, valueSet);
		if( (valueSet[0] ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3HighWindowWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3HighWindowWString, valueSet[0] , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Piezo3HighWindowW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Piezo3LowWindowWAdr:
		status = (asynStatus) getIntegerParam(p_Piezo3LowWindowW, valueSet);
		if( (valueSet[0] ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3LowWindowWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3LowWindowWString, valueSet[0] , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Piezo3LowWindowW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Piezo3CntlWAdr:
		status = (asynStatus) getIntegerParam(p_Piezo3CntlW, valueSet);
		if( (valueSet[0] ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3CntlWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3CntlWString, valueSet[0] , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Piezo3CntlW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Piezo3IgainWAdr:
		status = (asynStatus) getIntegerParam(p_Piezo3IgainW, valueSet);
		if( (valueSet[0] ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3IgainWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3IgainWString, valueSet[0] , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Piezo3IgainW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Motor4AccWAdr:
		status = (asynStatus) getIntegerParam(p_Motor4AccW, valueSet);
		if( (valueSet[0] ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor4AccWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Motor4AccWString, valueSet[0] , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Motor4AccW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Motor4VlctyWAdr:
		status = (asynStatus) getIntegerParam(p_Motor4VlctyW, valueSet);
		if( (valueSet[0] ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor4VlctyWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Motor4VlctyWString, valueSet[0] , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Motor4VlctyW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Motor4StepsWAdr:
		status = (asynStatus) getIntegerParam(p_Motor4StepsW, valueSet);
		if( (valueSet[0] ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor4StepsWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Motor4StepsWString, valueSet[0] , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Motor4StepsW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Motor4DrviWAdr:
		status = (asynStatus) getIntegerParam(p_Motor4DrviW, valueSet);
		if( (valueSet[0] ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor4DrviWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Motor4DrviWString, valueSet[0] , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Motor4DrviW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Motor4CntlWAdr:
		status = (asynStatus) getIntegerParam(p_Motor4CntlW, valueSet);
		if( (valueSet[0] ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Motor4CntlWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Motor4CntlWString, valueSet[0] , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Motor4CntlW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Piezo4Dac1WAdr:
		status = (asynStatus) getIntegerParam(p_Piezo4Dac1W, valueSet);
		if( (valueSet[0] ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4Dac1WString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4Dac1WString, valueSet[0] , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Piezo4Dac1W, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Piezo4Dac2WAdr:
		status = (asynStatus) getIntegerParam(p_Piezo4Dac2W, valueSet);
		if( (valueSet[0] ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4Dac2WString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4Dac2WString, valueSet[0] , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Piezo4Dac2W, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Piezo4HighWindowWAdr:
		status = (asynStatus) getIntegerParam(p_Piezo4HighWindowW, valueSet);
		if( (valueSet[0] ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4HighWindowWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4HighWindowWString, valueSet[0] , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Piezo4HighWindowW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Piezo4LowWindowWAdr:
		status = (asynStatus) getIntegerParam(p_Piezo4LowWindowW, valueSet);
		if( (valueSet[0] ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4LowWindowWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4LowWindowWString, valueSet[0] , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Piezo4LowWindowW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Piezo4CntlWAdr:
		status = (asynStatus) getIntegerParam(p_Piezo4CntlW, valueSet);
		if( (valueSet[0] ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4CntlWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4CntlWString, valueSet[0] , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Piezo4CntlW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case Piezo4IgainWAdr:
		status = (asynStatus) getIntegerParam(p_Piezo4IgainW, valueSet);
		if( (valueSet[0] ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4IgainWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4IgainWString, valueSet[0] , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_Piezo4IgainW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
	default:
		getIntegerParam(p_CommErrorCount, &errorCount);
		setIntegerParam(p_CommErrorCount, ++errorCount);

		status = asynError;
		break;
    }

	// TODO: handle arrays

    return status;
}



extern "C" {

/* Configuration routine.  Called directly, or from the iocsh function below */

/** EPICS iocsh callable function to call constructor for the scllrfRES class.
 * \param[in] portName The name of the asyn port driver to be created.
 * \param[in] netPortName The name of the asynIPport this will use to communicate */
int scllrfRESConfigure(const char *drvPortName, const char *netPortName)
{
	new scllrfRESDriver(drvPortName, netPortName);
	return asynSuccess;
}


/* EPICS iocsh shell commands */

static const iocshArg initArg0 = { "drvPortName",iocshArgString};
static const iocshArg initArg1 = { "IP port name",iocshArgString};
static const iocshArg * const initArgs[] = {&initArg0,
		&initArg1};
static const iocshFuncDef initFuncDef = {"scllrfRESConfigure",2,initArgs};
static void initCallFunc(const iocshArgBuf *args)
{
	scllrfRESConfigure(args[0].sval, args[1].sval);
}

void scllrfRESRegister(void)
{
	iocshRegister(&initFuncDef,initCallFunc);
}

epicsExportRegistrar(scllrfRESRegister);

}




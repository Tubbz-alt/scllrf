/*
 * scllrfAsynPortDriver.h
 *
 * Prototype for FPGA register access to FPGAs using protocol defined in papers
 * given to SLAC by Larry Doolittle. Uses asynPortDriver interface. Some of this
 * should eventually be autogenerated from json files or some such, and templates.
 *
 *  Created on: Jun 17, 2016
 *      Author: gwbrown
 */

#ifndef scllrfAPP_SRC_scllrfASYNPORTDRIVER_H_
#define scllrfAPP_SRC_scllrfASYNPORTDRIVER_H_

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <stdint.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <iostream>
#include <vector>
//#include <atomic>

#include <epicsTypes.h>
#include <epicsThread.h>
#include <epicsEvent.h>
#include <iocsh.h>

#include <asynPortDriver.h>

#include <epicsExport.h>

const size_t regCount = 0x20;

// Move these to a common file somewhere

// First byte of data is for control (read/write flag)
// Next 3 bytes are the address
// last 32 bits are data
typedef struct
{
	uint32_t addr;
	int32_t data;
} FpgaReg;

unsigned int nonceSize = 1; // nonce is one FpgaReg big

// Functions to convert arrays of registers in place.
/**
* Convert an array of FpgaReg elements to network byte order in place
* @param buffer Array of FpgaReg elements to be sent over the network
* @param regCount the dimension of the buffer, not the number of bytes
* @see ntohFpgaRegArray
* @return The test results
*/
void htonFpgaRegArray(FpgaReg *buffer, unsigned int regCount);
/**
* Convert an array of FpgaReg elements from network byte order in place
* @param buffer Array of FpgaReg elements received over the network
* @param regCount the dimension of the buffer, not the number of bytes
* @see htonFpgaRegArray
* @return The test results
*/
void ntohFpgaRegArray(FpgaReg *buffer, unsigned int regCount);

// Set this bit in the control portion of address to request a reg read
const uint32_t flagReadMask = 0x10000000;

// Mask for the lower 24 bits of the addr field
const uint32_t addrMask = 0x00FFFFFF;

// Something easy to spot assigned to uninitialized data
const int32_t blankData = 0xDEADBEEF;

// Waveform data is packed as 2D arrays, not one after the other
// in the network data. See cmoc code "submodules/common_hdl/circle.txt" for more details.
// Summary: (array 1, data 1 and 2), (array 2, data 1 and 2), (array 3, data 1 and 2)....
const uint32_t wavesStart = 0x004000; // From FPGA design, base address
const uint32_t wavesEnd = 0x005fff; // From FPGA design
const unsigned waveBufferRegCount = wavesEnd - wavesStart + 1;
const unsigned wavesCount = 8; // From FPGA design, number of waveforms interlaced in waveform buffer
const unsigned maxMsgSize = 1400; // Estimated MTU minus fudge factor, in bytes
/**< Waveform buffer is read in waveSegmentCount segments due to network packet size limits.
 *  1+ is an approximation of "round upwards". -1 makes space for the nonce */
const unsigned waveSegmentCount = 1 + (sizeof(FpgaReg) * waveBufferRegCount)/(maxMsgSize - sizeof(FpgaReg));

/**< Size of each segment, in number of registers */
const unsigned waveSegmentSize = 1 + (waveBufferRegCount + waveSegmentCount)/waveSegmentCount;
const uint32_t wavesReadyMask = 0x100; // found in the first 0x1F registers

// EPICS database driver strings
const char *RunStopString = "RUN_STOP";            /* asynInt32,    r/w */
const char *MaxParallelRequestsString = "MAX_PARALLEL_REQUESTS";            /* asynInt32,    r/w */
const char *PollPeriodString = "POLL_PERIOD";            /* asynInt32,    r/w */
const char *MagicString = "MAGIC";
const char *DspFlavorString = "DSP_FLAVOR";
const char *BuildYearString = "BUILD_YEAR";
const char *BuildMonthString = "BUILD_MONTH";
const char *BuildDayString = "BUILD_DAY";
const char *BuildHourString = "BUILD_HOUR";
const char *BuildMinuteString = "BUILD_MINUTE";
const char *CodeIsCleanString = "CODE_IS_CLEAN";
const char *ToolRevString = "TOOL_REV";
const char *UserString = "USER";
const char *BoardTypeString = "BOARD_TYPE";
const char *VersionString = "VERSION";
const char *GitSHA1aString = "GIT_SHA_1A";
const char *GitSHA1bString = "GIT_SHA_1B";
const char *GitSHA1cString = "GIT_SHA_1C";
const char *GitSHA1dString = "GIT_SHA_1D";
const char *GitSHA1eString = "GIT_SHA_1E";
const char *GitSHA1fString = "GIT_SHA_1F";
const char *GitSHA1gString = "GIT_SHA_1G";
const char *GitSHA1hString = "GIT_SHA_1H";
const char *GitSHA1iString = "GIT_SHA_1I";
const char *GitSHA1jString = "GIT_SHA_1J";
const char *GitSHA1kString = "GIT_SHA_1K";
const char *GitSHA1lString = "GIT_SHA_1L";
const char *GitSHA1mString = "GIT_SHA_1M";
const char *GitSHA1nString = "GIT_SHA_1N";
const char *GitSHA1oString = "GIT_SHA_1O";
const char *GitSHA1pString = "GIT_SHA_1P";
const char *GitSHA1qString = "GIT_SHA_1Q";
const char *GitSHA1rString = "GIT_SHA_1R";
const char *GitSHA1sString = "GIT_SHA_1S";
const char *GitSHA1tString = "GIT_SHA_1T";
const char *DspFdbkCoreMpProcCoeffString = "DSP_FDBK_CORE_MP_PROC_COEFF";
const char *DspFdbkCoreMpProcLimString = "DSP_FDBK_CORE_MP_PROC_LIM";
const char *DspFdbkCoreMpProcSetmpString = "DSP_FDBK_CORE_MP_PROC_SETMP";
const char *DspLpNotchLp1AKxString = "DSP_LP_NOTCH_LP1A_KX";
const char *DspLpNotchLp1AKyString = "DSP_LP_NOTCH_LP1A_KY";
const char *DspLpNotchLp1BKxString = "DSP_LP_NOTCH_LP1B_KX";
const char *DspLpNotchLp1BKyString = "DSP_LP_NOTCH_LP1B_KY";
const char *DspChanKeepString = "DSP_CHAN_KEEP";
const char *DspFdbkCoreCoarseScaleString = "DSP_FDBK_CORE_COARSE_SCALE";
const char *DspFdbkCoreMpProcPhOffsetString = "DSP_FDBK_CORE_MP_PROC_PH_OFFSET";
const char *DspFdbkCoreMpProcSelEnString = "DSP_FDBK_CORE_MP_PROC_SEL_EN";
const char *DspFdbkCoreMpProcSelThreshString = "DSP_FDBK_CORE_MP_PROC_SEL_THRESH";
const char *DspModuloString = "DSP_MODULO";
const char *DspPhaseStepString = "DSP_PHASE_STEP";
const char *DspPiezoPiezoDcString = "DSP_PIEZO_PIEZO_DC";
const char *DspTagString = "DSP_TAG";
const char *DspWaveSampPerString = "DSP_WAVE_SAMP_PER";
const char *DspWaveShiftString = "DSP_WAVE_SHIFT";
const char *Waveform1String = "WAVEFORM";          /* asynInt32Array,  r/w */

const double readTimeout = 5.0; // seconds
const double writeTimeout = 5.0; // seconds
const double defaultPollPeriod = 0.5; // seconds
const double throttleLoopDelay = 0.001; // seconds, delay when sending is outstripping reading
const unsigned int defaultMaxParallelRequests = 5; // throttle requests when this many are outstanding

class scllrfAsynPortDriver : public asynPortDriver
{
public:
	scllrfAsynPortDriver(const char *drvPortName, const char *netPortName);
	virtual ~scllrfAsynPortDriver();
	asynStatus writeInt32(asynUser *pasynUser, epicsInt32 value);
	asynStatus writeInt32Array(asynUser *pasynUser, epicsInt32 *value,
	                                size_t nElements);

    /* Define a polling mechanism.
     * Sends requests for all register data at a specified period.
     * A separate thread processes the response.
     */
	void regPoller(); // Polling loop, exits on shutdown
    virtual asynStatus wakeupPoller(); // Alert poller to request new data
    virtual asynStatus sendRegRequest(FpgaReg *regBuffer, unsigned int regBuffSize); // Send out canned request for all registers

    void waveformRequester(); // When signaled that waveforms are waiting, request them.

    virtual void responseHandler(); // Readback loop, processes data from FPGAs when it arrives
    virtual asynStatus wakeupReader(); // Alert responseHandler to expect new data

protected:

    virtual asynStatus startPoller(double pollPeriod); // For system startup
    virtual asynStatus startWaveformRequester(); // For system startup
    // Response handler, reads data sent back from FPGA and assigns it to
    // the appropriate variables and pvs.
    virtual asynStatus startResponseHandler(); // For system startup
    asynStatus processReadbackBuffer(FpgaReg *pFromFpga, unsigned int readCount);
    virtual asynStatus processRegWriteResponse(const FpgaReg *pFromFpga);
    virtual asynStatus processRegReadback(const FpgaReg *pFromFpga, bool &waveIsReady); // parse register data, write to PVs
    virtual asynStatus processWaveReadback(const FpgaReg *pFromFpga); // parse register data, write to array PV
    virtual asynStatus functionToRegister(const int function, FpgaReg *pToFpga); /**< Translate asyn function number/reason to a register address */

    epicsEventId pollEventId_;    /**< Event ID to wake up poller */
    double pollPeriod_;           /**< The time between polls */
    epicsEventId readEventId_;    /**< Event ID to wake up poller */
    double readTimeout_;           /**< The time between polls */
    epicsEventId reqWaveEventId_;    /**< Event ID to signal the waveform requester */
    bool isShuttingDown_; /**< Flag to indicate threads should exit */
    asynUser* pCommonAsynUser_; /**< asynUser for asynCommonSyncIO */
    asynUser* pOctetAsynUser_; /**< asynUser for asynOctetSyncIO */
    unsigned int netSendCount_; /**< Number of messages sent to FPGA, sent in nonce for error checking */
    unsigned int lastResponseCount_; /**< Used by response processing to check for missing or out of order responses */
//  std::atomic<uint> netWaitingRequests; // writers increment, reader decrements
    unsigned int netWaitingRequests_; /**< writers increment, reader decrements */
    unsigned int newWaveAvailable_; /**< netSendCount value of the latest response with the "new waveform" flag set */
    unsigned int newWaveRead_;      /**< netSendCount for the most recent waveform */
    enum {stop, run};
    epicsInt32 pWaveform_[wavesCount][waveBufferRegCount/wavesCount];

    /** Values used for pasynUser->reason, and indexes into the parameter library.
     * For this prototype, it's read only values that identify the FPGA. */
    int p_RunStop;
#define FIRST_CMOC_COMMAND p_RunStop
    int p_MaxParallelRequests;
    int p_PollPeriod;
    int p_Magic;
    int p_DspFlavor;
    int p_BuildYear;
    int p_BuildMonth;
    int p_BuildDay;
    int p_BuildHour;
    int p_BuildMinute;
    int p_CodeIsClean;
    int p_ToolRev;
    int p_User;
    int p_BoardType;
    int p_Version;
    int p_GitSHA1a;
    int p_GitSHA1b;
    int p_GitSHA1c;
    int p_GitSHA1d;
    int p_GitSHA1e;
    int p_GitSHA1f;
    int p_GitSHA1g;
    int p_GitSHA1h;
    int p_GitSHA1i;
    int p_GitSHA1j;
    int p_GitSHA1k;
    int p_GitSHA1l;
    int p_GitSHA1m;
    int p_GitSHA1n;
    int p_GitSHA1o;
    int p_GitSHA1p;
    int p_GitSHA1q;
    int p_GitSHA1r;
    int p_GitSHA1s;
    int p_GitSHA1t;
    int p_DspFdbkCoreMpProcCoeff;
    int p_DspFdbkCoreMpProcLim;
    int p_DspFdbkCoreMpProcSetmp;
    int p_DspLpNotchLp1AKx;
    int p_DspLpNotchLp1AKy;
    int p_DspLpNotchLp1BKx;
    int p_DspLpNotchLp1BKy;
    int p_DspChanKeep;
    int p_DspFdbkCoreCoarseScale;
    int p_DspFdbkCoreMpProcPhOffset;
    int p_DspFdbkCoreMpProcSelEn;
    int p_DspFdbkCoreMpProcSelThresh;
    int p_DspModulo;
    int p_DspPhaseStep;
    int p_DspPiezoPiezoDc;
    int p_DspTag;
    int p_DspWaveSampPer;
    int p_DspWaveShift;
    int p_Waveform;
    #define LAST_CMOC_COMMAND p_Waveform

    // mapping of register names to addresses
    // Note that the same address may access a different register reading than writing
    enum RegReadAddrs
    {
    	MagicAdr = 0x00,
    	DspFlavorAdr = 0x01,
    	BuildYearAdr = 0x02,
    	BuildMonthAdr = 0x03,
    	BuildDayAdr = 0x04,
    	BuildHourAdr = 0x05,
    	BuildMinuteAdr = 0x06,
    	CodeIsCleanAdr = 0x07,
    	ToolRevAdr = 0x08,
    	UserAdr = 0x09,
    	BoardTypeAdr = 0x0a,
    	VersionAdr = 0x0b,
    	GitSHA1aAdr = 0x0c,
    	GitSHA1bAdr = 0x0d,
    	GitSHA1cAdr = 0x0e,
    	GitSHA1dAdr = 0x0f,
    	GitSHA1eAdr = 0x10,
    	GitSHA1fAdr = 0x11,
    	GitSHA1gAdr = 0x12,
    	GitSHA1hAdr = 0x13,
    	GitSHA1iAdr = 0x14,
    	GitSHA1jAdr = 0x15,
    	GitSHA1kAdr = 0x16,
    	GitSHA1lAdr = 0x17,
    	GitSHA1mAdr = 0x18,
    	GitSHA1nAdr = 0x19,
    	GitSHA1oAdr = 0x1a,
    	GitSHA1pAdr = 0x1b,
    	GitSHA1qAdr = 0x1c,
    	GitSHA1rAdr = 0x1d,
    	GitSHA1sAdr = 0x1e,
    	GitSHA1tAdr = 0x1f
    };

    enum RegWriteAddrs
    {
    	DspFdbkCoreMpProcCoeffAdr = 0x0000,
    	DspFdbkCoreMpProcLimAdr = 0x0004,
    	DspFdbkCoreMpProcSetmpAdr = 0x0008,
    	DspLpNotchLp1AKxAdr = 0x000C,
    	DspLpNotchLp1AKyAdr = 0x000E,
    	DspLpNotchLp1BKxAdr = 0x0010,
    	DspLpNotchLp1BKyAdr = 0x0012,
    	DspChanKeepAdr = 0x0014,
    	DspFdbkCoreCoarseScaleAdr = 0x0015,
    	DspFdbkCoreMpProcPhOffsetAdr = 0x0016,
    	DspFdbkCoreMpProcSelEnAdr = 0x0017,
    	DspFdbkCoreMpProcSelThreshAdr = 0x0018,
    	DspModuloAdr = 0x0019,
    	DspPhaseStepAdr = 0x001A,
    	DspPiezoPiezoDcAdr = 0x001B,
    	DspTagAdr = 0x001C,
    	DspWaveSampPerAdr = 0x001D,
    	DspWaveShiftAdr = 0x001E,
    };

    // masks applied to returned register data
    enum RegMasks
    {
    	DspFdbkCoreMpProcCoeffMask =  0x0003FFFF,
    	DspFdbkCoreMpProcLimMask =  0x0003FFFF,
    	DspFdbkCoreMpProcSetmpMask =  0x0003FFFF,
    	DspLpNotchLp1AKxMask =  0x0003FFFF,
    	DspLpNotchLp1AKyMask =  0x0003FFFF,
    	DspLpNotchLp1BKxMask =  0x0003FFFF,
    	DspLpNotchLp1BKyMask =  0x0003FFFF,
    	DspChanKeepMask =  0x00000FFF,
    	DspFdbkCoreCoarseScaleMask =  0x00000003,
    	DspFdbkCoreMpProcPhOffsetMask =  0x0003FFFF,
    	DspFdbkCoreMpProcSelEnMask =  0x00000001,
    	DspFdbkCoreMpProcSelThreshMask =  0x0003FFFF,
    	DspModuloMask =  0x00000FFF,
    	DspPhaseStepMask =  0xFFFFFFFF,
    	DspPiezoPiezoDcMask =  0x0000FFFF,
    	DspTagMask =  0x000000FF,
    	DspWaveSampPerMask =  0x0000007F,
    	DspWaveShiftMask =  0x00000007,
    	MagicMask = 0xff,
    	DspFlavorMask = 0xff,
    	BuildYearMask = 0xff,
    	BuildMonthMask = 0xff,
    	BuildDayMask = 0xff,
    	BuildHourMask = 0xff,
    	BuildMinuteMask = 0xff,
    	CodeIsCleanMask = 0xff,
    	ToolRevMask = 0xff,
    	UserMask = 0xff,
    	BoardTypeMask = 0xff,
    	VersionMask = 0xff,
    	GitSHA1aMask = 0xff,
    	GitSHA1bMask = 0xff,
    	GitSHA1cMask = 0xff,
    	GitSHA1dMask = 0xff,
    	GitSHA1eMask = 0xff,
    	GitSHA1fMask = 0xff,
    	GitSHA1gMask = 0xff,
    	GitSHA1hMask = 0xff,
    	GitSHA1iMask = 0xff,
    	GitSHA1jMask = 0xff,
    	GitSHA1kMask = 0xff,
    	GitSHA1lMask = 0xff,
    	GitSHA1mMask = 0xff,
    	GitSHA1nMask = 0xff,
    	GitSHA1oMask = 0xff,
    	GitSHA1pMask = 0xff,
    	GitSHA1qMask = 0xff,
    	GitSHA1rMask = 0xff,
    	GitSHA1sMask = 0xff,
    	GitSHA1tMask = 0xff
    };

};

/* Initial testing registers:
 *     0000:   85   //  0x55  magic
    0001:    7   //  0x07  dsp flavor
    0002:   16   //  0x10  year
    0003:    6   //  0x06  month
    0004:   15   //  0x0f  day
    0005:    4   //  0x04  hour
    0006:   32   //  0x20  minute
    0007:    0   //  0x00  code is (clean), () commits after the latest tag
    0008:    0   //  0x00  tool rev ()
    0009:    1   //  0x01  user (larry)
    000a:   17   //  0x11  board type (ac701)
    000b:    0   //  0x00  version number
    000c: 8'h8c  //  0x8c  start of git commit SHA1
    000d: 8'hd5  //  0xd5  ...
    000e: 8'h10  //  0x10  ...
    000f: 8'hda  //  0xda  ...
    0010: 8'h7b  //  0x7b  ...
    0011: 8'hb8  //  0xb8  ...
    0012: 8'ha1  //  0xa1  ...
    0013: 8'hd4  //  0xd4  ...
    0014: 8'h5d  //  0x5d  ...
    0015: 8'h52  //  0x52  ...
    0016: 8'hc1  //  0xc1  ...
    0017: 8'h90  //  0x90  ...
    0018: 8'h6d  //  0x6d  ...
    0019: 8'hb1  //  0xb1  ...
    001a: 8'hd0  //  0xd0  ...
    001b: 8'hd8  //  0xd8  ...
    001c: 8'h7e  //  0x7e  ...
    001d: 8'he7  //  0xe7  ...
    001e: 8'h2a  //  0x2a  ...
    001f: 8'hc7  //  0xc7  end of SHA1
 *
 */

#endif /* scllrfAPP_SRC_scllrfASYNPORTDRIVER_H_ */

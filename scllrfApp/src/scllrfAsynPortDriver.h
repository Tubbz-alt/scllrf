/**
 *-----------------------------------------------------------------------------
 * Title      : superconducting low level RF EPICS interface
 * ----------------------------------------------------------------------------
 * File       : scllrfAsynPortDriver.h
 * Author     : Garth Brown, gwbrown@slac.stanford.edu
 * Created    : June 17, 2016
 * Last update: September 6, 2016
 * ----------------------------------------------------------------------------
 * Description:
 * Prototype for FPGA register access to FPGAs using protocol defined in papers
 * given to SLAC by LBNL (Larry Doolittle). Uses asynPortDriver interface. Some of this
 * should eventually be autogenerated from json files or some such, and templates.
 *
 * ----------------------------------------------------------------------------
 * This file is part of LCLS II. It is subject to
 * the license terms in the LICENSE.txt file found in the top-level directory
 * of this distribution and at:
	* https://confluence.slac.stanford.edu/display/ppareg/LICENSE.html.
 * No part of LCLS II, including this file, may be
 * copied, modified, propagated, or distributed except according to the terms
 * contained in the LICENSE.txt file.
 * ----------------------------------------------------------------------------
**/

#ifndef SCLLRFAPP_SRC_SCLLRFASYNPORTDRIVER_H_
#define SCLLRFAPP_SRC_SCLLRFASYNPORTDRIVER_H_

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <stdint.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <iostream>
#include <vector>
//#include <atomic>
#include <string>
#include <sstream>
#include <iomanip>


#include <epicsTypes.h>
#include <epicsThread.h>
#include <epicsEvent.h>
#include <iocsh.h>
#include <epicsMessageQueue.h>

#include <asynPortDriver.h>
#include <asynDriver.h>

#include <epicsExport.h>

// Move these to a common file somewhere

// First byte of data is for control (read/write flag)
// Next 3 bytes are the address
// last 32 bits are data
typedef struct
{
	uint32_t addr;
	int32_t data;
} FpgaReg;

static const unsigned int nonceSize = 1; // nonce is one FpgaReg big

// Functions to convert arrays of registers in place.
/**
 * Convert an array of FpgaReg elements to network byte order in place
 * @param buffer Array of FpgaReg elements to be sent over the network
 * @param regCount the dimension of the buffer, not the number of bytes
 * @see ntohFpgaRegArray
 * @return The test results
 */
void htonFpgaRegArray(FpgaReg *buffer, unsigned int regCount);
/**
 * Convert an array of FpgaReg elements from network byte order in place
 * @param buffer Array of FpgaReg elements received over the network
 * @param regCount the dimension of the buffer, not the number of bytes
 * @see htonFpgaRegArray
 * @return The test results
 */
void ntohFpgaRegArray(FpgaReg *buffer, unsigned int regCount);

// snagged from https://graphics.stanford.edu/~seander/bithacks.html#Interleave64bitOps

// I and Q in the *keep registers alternate bits indicating active I or Q.
// This function removes every other bit, so you can get only I or only Q.
// Pinched from https://stackoverflow.com/questions/4909263/how-to-efficiently-de-interleave-bits-inverse-morton
uint32_t DeInterleaveBits(uint32_t x);
unsigned short InterleaveEnableBits(unsigned char i, unsigned char q);

// Set this bit in the control portion of address to request a reg read
static const uint32_t flagReadMask = 0x10000000;

// Mask for the lower 24 bits of the addr field
static const uint32_t addrMask = 0x00FFFFFF;

// Something easy to spot assigned to uninitialized data
static const int32_t blankData = 0xDEADBEEF;

static const unsigned maxMsgSize = 1450; // Estimated MTU minus fudge factor, in bytes
static const unsigned maxRegPerMsg = maxMsgSize/sizeof(FpgaReg)-1; // Number of register requests minus the nonce
static const unsigned minRegPerMsg = 5; // Limitation of UDP and what the FPGA's limited network stack can cope with

// Communication tuning parameters
static const double readTimeout = 1.0; // seconds
static const double writeTimeout = 5.0; // seconds
static const double defaultPollPeriod = 0.1; // seconds
static const double throttleLoopDelay = 0.001; // seconds, delay when sending is outstripping reading
static const unsigned int defaultMaxParallelRequests = 1; // throttle requests when this many are outstanding


/* Registers */


class scllrfAsynPortDriver: public asynPortDriver
{
public:
	scllrfAsynPortDriver(const char *drvPortName, const char *netPortName, int maxAddr=0, int paramTableSize=7);
	virtual ~scllrfAsynPortDriver();
	virtual asynStatus writeInt32(asynUser *pasynUser, epicsInt32 value);
	virtual asynStatus readInt32(asynUser *pasynUser, epicsInt32 *value);
	virtual asynStatus readInt8Array(asynUser *pasynUser, epicsInt8 *value,
			size_t nElements, size_t *nIn);
	virtual asynStatus readInt16Array(asynUser *pasynUser, epicsInt16 *value,
			size_t nElements, size_t *nIn);
	virtual asynStatus readInt32Array(asynUser *pasynUser, epicsInt32 *value,
			size_t nElements, size_t *nIn);
	virtual asynStatus writeInt8Array(asynUser *pasynUser, epicsInt8 *value,
			size_t nElements);
	virtual asynStatus writeInt16Array(asynUser *pasynUser, epicsInt16 *value,
			size_t nElements);
	virtual asynStatus writeInt32Array(asynUser *pasynUser, epicsInt32 *value,
			size_t nElements);
//	virtual asynStatus readInt32Array(asynUser *pasynUser, epicsInt32 *value,
//			size_t nElements, size_t *nIn);
	virtual asynStatus writeUInt32Digital(asynUser *pasynUser, epicsUInt32 value, epicsUInt32 mask);

	/* Define a polling mechanism.
	 * Sends requests for all register data at a specified period.
	 * A separate thread processes the response.
	 */
	void regPoller(); // Polling loop, exits on shutdown
	void regSettingsInit(); // canned settings from LBL
	virtual asynStatus wakeupPoller(); // Alert poller to request new data
	virtual asynStatus sendRegRequest(FpgaReg *regBuffer,
			unsigned int regBuffSize); // Send out canned request for all registers

	virtual void responseHandler(); // Readback loop, processes data from FPGAs when it arrives
	virtual asynStatus wakeupReader(); // Alert responseHandler to expect new data
	virtual void init();
	void singleMessageQueuer(); // Accumulates individual requests until they can be sent together.

protected:

	// EPICS database driver strings
	static const char *RunStopString; /* asynInt32,    r/w */
	static const char *ReadOneRegString; /* asynInt32 array[2] w */
	static const char *WriteOneRegString; /* asynInt32 array[2] w */
	static const char *MaxParallelRequestsString; /* asynInt32,    r/w */
	static const char *PollPeriodString; /* asynInt32,    r/w */
	static const char *CommErrorCountString;  /* asynInt32,    r */


	// Registers relating to the firmware build
	static const char *BoardTypeRString;
	// Day firmware was built
	static const char *BuildDayRString;
	// Hour firmware was built
	static const char *BuildHourRString;
	// Minute firmware was built
	static const char *BuildMinuteRString;
	// Month firmware was built
	static const char *BuildMonthRString;
	// Year firmware was built
	static const char *BuildYearRString;
	static const char *CodeIsCleanRString;
	static const char *DspFlavorRString;
	static const char *GitSha1ARString;
	static const char *GitSha1BRString;
	static const char *GitSha1CRString;
	static const char *GitSha1DRString;
	static const char *GitSha1ERString;
	static const char *GitSha1FRString;
	static const char *GitSha1GRString;
	static const char *GitSha1HRString;
	static const char *GitSha1IRString;
	static const char *GitSha1JRString;
	static const char *GitSha1KRString;
	static const char *GitSha1LRString;
	static const char *GitSha1MRString;
	static const char *GitSha1NRString;
	static const char *GitSha1ORString;
	static const char *GitSha1PRString;
	static const char *GitSha1QRString;
	static const char *GitSha1RRString;
	static const char *GitSha1SRString;
	static const char *GitSha1TRString;
	static const char *GitSHA1String;  /* asynOctet,    r */
	static const char *MagicRString;
	static const char *ToolRevRString;
	// Name of person compiling firmware
	static const char *UserRString;
	static const char *VersionRString;


	// For readable registers that are polled together at the set polling rate
	FpgaReg *pPolledRegMsg_; // Leave the first array element blank, for use as the nonce
	size_t PolledRegMsgSize_; // number of registers plus one for the nonce
	virtual asynStatus startPoller(const char *netPortName, double pollPeriod); // For system startup

	// Response handler, reads data sent back from FPGA and assigns it to
	// the appropriate variables and pvs.
	virtual asynStatus startResponseHandler(const char *netPortName); // For system startup
	asynStatus processReadbackBuffer(FpgaReg *pFromFpga,
			unsigned int readCount);
	virtual asynStatus processRegWriteResponse(const FpgaReg *pFromFpga);
	virtual asynStatus processRegReadback(const FpgaReg *pFromFpga,
			bool &waveIsReady); // parse register data, write to PVs
	virtual asynStatus functionToRegister(const int function, FpgaReg *pToFpga); /**< Translate asyn function number/reason to a register address */

	virtual asynStatus catGitSHA1(); // Once the individual bytes are all read into registers, concatenate them into a string

	virtual asynStatus startSingleMessageQueuer(const char *netPortName);
	epicsEventId singleMsgQueueEventId_; /**< Event ID to signal the write message queuer */
	epicsMessageQueue _singleMsgQ;

	void fillWaveRequestMsg(FpgaReg pMsgBuff[], const size_t buffSize, const unsigned int iStartAddr); /**< For requesting a waveform, fill canned message request with sequential addresses */
	asynStatus sendBigBuffer(FpgaReg *regBuffer, unsigned int regBuffCount); /**< A message composed by fillWaveRequestMsg can be sent with this function */

	epicsEvent pollEvent_; /**< Event ID to wake up poller */
	double pollPeriod_; /**< The time between polls */
	epicsEventId readEventId_; /**< Event ID to wake up network message response reader */
	double readTimeout_; /**< The time between polls */
	epicsEventId reqWaveEventId_; /**< Event ID to signal the waveform requester */
	bool isShuttingDown_; /**< Flag to indicate threads should exit */
	asynUser* pCommonAsynUser_; /**< asynUser for asynCommonSyncIO */
	asynUser* pOctetAsynUser_; /**< asynUser for asynOctetSyncIO */
	epicsMutexId comCountersMutexId_;
	unsigned int netSendCount_; /**< Number of messages sent to FPGA, sent in nonce for error checking */
	unsigned int lastResponseCount_; /**< Used by response processing to check for missing or out of order responses */
//  std::atomic<uint> netWaitingRequests; // writers increment, reader decrements
	unsigned int netWaitingRequests_; /**< writers increment, reader decrements */
	unsigned int newWaveAvailable_; /**< netSendCount value of the latest response with the "new waveform" flag set */
	unsigned int newWaveRead_; /**< netSendCount for the most recent waveform */
	enum
	{
		stop, run
	};

	/* SHA1 hash of register map */
	static const char *regMapSha1String;
	std::ostringstream strGitSHA1;

	/** Values used for pasynUser->reason, and indexes into the parameter library.
	 * For this prototype, it's read only values that identify the FPGA. */
	int p_RunStop;
#define FIRST_SCLLRF_PARAM p_RunStop
	int p_ReadOneReg;
	int p_WriteOneReg;
	int p_MaxParallelRequests;
	int p_PollPeriod;
	int p_CommErrorCount;

	// Registers relating to the firmware build
	int p_BoardTypeR;
	int p_BuildDayR;
	int p_BuildHourR;
	int p_BuildMinuteR;
	int p_BuildMonthR;
	int p_BuildYearR;
	int p_CodeIsCleanR;
	int p_DspFlavorR;
	int p_GitSha1AR;
	int p_GitSha1BR;
	int p_GitSha1CR;
	int p_GitSha1DR;
	int p_GitSha1ER;
	int p_GitSha1FR;
	int p_GitSha1GR;
	int p_GitSha1HR;
	int p_GitSha1IR;
	int p_GitSha1JR;
	int p_GitSha1KR;
	int p_GitSha1LR;
	int p_GitSha1MR;
	int p_GitSha1NR;
	int p_GitSha1OR;
	int p_GitSha1PR;
	int p_GitSha1QR;
	int p_GitSha1RR;
	int p_GitSha1SR;
	int p_GitSha1TR;
	int p_GitSHA1;
	int p_MagicR;
	int p_ToolRevR;
	int p_UserR;
	int p_VersionR;
/* Registers */
	#define LAST_SCLLRF_PARAM p_VersionR

	epicsUInt32 uReadOneRegAddr, uWriteOneRegAddr;

	//Note: the number of parameters must be manually set in the iocsh binding,
	// the addresses of the parameters used in the #define are out of scope there.
#define NUM_SCLLRF_PARAMS (&LAST_SCLLRF_PARAM - &FIRST_SCLLRF_PARAM + 1)

	// mapping of register names to addresses
	enum ReadRegAddrs
	{
		MagicRAdr = 0x00000800,
		DspFlavorRAdr = 0x00000801,
		BuildYearRAdr = 0x00000802,
		BuildMonthRAdr = 0x00000803,
		BuildDayRAdr = 0x00000804,
		BuildHourRAdr = 0x00000805,
		BuildMinuteRAdr = 0x00000806,
		CodeIsCleanRAdr = 0x00000807,
		ToolRevRAdr = 0x00000808,
		UserRAdr = 0x00000809,
		BoardTypeRAdr = 0x0000080A,
		VersionRAdr = 0x0000080B,
		GitSha1ARAdr = 0x0000080C,
		GitSha1BRAdr = 0x0000080D,
		GitSha1CRAdr = 0x0000080E,
		GitSha1DRAdr = 0x0000080F,
		GitSha1ERAdr = 0x00000810,
		GitSha1FRAdr = 0x00000811,
		GitSha1GRAdr = 0x00000812,
		GitSha1HRAdr = 0x00000813,
		GitSha1IRAdr = 0x00000814,
		GitSha1JRAdr = 0x00000815,
		GitSha1KRAdr = 0x00000816,
		GitSha1LRAdr = 0x00000817,
		GitSha1MRAdr = 0x00000818,
		GitSha1NRAdr = 0x00000819,
		GitSha1ORAdr = 0x0000081A,
		GitSha1PRAdr = 0x0000081B,
		GitSha1QRAdr = 0x0000081C,
		GitSha1RRAdr = 0x0000081D,
		GitSha1SRAdr = 0x0000081E,
		GitSha1TRAdr = 0x0000081F,
	};

	// masks applied to returned register data
	enum RegMasks
	{
		MagicMask =  0x000000FF,
		DspFlavorMask =  0x000000FF,
		BuildYearMask =  0x000000FF,
		BuildMonthMask =  0x000000FF,
		BuildDayMask =  0x000000FF,
		BuildHourMask =  0x000000FF,
		BuildMinuteMask =  0x000000FF,
		CodeIsCleanMask =  0x000000FF,
		ToolRevMask =  0x000000FF,
		UserMask =  0x000000FF,
		BoardTypeMask =  0x000000FF,
		VersionMask =  0x000000FF,
		GitSha1AMask =  0x000000FF,
		GitSha1BMask =  0x000000FF,
		GitSha1CMask =  0x000000FF,
		GitSha1DMask =  0x000000FF,
		GitSha1EMask =  0x000000FF,
		GitSha1FMask =  0x000000FF,
		GitSha1GMask =  0x000000FF,
		GitSha1HMask =  0x000000FF,
		GitSha1IMask =  0x000000FF,
		GitSha1JMask =  0x000000FF,
		GitSha1KMask =  0x000000FF,
		GitSha1LMask =  0x000000FF,
		GitSha1MMask =  0x000000FF,
		GitSha1NMask =  0x000000FF,
		GitSha1OMask =  0x000000FF,
		GitSha1PMask =  0x000000FF,
		GitSha1QMask =  0x000000FF,
		GitSha1RMask =  0x000000FF,
		GitSha1SMask =  0x000000FF,
		GitSha1TMask =  0x000000FF,

	};
};

#endif /* SCLLRFAPP_SRC_SCLLRFASYNPORTDRIVER_H_ */

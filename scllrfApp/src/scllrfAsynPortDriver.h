/*
 * scllrfAsynPortDriver.h
 *
 * Prototype for FPGA register access to FPGAs using protocol defined in papers
 * given to SLAC by Larry Doolittle. Uses asynPortDriver interface. Some of this
 * should eventually be autogenerated from json files or some such, and templates.
 *
 *  Created on: Jun 17, 2016
 *      Author: gwbrown
 */

#ifndef scllrfAPP_SRC_scllrfASYNPORTDRIVER_H_
#define scllrfAPP_SRC_scllrfASYNPORTDRIVER_H_

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <stdint.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <iostream>
#include <vector>
//#include <atomic>

#include <epicsTypes.h>
#include <epicsThread.h>
#include <epicsEvent.h>
#include <iocsh.h>

#include <asynPortDriver.h>

#include <epicsExport.h>

//static const char *driverName = "scllrfAsynPortDriver";

const size_t regCount = 0x20;

// Move these to a common file somewhere

// First byte of data is for control (read/write flag)
// Next 3 bytes are the address
// last 32 bits are data
typedef struct
{
	uint32_t addr;
	int32_t data;
} FpgaReg;

unsigned int nonceSize = 1; // nonce is one FpgaReg big

// Functions to convert arrays of registers in place.
/**
* Convert an array of FpgaReg elements to network byte order in place
* @param buffer Array of FpgaReg elements to be sent over the network
* @param regCount the dimension of the buffer, not the number of bytes
* @see ntohFpgaRegArray
* @return The test results
*/
void htonFpgaRegArray(FpgaReg *buffer, unsigned int regCount);
/**
* Convert an array of FpgaReg elements from network byte order in place
* @param buffer Array of FpgaReg elements received over the network
* @param regCount the dimension of the buffer, not the number of bytes
* @see htonFpgaRegArray
* @return The test results
*/
void ntohFpgaRegArray(FpgaReg *buffer, unsigned int regCount);

// Set this bit in the control portion of address to request a reg read
const uint32_t flagReadMask = 0x10000000;

// Mask for the lower 24 bits of the addr field
const uint32_t addrMask = 0x00FFFFFF;

// Something easy to spot assigned to uninitialized data
const int32_t blankData = 0xDEADBEEF;

// Waveform data is packed as 2D arrays, not one after the other
// in the network data. See cmoc code "submodules/common_hdl/circle.txt" for more details.
// Summary: (array 1, data 1 and 2), (array 2, data 1 and 2), (array 3, data 1 and 2)....
const uint32_t wavesStart = 0x004000; // From FPGA design, base address
const uint32_t wavesEnd = 0x005fff; // From FPGA design
const unsigned waveBufferRegCount = wavesEnd - wavesStart + 1;
const unsigned wavesCount = 8; // From FPGA design, number of waveforms interlaced in waveform buffer
const unsigned maxMsgSize = 1400; // Estimated MTU minus fudge factor, in bytes
/**< Waveform buffer is read in waveSegmentCount segments due to network packet size limits.
 *  1+ is an approximation of "round upwards". -1 makes space for the nonce */
const unsigned waveSegmentCount = 1 + (sizeof(FpgaReg) * waveBufferRegCount)/(maxMsgSize - sizeof(FpgaReg));

/**< Size of each segment, in number of registers */
const unsigned waveSegmentSize = 1 + (waveBufferRegCount + waveSegmentCount)/waveSegmentCount;
const uint32_t wavesReadyMask = 0x100; // found in the first 0x1F registers

// EPICS database driver strings
const char *P_MagicString = "MAGIC";
const char *P_DspFlavorString = "DSP_FLAVOR";
const char *P_BuildYearString = "BUILD_YEAR";
const char *P_BuildMonthString = "BUILD_MONTH";
const char *P_BuildDayString = "BUILD_DAY";
const char *P_BuildHourString = "BUILD_HOUR";
const char *P_BuildMinuteString = "BUILD_MINUTE";
const char *P_CodeIsCleanString = "CODE_IS_CLEAN";
const char *P_ToolRevString = "TOOL_REV";
const char *P_UserString = "USER";
const char *P_BoardTypeString = "BOARD_TYPE";
const char *P_VersionString = "VERSION";
const char *P_GitSHA1aString = "GIT_SHA_1A";
const char *P_GitSHA1bString = "GIT_SHA_1B";
const char *P_GitSHA1cString = "GIT_SHA_1C";
const char *P_GitSHA1dString = "GIT_SHA_1D";
const char *P_GitSHA1eString = "GIT_SHA_1E";
const char *P_GitSHA1fString = "GIT_SHA_1F";
const char *P_GitSHA1gString = "GIT_SHA_1G";
const char *P_GitSHA1hString = "GIT_SHA_1H";
const char *P_GitSHA1iString = "GIT_SHA_1I";
const char *P_GitSHA1jString = "GIT_SHA_1J";
const char *P_GitSHA1kString = "GIT_SHA_1K";
const char *P_GitSHA1lString = "GIT_SHA_1L";
const char *P_GitSHA1mString = "GIT_SHA_1M";
const char *P_GitSHA1nString = "GIT_SHA_1N";
const char *P_GitSHA1oString = "GIT_SHA_1O";
const char *P_GitSHA1pString = "GIT_SHA_1P";
const char *P_GitSHA1qString = "GIT_SHA_1Q";
const char *P_GitSHA1rString = "GIT_SHA_1R";
const char *P_GitSHA1sString = "GIT_SHA_1S";
const char *P_GitSHA1tString = "GIT_SHA_1T";
const char *P_Waveform1String = "WAVEFORM";          /* asynInt32Array,  r/w */

const double readTimeout = 5.0; // seconds
const double writeTimeout = 5.0; // seconds
const double defaultPollPeriod = 0.1; // seconds
const unsigned int throttlePoint = 16; // throttle requests when this many are outstanding
const double throttleLoopDelay = 0.001; // seconds, delay when sending is outstripping reading

class scllrfAsynPortDriver : public asynPortDriver
{
public:
	scllrfAsynPortDriver(const char *drvPortName, const char *netPortName);
	virtual ~scllrfAsynPortDriver();
	asynStatus readInt32(asynUser *pasynUser, epicsInt32 *value);

    /* Define a polling mechanism.
     * Sends requests for all register data at a specified period.
     * A separate thread processes the response.
     */
	void regPoller(); // Polling loop, exits on shutdown
    virtual asynStatus wakeupPoller(); // Alert poller to request new data
    virtual asynStatus sendRegRequest(FpgaReg *regBuffer, unsigned int regBuffSize); // Send out canned request for all registers

    void waveformRequester(); // When signaled that waveforms are waiting, request them.

    virtual void responseHandler(); // Readback loop, processes data from FPGAs when it arrives
    virtual asynStatus wakeupReader(); // Alert responseHandler to expect new data

protected:

    virtual asynStatus startPoller(double pollPeriod); // For system startup
    virtual asynStatus startWaveformRequester(); // For system startup
    // Response handler, reads data sent back from FPGA and assigns it to
    // the appropriate variables and pvs.
    virtual asynStatus startResponseHandler(); // For system startup
    asynStatus processReadbackBuffer(const FpgaReg *pFromFpga);
    virtual asynStatus processRegReadback(const FpgaReg *pFromFpga, bool &waveIsReady); // parse register data, write to PVs
    virtual asynStatus processWaveReadback(const FpgaReg *pFromFpga); // parse register data, write to array PV

    epicsEventId pollEventId_;    /**< Event ID to wake up poller */
    double pollPeriod_;           /**< The time between polls */
    epicsEventId readEventId_;    /**< Event ID to wake up poller */
    double readTimeout_;           /**< The time between polls */
    epicsEventId reqWaveEventId_;    /**< Event ID to signal the waveform requester */
    bool isShuttingDown_; /**< Flag to indicate threads should exit */
    asynUser* pCommonAsynUser_; /**< asynUser for asynCommonSyncIO */
    asynUser* pOctetAsynUser_; /**< asynUser for asynOctetSyncIO */
    unsigned int netSendCount_; /**< Number of messages sent to FPGA, sent in nonce for error checking */
    unsigned int lastResponseCount_; /**< Used by response processing to check for missing or out of order responses */
//  std::atomic<uint> netWaitingRequests; // writers increment, reader decrements
    unsigned int netWaitingRequests_; /**< writers increment, reader decrements */
    unsigned int newWaveAvailable_; /**< netSendCount value of the latest response with the "new waveform" flag set */
    unsigned int newWaveRead_;      /**< netSendCount for the most recent waveform */

    epicsInt32 pWaveform_[wavesCount][waveBufferRegCount/wavesCount];

    /** Values used for pasynUser->reason, and indexes into the parameter library.
     * For this prototype, it's read only values that identify the FPGA. */
    int P_Magic;
    #define FIRST_CMOC_COMMAND P_Magic
    int P_DspFlavor;
    int P_BuildYear;
    int P_BuildMonth;
    int P_BuildDay;
    int P_BuildHour;
    int P_BuildMinute;
    int P_CodeIsClean;
    int P_ToolRev;
    int P_User;
    int P_BoardType;
    int P_Version;
    int P_GitSHA1a;
    int P_GitSHA1b;
    int P_GitSHA1c;
    int P_GitSHA1d;
    int P_GitSHA1e;
    int P_GitSHA1f;
    int P_GitSHA1g;
    int P_GitSHA1h;
    int P_GitSHA1i;
    int P_GitSHA1j;
    int P_GitSHA1k;
    int P_GitSHA1l;
    int P_GitSHA1m;
    int P_GitSHA1n;
    int P_GitSHA1o;
    int P_GitSHA1p;
    int P_GitSHA1q;
    int P_GitSHA1r;
    int P_GitSHA1s;
    int P_GitSHA1t;
    int P_Waveform;
    #define LAST_CMOC_COMMAND P_Waveform

    // mapping of register names to addresses
    enum RegAddrs
    {
    	MagicAdr = 0x00,
    	DspFlavorAdr = 0x01,
    	BuildYearAdr = 0x02,
    	BuildMonthAdr = 0x03,
    	BuildDayAdr = 0x04,
    	BuildHourAdr = 0x05,
    	BuildMinuteAdr = 0x06,
    	CodeIsCleanAdr = 0x07,
    	ToolRevAdr = 0x08,
    	UserAdr = 0x09,
    	BoardTypeAdr = 0x0a,
    	VersionAdr = 0x0b,
    	GitSHA1aAdr = 0x0c,
    	GitSHA1bAdr = 0x0d,
    	GitSHA1cAdr = 0x0e,
    	GitSHA1dAdr = 0x0f,
    	GitSHA1eAdr = 0x10,
    	GitSHA1fAdr = 0x11,
    	GitSHA1gAdr = 0x12,
    	GitSHA1hAdr = 0x13,
    	GitSHA1iAdr = 0x14,
    	GitSHA1jAdr = 0x15,
    	GitSHA1kAdr = 0x16,
    	GitSHA1lAdr = 0x17,
    	GitSHA1mAdr = 0x18,
    	GitSHA1nAdr = 0x19,
    	GitSHA1oAdr = 0x1a,
    	GitSHA1pAdr = 0x1b,
    	GitSHA1qAdr = 0x1c,
    	GitSHA1rAdr = 0x1d,
    	GitSHA1sAdr = 0x1e,
    	GitSHA1tAdr = 0x1f
    };

    // masks applied to returned register data
    enum RegMasks
    {
    	MagicMask = 0xff,
    	DspFlavorMask = 0xff,
    	BuildYearMask = 0xff,
    	BuildMonthMask = 0xff,
    	BuildDayMask = 0xff,
    	BuildHourMask = 0xff,
    	BuildMinuteMask = 0xff,
    	CodeIsCleanMask = 0xff,
    	ToolRevMask = 0xff,
    	UserMask = 0xff,
    	BoardTypeMask = 0xff,
    	VersionMask = 0xff,
    	GitSHA1aMask = 0xff,
    	GitSHA1bMask = 0xff,
    	GitSHA1cMask = 0xff,
    	GitSHA1dMask = 0xff,
    	GitSHA1eMask = 0xff,
    	GitSHA1fMask = 0xff,
    	GitSHA1gMask = 0xff,
    	GitSHA1hMask = 0xff,
    	GitSHA1iMask = 0xff,
    	GitSHA1jMask = 0xff,
    	GitSHA1kMask = 0xff,
    	GitSHA1lMask = 0xff,
    	GitSHA1mMask = 0xff,
    	GitSHA1nMask = 0xff,
    	GitSHA1oMask = 0xff,
    	GitSHA1pMask = 0xff,
    	GitSHA1qMask = 0xff,
    	GitSHA1rMask = 0xff,
    	GitSHA1sMask = 0xff,
    	GitSHA1tMask = 0xff
    };

};

/* Initial testing registers:
 *     0000:   85   //  0x55  magic
    0001:    7   //  0x07  dsp flavor
    0002:   16   //  0x10  year
    0003:    6   //  0x06  month
    0004:   15   //  0x0f  day
    0005:    4   //  0x04  hour
    0006:   32   //  0x20  minute
    0007:    0   //  0x00  code is (clean), () commits after the latest tag
    0008:    0   //  0x00  tool rev ()
    0009:    1   //  0x01  user (larry)
    000a:   17   //  0x11  board type (ac701)
    000b:    0   //  0x00  version number
    000c: 8'h8c  //  0x8c  start of git commit SHA1
    000d: 8'hd5  //  0xd5  ...
    000e: 8'h10  //  0x10  ...
    000f: 8'hda  //  0xda  ...
    0010: 8'h7b  //  0x7b  ...
    0011: 8'hb8  //  0xb8  ...
    0012: 8'ha1  //  0xa1  ...
    0013: 8'hd4  //  0xd4  ...
    0014: 8'h5d  //  0x5d  ...
    0015: 8'h52  //  0x52  ...
    0016: 8'hc1  //  0xc1  ...
    0017: 8'h90  //  0x90  ...
    0018: 8'h6d  //  0x6d  ...
    0019: 8'hb1  //  0xb1  ...
    001a: 8'hd0  //  0xd0  ...
    001b: 8'hd8  //  0xd8  ...
    001c: 8'h7e  //  0x7e  ...
    001d: 8'he7  //  0xe7  ...
    001e: 8'h2a  //  0x2a  ...
    001f: 8'hc7  //  0xc7  end of SHA1
 *
 */

#endif /* scllrfAPP_SRC_scllrfASYNPORTDRIVER_H_ */

/**
 *-----------------------------------------------------------------------------
 * Title      : superconducting low level RF EPICS interface
 * ----------------------------------------------------------------------------
 * File       : scllrfAsynPortDriver.h
 * Author     : Garth Brown, gwbrown@slac.stanford.edu
 * Created    : June 17, 2016
 * Last update: September 6, 2016
 * ----------------------------------------------------------------------------
 * Description:
 * Prototype for FPGA register access to FPGAs using protocol defined in papers
 * given to SLAC by LBNL (Larry Doolittle). Uses asynPortDriver interface. Some of this
 * should eventually be autogenerated from json files or some such, and templates.
 *
 * ----------------------------------------------------------------------------
 * This file is part of LCLS II. It is subject to
 * the license terms in the LICENSE.txt file found in the top-level directory
 * of this distribution and at:
	* https://confluence.slac.stanford.edu/display/ppareg/LICENSE.html.
 * No part of LCLS II, including this file, may be
 * copied, modified, propagated, or distributed except according to the terms
 * contained in the LICENSE.txt file.
 * ----------------------------------------------------------------------------
**/

#ifndef SCLLRFAPP_SRC_SCLLRFASYNPORTDRIVER_H_
#define SCLLRFAPP_SRC_SCLLRFASYNPORTDRIVER_H_

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <stdint.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <iostream>
#include <vector>
//#include <atomic>
#include <string>
#include <sstream>
#include <iomanip>
#include <initializer_list>
#include <unordered_map>
using namespace std;


#include <epicsTypes.h>
#include <epicsThread.h>
#include <epicsEvent.h>
#include <iocsh.h>
#include <epicsMessageQueue.h>

#include <asynPortDriver.h>
#include <asynDriver.h>

#include <epicsExport.h>

// Move these to a common file somewhere

// First byte of data is for control (read/write flag)
// Next 3 bytes are the address
// last 32 bits are data
typedef struct
{
	uint32_t addr;
	int32_t data;
} FpgaReg;

static const unsigned int nonceSize = 1; // nonce is one FpgaReg big

// Functions to convert arrays of registers in place.
/**
 * Convert an array of FpgaReg elements to network byte order in place
 * @param buffer Array of FpgaReg elements to be sent over the network
 * @param regCount the dimension of the buffer, not the number of bytes
 * @see ntohFpgaRegArray
 * @return The test results
 */
void htonFpgaRegArray(FpgaReg *buffer, unsigned int regCount);
/**
 * Convert an array of FpgaReg elements from network byte order in place
 * @param buffer Array of FpgaReg elements received over the network
 * @param regCount the dimension of the buffer, not the number of bytes
 * @see htonFpgaRegArray
 * @return The test results
 */
void ntohFpgaRegArray(FpgaReg *buffer, unsigned int regCount);

// snagged from https://graphics.stanford.edu/~seander/bithacks.html#Interleave64bitOps

// I and Q in the *keep registers alternate bits indicating active I or Q.
// This function removes every other bit, so you can get only I or only Q.
// Pinched from https://stackoverflow.com/questions/4909263/how-to-efficiently-de-interleave-bits-inverse-morton
uint32_t DeInterleaveBits(uint32_t x);
unsigned short InterleaveEnableBits(unsigned char i, unsigned char q);

// Set this bit in the control portion of address to request a reg read
static const uint32_t flagReadMask = 0x10000000;

// Mask for the lower 24 bits of the addr field
static const uint32_t addrMask = 0x00FFFFFF;

// Something easy to spot assigned to uninitialized data
static const int32_t blankData = 0xDEADBEEF;

static const unsigned maxMsgSize = 1450; // Estimated MTU minus fudge factor, in bytes
static const unsigned maxRegPerMsg = maxMsgSize/sizeof(FpgaReg)-1; // Number of register requests minus the nonce
static const unsigned minRegPerMsg = 5; // Limitation of UDP and what the FPGA's limited network stack can cope with

// Communication tuning parameters
static const double readTimeout = 1.0; // seconds
static const double writeTimeout = 5.0; // seconds
static const double defaultPollPeriod = 0.1; // seconds
static const double throttleLoopDelay = 0.0001; // seconds, delay when sending is outstripping reading
static const unsigned int defaultMaxParallelRequests = 1; // throttle requests when this many are outstanding


/* Registers */
typedef struct
{
	// NOTE: unless we merge read/write params, this is inconsistent.
	// Motivation for creating this is restoring write values, so default to write param
	int paramNum; // The parameter number asyn uses
	asynParamType paramType;
	bool isReadable;
	unsigned int readAddr;
	bool isWritable;
	unsigned int writeAddr;
}
regInterface;


// A base class to be used for registers containing arrays.
// This is the interface, defined so that the templated
// DataBuffer<T> classes can be used in a generic way
// by non-templated classes like DataBufferReader
class DataBuffer
{
public:
	const unsigned int RegCount;
	const unsigned int ReqSegmentCount; // # of UDP requests, divide and round up;
	const unsigned int ReqMsgSize; // All register addresses plus nonce space
	const unsigned int iStartAddr;
	std::vector<FpgaReg> reqData; // Canned message to request data buffer
	// When the data is used, e.g. scaled, the various bit width integers
	// in the template types will be used as floating point data. This
	// also allows us to access the data without knowing the type of data
	// in the template.
	// Note that this is read only "const" access, not "reference" access,
	// because the expected implementation is just casting an int, not
	// assigning values to data.
	DataBuffer(unsigned int RegCount, unsigned int iStartAddr);
	virtual ~DataBuffer();

	/** For requesting a waveform, fill canned message request with sequential addresses
	 * \param[in/out] pMsgBuff An array of the right size to contain a request
	 * message for the waveform. The canned message includes the nonce per packet,
	 * so for an n element array, size should be N + N/maxRegPerMsg + 1.
	 * \param[in] buffSize The array length, N + N/maxRegPerMsg + 1 for an N register array
	 * \param[in] iStartAddr Address of the start of the array.
	 */
	void fillWaveRequestMsg();
	virtual epicsFloat32 getDataAt(unsigned int index) const = 0;
	virtual void setDataAt(unsigned int index, epicsInt32 value) = 0;
	virtual void publish(asynPortDriver *driver, int *paramIndex);
};

class DataBuffer8 : public DataBuffer
{
public:
	std::vector<epicsInt8> data;
	virtual epicsFloat32 getDataAt(unsigned int index) const { return (epicsFloat32) data[index]; }
	virtual void setDataAt(unsigned int index, epicsInt32 value) { data[index] = (epicsInt8) value; }
	virtual void publish(asynPortDriver *driver, int *paramIndex);

	DataBuffer8(unsigned int RegCount, unsigned int iStartAddr):
		DataBuffer(RegCount, iStartAddr)
	{
		data.reserve(RegCount);
	}
	virtual ~DataBuffer8(){};
};

class DataBuffer16 : public DataBuffer
{
public:
	std::vector<epicsInt16> data;
	virtual epicsFloat32 getDataAt(unsigned int index) const { return (epicsFloat32) data[index]; }
	virtual void setDataAt(unsigned int index, epicsInt32 value) { data[index] = (epicsInt16) value; }
	virtual void publish(asynPortDriver *driver, int *paramIndex);

	DataBuffer16(unsigned int RegCount, unsigned int iStartAddr):
		DataBuffer(RegCount, iStartAddr)
	{
		data.reserve(RegCount);
	}
	virtual ~DataBuffer16(){};
};

class DataBuffer32 : public DataBuffer
{
public:
	std::vector<epicsInt32> data;
	virtual epicsFloat32 getDataAt(unsigned int index) const { return (epicsFloat32) data[index]; }
	virtual void setDataAt(unsigned int index, epicsInt32 value) { data[index] = (epicsInt32) value; }
	virtual void publish(asynPortDriver *driver, int *paramIndex);

	DataBuffer32(unsigned int RegCount, unsigned int iStartAddr):
		DataBuffer(RegCount, iStartAddr)
	{
		data.reserve(RegCount);
	}
	virtual ~DataBuffer32(){};
};

class scllrfAsynPortDriver: public asynPortDriver
{
public:
	scllrfAsynPortDriver(const char *drvPortName, const char *netPortName, int maxAddr=0, int paramTableSize=7);
	virtual ~scllrfAsynPortDriver();
	virtual asynStatus writeInt32(asynUser *pasynUser, epicsInt32 value);
	virtual asynStatus readInt32(asynUser *pasynUser, epicsInt32 *value);
	virtual asynStatus readInt8Array(asynUser *pasynUser, epicsInt8 *value,
			size_t nElements, size_t *nIn);
	virtual asynStatus readInt16Array(asynUser *pasynUser, epicsInt16 *value,
			size_t nElements, size_t *nIn);
	virtual asynStatus readInt32Array(asynUser *pasynUser, epicsInt32 *value,
			size_t nElements, size_t *nIn);
	virtual asynStatus writeInt8Array(asynUser *pasynUser, epicsInt8 *value,
			size_t nElements);
	virtual asynStatus writeInt16Array(asynUser *pasynUser, epicsInt16 *value,
			size_t nElements);
	virtual asynStatus writeInt32Array(asynUser *pasynUser, epicsInt32 *value,
			size_t nElements);
//	virtual asynStatus readInt32Array(asynUser *pasynUser, epicsInt32 *value,
//			size_t nElements, size_t *nIn);
	virtual asynStatus writeUInt32Digital(asynUser *pasynUser, epicsUInt32 value, epicsUInt32 mask);

	/* Define a polling mechanism.
	 * Sends requests for all register data at a specified period.
	 * A separate thread processes the response.
	 */
	void regPoller(); // Polling loop, exits on shutdown
	void regSettingsInit(); // canned settings from LBL
	virtual asynStatus wakeupPoller(); // Alert poller to request new data
	virtual asynStatus sendRegRequest(FpgaReg *regBuffer,
			unsigned int regBuffSize); // Send out canned request for all registers

	virtual void responseHandler(); // Readback loop, processes data from FPGAs when it arrives
	virtual asynStatus wakeupReader(); // Alert responseHandler to expect new data
	virtual void init();
	void singleMessageQueuer(); // Accumulates individual requests until they can be sent together.

protected:

	// EPICS database driver strings
	static const char *RunStopString; /* asynInt32,    r/w */
	static const char *ReadOneRegString; /* asynInt32 array[2] w */
	static const char *WriteOneRegString; /* asynInt32 array[2] w */
	static const char *MaxParallelRequestsString; /* asynInt32,    r/w */
	static const char *PollPeriodString; /* asynInt32,    r/w */
	static const char *CommErrorCountString;  /* asynInt32,    r */

	std::unordered_map<int, regInterface> paramToReg;
	std::unordered_map<unsigned int, regInterface> addrToReg;


	// Registers relating to the firmware build
	static const char *ConfigRomOctetString;  /* asynOctet,    r */
	static const char *JsonSha1DesString;  /* asynOctet,    r */
	static const char *JsonSha1ActString;  /* asynOctet,    r */
	static const char *GitSha1ARString;
	static const char *GitSha1BRString;
	static const char *GitSha1CRString;
	static const char *GitSha1DRString;
	static const char *GitSha1ERString;
	static const char *GitSha1FRString;
	static const char *GitSha1GRString;
	static const char *GitSha1HRString;
	static const char *GitSha1IRString;
	static const char *GitSha1JRString;
	static const char *GitSha1KRString;
	static const char *GitSha1LRString;
	static const char *GitSha1MRString;
	static const char *GitSha1NRString;
	static const char *GitSha1ORString;
	static const char *GitSha1PRString;
	static const char *GitSha1QRString;
	static const char *GitSha1RRString;
	static const char *GitSha1SRString;
	static const char *GitSha1TRString;
	static const char *GitSHA1String;  /* asynOctet,    r */
	static const char *FwDescString;  /* asynOctet,    r */


	// For readable registers that are polled together at the set polling rate
	FpgaReg *pPolledRegMsg_; // Leave the first array element blank, for use as the nonce
	size_t PolledRegMsgSize_; // number of registers plus one for the nonce
	virtual asynStatus startPoller(const char *netPortName, double pollPeriod); // For system startup

	// Response handler, reads data sent back from FPGA and assigns it to
	// the appropriate variables and pvs.
	virtual asynStatus startResponseHandler(const char *netPortName); // For system startup
	asynStatus processReadbackBuffer(FpgaReg *pFromFpga,
			unsigned int readCount);
	virtual asynStatus processRegWriteResponse(const FpgaReg *pFromFpga);
	virtual asynStatus processRegReadback(const FpgaReg *pFromFpga); // parse register data, write to PVs
	virtual asynStatus functionToRegister(const int function, FpgaReg *pToFpga); /**< Translate asyn function number/reason to a register address */

	virtual asynStatus catGitSHA1(); // Once the individual bytes are all read into registers, concatenate them into a string

	virtual asynStatus startSingleMessageQueuer(const char *netPortName);
	epicsEventId singleMsgQueueEventId_; /**< Event ID to signal the write message queuer */
	epicsMessageQueue _singleMsgQ;

	asynStatus sendBigBuffer(FpgaReg *regBuffer, unsigned int regBuffCount); /**< A message composed by fillWaveRequestMsg can be sent with this function */

	epicsEvent pollEvent_; /**< Event ID to wake up poller */
	double pollPeriod_; /**< The time between polls */
	epicsEventId readEventId_; /**< Event ID to wake up network message response reader */
	double readTimeout_; /**< The time between polls */
	epicsEventId reqWaveEventId_; /**< Event ID to signal the waveform requester */
	bool isShuttingDown_; /**< Flag to indicate threads should exit */
	asynUser* pCommonAsynUser_; /**< asynUser for asynCommonSyncIO */
	asynUser* pOctetAsynUser_; /**< asynUser for asynOctetSyncIO */
	epicsMutexId comCountersMutexId_;
	unsigned int netSendCount_; /**< Number of messages sent to FPGA, sent in nonce for error checking */
	unsigned int lastResponseCount_; /**< Used by response processing to check for missing or out of order responses */
//  std::atomic<uint> netWaitingRequests; // writers increment, reader decrements
	unsigned int netWaitingRequests_; /**< writers increment, reader decrements */
	unsigned int newWaveAvailable_; /**< netSendCount value of the latest response with the "new waveform" flag set */
	unsigned int newWaveRead_; /**< netSendCount for the most recent waveform */
	enum
	{
		stop, run
	};

	static const unsigned int ConfigRomOctetCount = 4096;
	static const unsigned int ConfigRomOctetAdr;
	DataBuffer8 ConfigRomOctetBuf; // The registers are 16 bit, so generated code is 16 bit, but the data is really bytes
	unsigned int cfgRecordType; // Offset from ConfigRomOctetAdr where the record being read ends
	unsigned int cfgRecordEnd; // Offset from ConfigRomOctetAdr where the record being read ends
	/* SHA1 hash of register map */
	static const char *regMapSha1String; // Compiled in to a subclass, from the SHA1 sum of the register map a used to generate the subclass
	std::ostringstream strJsonSha1; // Read back from a live system
	std::ostringstream strGitSHA1; // SHA1 from the git commit used to generate firmware on the live system
	std::ostringstream strFwDesc; // Firmware description string
	unsigned int fwDescSize;

	/** Values used for pasynUser->reason, and indexes into the parameter library.
	 * For this prototype, it's read only values that identify the FPGA. */
	int p_RunStop;
#define FIRST_SCLLRF_PARAM p_RunStop
	int p_ReadOneReg;
	int p_WriteOneReg;
	int p_MaxParallelRequests;
	int p_PollPeriod;
	int p_CommErrorCount;

	// Registers relating to the firmware build
	int p_ConfigRomOctet;
	int p_JsonSha1Des;
	int p_JsonSha1Act;
	int p_GitSha1AR;
	int p_GitSha1BR;
	int p_GitSha1CR;
	int p_GitSha1DR;
	int p_GitSha1ER;
	int p_GitSha1FR;
	int p_GitSha1GR;
	int p_GitSha1HR;
	int p_GitSha1IR;
	int p_GitSha1JR;
	int p_GitSha1KR;
	int p_GitSha1LR;
	int p_GitSha1MR;
	int p_GitSha1NR;
	int p_GitSha1OR;
	int p_GitSha1PR;
	int p_GitSha1QR;
	int p_GitSha1RR;
	int p_GitSha1SR;
	int p_GitSha1TR;
	int p_GitSHA1;
	int p_FwDesc;
/* Registers */
	#define LAST_SCLLRF_PARAM p_FwDesc

	epicsUInt32 uReadOneRegAddr, uWriteOneRegAddr;

	//Note: the number of parameters must be manually set in the iocsh binding,
	// the addresses of the parameters used in the #define are out of scope there.
#define NUM_SCLLRF_PARAMS (&LAST_SCLLRF_PARAM - &FIRST_SCLLRF_PARAM + 1)

	// mapping of register names to addresses
	enum ReadRegAddrs
	{
		JsonSha1RAdr = 0x00000801,
//		DspFlavorRAdr = 0x00000801,
//		BuildYearRAdr = 0x00000802,
//		BuildMonthRAdr = 0x00000803,
//		BuildDayRAdr = 0x00000804,
//		BuildHourRAdr = 0x00000805,
//		BuildMinuteRAdr = 0x00000806,
//		CodeIsCleanRAdr = 0x00000807,
//		ToolRevRAdr = 0x00000808,
//		UserRAdr = 0x00000809,
//		BoardTypeRAdr = 0x0000080A,
//		VersionRAdr = 0x0000080B,
		GitSha1ARAdr = 0x0000080C,
		GitSha1BRAdr = 0x0000080D,
		GitSha1CRAdr = 0x0000080E,
		GitSha1DRAdr = 0x0000080F,
		GitSha1ERAdr = 0x00000810,
		GitSha1FRAdr = 0x00000811,
		GitSha1GRAdr = 0x00000812,
		GitSha1HRAdr = 0x00000813,
		GitSha1IRAdr = 0x00000814,
		GitSha1JRAdr = 0x00000815,
		FwDescLengthRAdr = 0x00000816,
		FwDescRAdr = 0x00000817
	};

	// masks applied to returned register data
	enum RegMasks
	{
		JsonSha1Mask =  0x0000FFFF,
		GitSha1AMask =  0x0000FFFF,
		GitSha1BMask =  0x0000FFFF,
		GitSha1CMask =  0x0000FFFF,
		GitSha1DMask =  0x0000FFFF,
		GitSha1EMask =  0x0000FFFF,
		GitSha1FMask =  0x0000FFFF,
		GitSha1GMask =  0x0000FFFF,
		GitSha1HMask =  0x0000FFFF,
		GitSha1IMask =  0x0000FFFF,
		GitSha1JMask =  0x0000FFFF,
		GitSha1KMask =  0x0000FFFF,
		GitSha1LMask =  0x0000FFFF,
		GitSha1MMask =  0x0000FFFF,
		GitSha1NMask =  0x0000FFFF,
		GitSha1OMask =  0x0000FFFF,
		GitSha1PMask =  0x0000FFFF,
		GitSha1QMask =  0x0000FFFF,
		GitSha1RMask =  0x0000FFFF,
		GitSha1SMask =  0x0000FFFF,
		GitSha1TMask =  0x0000FFFF,
		DescLengthMask = 0xC000
	};
};



//template <class T>
//class TypedDataBuffer : public DataBuffer
//{
//public:
//	std::vector<T> data;
//	virtual epicsFloat32 getDataAt(unsigned int index) const { return (epicsFloat32) data[index]; }
//	virtual void setDataAt(unsigned int index, epicsInt32 value) { data[index] = (T) value; }
//	//virtual void publish(scllrfAsynPortDriver *driver, int *paramIndex);
//
//	TypedDataBuffer(unsigned int RegCount, unsigned int iStartAddr):
//		DataBuffer(RegCount, iStartAddr)
//	{
//		data.reserve(RegCount);
//	}
//	virtual ~TypedDataBuffer(){};
//};

//template <>
//void TypedDataBuffer<epicsInt16>::publish(scllrfAsynPortDriver *driver, int *paramIndex)
//{
//	//driver->doCallbacksInt16Array(data.data(), RegCount, *paramIndex, 0);
//	RegCount = 5;////XXXX
//}

//template<>
//void TypedDataBuffer<epicsInt32>::publish(scllrfAsynPortDriver *driver, int *paramIndex)
//		{ driver->doCallbacksInt32Array(data.data(), RegCount, *paramIndex, 0); }

//class DataBufferReader
//{
//public:
//	DataBufferReader(DataBuffer myBuffer,
//			unsigned int resetAddr, unsigned int resetMask,
//			unsigned int statusAddr, unsigned int statusMask);
//protected:
//	DataBuffer myBuffer;
//	unsigned int resetAddr;
//	unsigned int resetMask;
//	unsigned int statusAddr;
//	unsigned int statusMask;
//
//};

#endif /* SCLLRFAPP_SRC_SCLLRFASYNPORTDRIVER_H_ */

/**
 *-----------------------------------------------------------------------------
 * Title      : superconducting low level RF EPICS interface
 * ----------------------------------------------------------------------------
 * File       : templateScllrfDriver.h
 * Author     : Garth Brown, gwbrown@slac.stanford.edu
 * Created    : June 17, 2016
 * Last update: September 6, 2016
 * ----------------------------------------------------------------------------
 * Description:
 * Header defining register interface to scllrfRESwav, autogenerated from a python
 * dictionary.
 *
 * ----------------------------------------------------------------------------
 * This file is part of LCLS II. It is subject to
 * the license terms in the LICENSE.txt file found in the top-level directory
 * of this distribution and at:
    * https://confluence.slac.stanford.edu/display/ppareg/LICENSE.html.
 * No part of LCLS II, including this file, may be
 * copied, modified, propagated, or distributed except according to the terms
 * contained in the LICENSE.txt file.
 * ----------------------------------------------------------------------------
**/

#include "scllrfRESwav.h"
#include <asynOctetSyncIO.h>
#include <asynCommonSyncIO.h>
#include <limits>
#include <netinet/in.h>
#include <iostream>
using namespace std;
#include <math.h>

/** Constructor for the scllrfRESwav class.
 * Calls constructor for the asynPortDriver base class.
 * \param[in] portName The name of the asyn port driver to be created.
 * \param[in] path The path to the peripherial as built by the builder api
 * \param[in] nelms The number of elements of this device (max addr)
 * \paarm[in] nEntries The number of asyn params to be created for each device
 *
 * */
scllrfRESwavDriver::scllrfRESwavDriver(const char *drvPortName, const char *netPortName)
: scllrfAsynPortDriver(drvPortName, netPortName,
		1, /* maxAddr, i.e. number of channels */
		NUM_SCLLRFRESWAV_PARAMS)
{
	asynStatus status = asynSuccess;

    epicsThreadSleep(defaultPollPeriod);

    createParam(Piezo1C1InRString, asynParamInt32, &p_Piezo1C1InR);
    createParam(Piezo1C1IpRString, asynParamInt32, &p_Piezo1C1IpR);
    createParam(Piezo1C1DriveVRString, asynParamInt32, &p_Piezo1C1DriveVR);
    createParam(Piezo1C1OutVRString, asynParamInt32, &p_Piezo1C1OutVR);
    createParam(Piezo1C2InRString, asynParamInt32, &p_Piezo1C2InR);
    createParam(Piezo1C2IpRString, asynParamInt32, &p_Piezo1C2IpR);
    createParam(Piezo1C2DriveVRString, asynParamInt32, &p_Piezo1C2DriveVR);
    createParam(Piezo1C2OutVRString, asynParamInt32, &p_Piezo1C2OutVR);
    createParam(Piezo2C1InRString, asynParamInt32, &p_Piezo2C1InR);
    createParam(Piezo2C1IpRString, asynParamInt32, &p_Piezo2C1IpR);
    createParam(Piezo2C1DriveVRString, asynParamInt32, &p_Piezo2C1DriveVR);
    createParam(Piezo2C1OutVRString, asynParamInt32, &p_Piezo2C1OutVR);
    createParam(Piezo2C2InRString, asynParamInt32, &p_Piezo2C2InR);
    createParam(Piezo2C2IpRString, asynParamInt32, &p_Piezo2C2IpR);
    createParam(Piezo2C2DriveVRString, asynParamInt32, &p_Piezo2C2DriveVR);
    createParam(Piezo2C2OutVRString, asynParamInt32, &p_Piezo2C2OutVR);
    createParam(Piezo3C1InRString, asynParamInt32, &p_Piezo3C1InR);
    createParam(Piezo3C1IpRString, asynParamInt32, &p_Piezo3C1IpR);
    createParam(Piezo3C1DriveVRString, asynParamInt32, &p_Piezo3C1DriveVR);
    createParam(Piezo3C1OutVRString, asynParamInt32, &p_Piezo3C1OutVR);
    createParam(Piezo3C2InRString, asynParamInt32, &p_Piezo3C2InR);
    createParam(Piezo3C2IpRString, asynParamInt32, &p_Piezo3C2IpR);
    createParam(Piezo3C2DriveVRString, asynParamInt32, &p_Piezo3C2DriveVR);
    createParam(Piezo3C2OutVRString, asynParamInt32, &p_Piezo3C2OutVR);
    createParam(Piezo4C1InRString, asynParamInt32, &p_Piezo4C1InR);
    createParam(Piezo4C1IpRString, asynParamInt32, &p_Piezo4C1IpR);
    createParam(Piezo4C1DriveVRString, asynParamInt32, &p_Piezo4C1DriveVR);
    createParam(Piezo4C1OutVRString, asynParamInt32, &p_Piezo4C1OutVR);
    createParam(Piezo4C2InRString, asynParamInt32, &p_Piezo4C2InR);
    createParam(Piezo4C2IpRString, asynParamInt32, &p_Piezo4C2IpR);
    createParam(Piezo4C2DriveVRString, asynParamInt32, &p_Piezo4C2DriveVR);
    createParam(Piezo4C2OutVRString, asynParamInt32, &p_Piezo4C2OutVR);
    createParam(PztWaveAvailRString, asynParamInt32, &p_PztWaveAvailR);
	createParam(PztWaveAvailBit1RString, asynParamUInt32Digital, &p_PztWaveAvailBit1R);
	createParam(PztWaveAvailBit2RString, asynParamUInt32Digital, &p_PztWaveAvailBit2R);
    createParam(ReservedRString, asynParamInt32, &p_ReservedR);
    createParam(ReservedWString, asynParamInt32, &p_ReservedW);
    createParam(ReservedRString, asynParamInt32, &p_ReservedR);
    createParam(ReservedWString, asynParamInt32, &p_ReservedW);
    createParam(ReservedRString, asynParamInt32, &p_ReservedR);
    createParam(ReservedWString, asynParamInt32, &p_ReservedW);
    createParam(ReservedRString, asynParamInt32, &p_ReservedR);
    createParam(ReservedWString, asynParamInt32, &p_ReservedW);

    // Message size is the number of read registers, plus 1 nonce for every 175 read registers
    PolledRegMsgSize_ = readRegCount + (readRegCount / 175) + 1;
	// A canned request to read all registers
    pPolledRegMsg_ = new FpgaReg[PolledRegMsgSize_]
	{
		{ 0, 0 },
		{ flagReadMask | ReservedRAdr, blankData },
		{ flagReadMask | ReservedRAdr, blankData },
		{ flagReadMask | ReservedRAdr, blankData },
		{ flagReadMask | ReservedRAdr, blankData },
		{ flagReadMask | PztWaveAvailRAdr, blankData },
		{ flagReadMask | Piezo1C1InRAdr, blankData },
		{ flagReadMask | Piezo1C1IpRAdr, blankData },
		{ flagReadMask | Piezo1C1OutVRAdr, blankData },
		{ flagReadMask | Piezo1C1DriveVRAdr, blankData },
		{ flagReadMask | Piezo1C2InRAdr, blankData },
		{ flagReadMask | Piezo1C2IpRAdr, blankData },
		{ flagReadMask | Piezo1C2OutVRAdr, blankData },
		{ flagReadMask | Piezo1C2DriveVRAdr, blankData },
		{ flagReadMask | Piezo2C1InRAdr, blankData },
		{ flagReadMask | Piezo2C1IpRAdr, blankData },
		{ flagReadMask | Piezo2C1OutVRAdr, blankData },
		{ flagReadMask | Piezo2C1DriveVRAdr, blankData },
		{ flagReadMask | Piezo2C2InRAdr, blankData },
		{ flagReadMask | Piezo2C2IpRAdr, blankData },
		{ flagReadMask | Piezo2C2OutVRAdr, blankData },
		{ flagReadMask | Piezo2C2DriveVRAdr, blankData },
		{ flagReadMask | Piezo3C1InRAdr, blankData },
		{ flagReadMask | Piezo3C1IpRAdr, blankData },
		{ flagReadMask | Piezo3C1OutVRAdr, blankData },
		{ flagReadMask | Piezo3C1DriveVRAdr, blankData },
		{ flagReadMask | Piezo3C2InRAdr, blankData },
		{ flagReadMask | Piezo3C2IpRAdr, blankData },
		{ flagReadMask | Piezo3C2OutVRAdr, blankData },
		{ flagReadMask | Piezo3C2DriveVRAdr, blankData },
		{ flagReadMask | Piezo4C1InRAdr, blankData },
		{ flagReadMask | Piezo4C1IpRAdr, blankData },
		{ flagReadMask | Piezo4C1OutVRAdr, blankData },
		{ flagReadMask | Piezo4C1DriveVRAdr, blankData },
		{ flagReadMask | Piezo4C2InRAdr, blankData },
		{ flagReadMask | Piezo4C2IpRAdr, blankData },
		{ flagReadMask | Piezo4C2OutVRAdr, blankData },
		{ flagReadMask | Piezo4C2DriveVRAdr, blankData },
	};

	htonFpgaRegArray(pPolledRegMsg_, PolledRegMsgSize_);

    epicsThreadSleep(defaultPollPeriod);
    printf("%s created %ld parameters.\n",__PRETTY_FUNCTION__,NUM_SCLLRFRESWAV_PARAMS);

    wakeupPoller();
    wakeupReader();
}

scllrfRESwavDriver::~scllrfRESwavDriver()
{
	isShuttingDown_ = true;
	epicsThreadSleep(0.1); // Allow threads to run and exit
	wakeupPoller();
	wakeupReader();
	epicsThreadSleep(0.1); // Allow threads to run and exit
	wakeupPoller(); // call this twice in case the poller was never set to run
	wakeupReader();
	epicsThreadSleep(0.1); // Allow threads to run and exit
	wakeupReader();
	pasynOctetSyncIO->disconnect(pOctetAsynUser_);
	pasynCommonSyncIO->disconnectDevice(pCommonAsynUser_);
	pasynCommonSyncIO->disconnect(pCommonAsynUser_);
}

/** Called when you have the asyn parameter name and want the corresponding
 * register address.
  * \param[in] function From pAsynUser->reason, corresponding to a registered parameter.
  * \param[in] pToFpga Pointer to the {Address, Data} structure where the register address will be written
  * \param[in] nElements Number of elements to read. */
asynStatus scllrfRESwavDriver::functionToRegister(const int function, FpgaReg *pToFpga)
{
	asynStatus status = asynSuccess;

    if( function == p_Piezo1C1InR )
    {
		pToFpga->addr = Piezo1C1InRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo1C1IpR )
    {
		pToFpga->addr = Piezo1C1IpRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo1C1DriveVR )
    {
		pToFpga->addr = Piezo1C1DriveVRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo1C1OutVR )
    {
		pToFpga->addr = Piezo1C1OutVRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo1C2InR )
    {
		pToFpga->addr = Piezo1C2InRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo1C2IpR )
    {
		pToFpga->addr = Piezo1C2IpRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo1C2DriveVR )
    {
		pToFpga->addr = Piezo1C2DriveVRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo1C2OutVR )
    {
		pToFpga->addr = Piezo1C2OutVRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo2C1InR )
    {
		pToFpga->addr = Piezo2C1InRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo2C1IpR )
    {
		pToFpga->addr = Piezo2C1IpRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo2C1DriveVR )
    {
		pToFpga->addr = Piezo2C1DriveVRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo2C1OutVR )
    {
		pToFpga->addr = Piezo2C1OutVRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo2C2InR )
    {
		pToFpga->addr = Piezo2C2InRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo2C2IpR )
    {
		pToFpga->addr = Piezo2C2IpRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo2C2DriveVR )
    {
		pToFpga->addr = Piezo2C2DriveVRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo2C2OutVR )
    {
		pToFpga->addr = Piezo2C2OutVRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo3C1InR )
    {
		pToFpga->addr = Piezo3C1InRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo3C1IpR )
    {
		pToFpga->addr = Piezo3C1IpRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo3C1DriveVR )
    {
		pToFpga->addr = Piezo3C1DriveVRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo3C1OutVR )
    {
		pToFpga->addr = Piezo3C1OutVRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo3C2InR )
    {
		pToFpga->addr = Piezo3C2InRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo3C2IpR )
    {
		pToFpga->addr = Piezo3C2IpRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo3C2DriveVR )
    {
		pToFpga->addr = Piezo3C2DriveVRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo3C2OutVR )
    {
		pToFpga->addr = Piezo3C2OutVRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo4C1InR )
    {
		pToFpga->addr = Piezo4C1InRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo4C1IpR )
    {
		pToFpga->addr = Piezo4C1IpRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo4C1DriveVR )
    {
		pToFpga->addr = Piezo4C1DriveVRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo4C1OutVR )
    {
		pToFpga->addr = Piezo4C1OutVRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo4C2InR )
    {
		pToFpga->addr = Piezo4C2InRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo4C2IpR )
    {
		pToFpga->addr = Piezo4C2IpRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo4C2DriveVR )
    {
		pToFpga->addr = Piezo4C2DriveVRAdr|flagReadMask;
    }
    else
    if( function == p_Piezo4C2OutVR )
    {
		pToFpga->addr = Piezo4C2OutVRAdr|flagReadMask;
    }
    else
    if( function == p_PztWaveAvailR )
    {
		pToFpga->addr = PztWaveAvailRAdr|flagReadMask;
    }
    else
    if( function == p_ReservedR )
    {
		pToFpga->addr = ReservedRAdr|flagReadMask;
    }
    else
    if( function == p_ReservedW )
    {
		pToFpga->addr = ReservedWAdr;
    }
    else
    if( function == p_ReservedR )
    {
		pToFpga->addr = ReservedRAdr|flagReadMask;
    }
    else
    if( function == p_ReservedW )
    {
		pToFpga->addr = ReservedWAdr;
    }
    else
    if( function == p_ReservedR )
    {
		pToFpga->addr = ReservedRAdr|flagReadMask;
    }
    else
    if( function == p_ReservedW )
    {
		pToFpga->addr = ReservedWAdr;
    }
    else
    if( function == p_ReservedR )
    {
		pToFpga->addr = ReservedRAdr|flagReadMask;
    }
    else
    if( function == p_ReservedW )
    {
		pToFpga->addr = ReservedWAdr;
    }
    else
    	status = asynError;

    return status;
}

/**  Extract register address and data from the received message and set the appropriate
 * asyn parameter.
 * Some registers have a "new waveform data ready" flag. If they have this and it is set,
 * set weveIsReady to true.
 * Note: This function should not set waveIsReady to false. That is done by a loop in the
 * calling function.
* \param[in] pFromFpga Data returned from the FPGA for a single register
* \param[in] waveIsReady A flag that gets set to true if the appropriate bit was set by the FPGA
*/
asynStatus scllrfRESwavDriver::processRegReadback(const FpgaReg *pFromFpga, bool &waveIsReady)
{
	unsigned int i;
	asynStatus status = asynSuccess;
	assert(pFromFpga->addr&flagReadMask); // This function is only for read registers
	epicsInt32 errorCount;
	int32_t signExtBits = 0;

	/* Map address to parameter, set the parameter in the parameter library. */
	switch (pFromFpga->addr)
    {
	break;

    case ReservedRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_ReservedR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				ReservedRString, (unsigned ) pFromFpga->data);
	break;

    case ReservedRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_ReservedR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				ReservedRString, (unsigned ) pFromFpga->data);
	break;

    case ReservedRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_ReservedR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				ReservedRString, (unsigned ) pFromFpga->data);
	break;

    case ReservedRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_ReservedR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				ReservedRString, (unsigned ) pFromFpga->data);
	break;

    case PztWaveAvailRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_PztWaveAvailR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				PztWaveAvailRString, (unsigned ) pFromFpga->data);

		status = (asynStatus) setUIntDigitalParam(p_PztWaveAvailBit1R,
				pFromFpga->data, PztWaveAvailBit1Mask);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				PztWaveAvailBit1RString,
				(unsigned ) pFromFpga->data & PztWaveAvailBit1Mask);

		status = (asynStatus) setUIntDigitalParam(p_PztWaveAvailBit2R,
				pFromFpga->data, PztWaveAvailBit2Mask);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				PztWaveAvailBit2RString,
				(unsigned ) pFromFpga->data & PztWaveAvailBit2Mask);
	break;

    case Piezo1C1InRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo1C1InR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1C1InRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo1C1IpRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo1C1IpR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1C1IpRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo1C1OutVRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo1C1OutVR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1C1OutVRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo1C1DriveVRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo1C1DriveVR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1C1DriveVRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo1C2InRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo1C2InR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1C2InRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo1C2IpRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo1C2IpR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1C2IpRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo1C2OutVRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo1C2OutVR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1C2OutVRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo1C2DriveVRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo1C2DriveVR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1C2DriveVRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo2C1InRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo2C1InR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2C1InRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo2C1IpRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo2C1IpR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2C1IpRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo2C1OutVRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo2C1OutVR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2C1OutVRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo2C1DriveVRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo2C1DriveVR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2C1DriveVRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo2C2InRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo2C2InR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2C2InRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo2C2IpRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo2C2IpR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2C2IpRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo2C2OutVRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo2C2OutVR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2C2OutVRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo2C2DriveVRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo2C2DriveVR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2C2DriveVRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo3C1InRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo3C1InR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3C1InRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo3C1IpRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo3C1IpR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3C1IpRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo3C1OutVRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo3C1OutVR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3C1OutVRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo3C1DriveVRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo3C1DriveVR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3C1DriveVRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo3C2InRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo3C2InR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3C2InRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo3C2IpRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo3C2IpR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3C2IpRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo3C2OutVRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo3C2OutVR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3C2OutVRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo3C2DriveVRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo3C2DriveVR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3C2DriveVRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo4C1InRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo4C1InR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4C1InRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo4C1IpRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo4C1IpR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4C1IpRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo4C1OutVRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo4C1OutVR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4C1OutVRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo4C1DriveVRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo4C1DriveVR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4C1DriveVRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo4C2InRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo4C2InR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4C2InRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo4C2IpRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo4C2IpR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4C2IpRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo4C2OutVRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo4C2OutVR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4C2OutVRString, (unsigned ) pFromFpga->data);
	break;

    case Piezo4C2DriveVRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_Piezo4C2DriveVR,
				pFromFpga->data);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4C2DriveVRString, (unsigned ) pFromFpga->data);
		break;

	default:
		getIntegerParam(p_CommErrorCount, &errorCount);
		setIntegerParam(p_CommErrorCount, ++errorCount);

		status = asynError;
		break;
    }

    return status;
}


/**  Extract register address and data from the received message and set the appropriate
 * asyn parameter.
 * Some registers have a "new waveform data ready" flag. If they have this and it is set,
 * set weveIsReady to true.
 * Note: This function should not set waveIsReady to false. That is done by a loop in the
 * calling function.
* \param[in] pFromFpga Data returned from the FPGA for a single register
* \param[in] waveIsReady A flag that gets set to true if the appropriate bit was set by the FPGA
*/
asynStatus scllrfRESwavDriver::processRegWriteResponse(const FpgaReg *pFromFpga)
{
	asynStatus status = asynSuccess;
	epicsInt32 valueSet[maxMsgSize/sizeof(FpgaReg)]; // Put the value sent to the FPGA here for comparison
	epicsInt32 errorCount;
//  variables that may be useful for checking array data
//	asynUser *pAsynArrayUser;
//	unsigned int i;

	/* Map address to parameter, set the parameter in the parameter library. */
	switch (pFromFpga->addr)
    {
    case ReservedWAdr:
		status = (asynStatus) getIntegerParam(p_ReservedW, valueSet);
		if( (valueSet[0] ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				ReservedWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				ReservedWString, valueSet[0] , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_ReservedW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case ReservedWAdr:
		status = (asynStatus) getIntegerParam(p_ReservedW, valueSet);
		if( (valueSet[0] ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				ReservedWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				ReservedWString, valueSet[0] , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_ReservedW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case ReservedWAdr:
		status = (asynStatus) getIntegerParam(p_ReservedW, valueSet);
		if( (valueSet[0] ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				ReservedWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				ReservedWString, valueSet[0] , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_ReservedW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case ReservedWAdr:
		status = (asynStatus) getIntegerParam(p_ReservedW, valueSet);
		if( (valueSet[0] ) == (pFromFpga->data ))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				ReservedWString, (unsigned ) pFromFpga->data );
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				ReservedWString, valueSet[0] , (unsigned ) pFromFpga->data );
			status = asynError;
			setParamStatus(p_ReservedW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
	default:
		getIntegerParam(p_CommErrorCount, &errorCount);
		setIntegerParam(p_CommErrorCount, ++errorCount);

		status = asynError;
		break;
    }

	// TODO: handle arrays

    return status;
}



extern "C" {

/* Configuration routine.  Called directly, or from the iocsh function below */

/** EPICS iocsh callable function to call constructor for the scllrfRESwav class.
 * \param[in] portName The name of the asyn port driver to be created.
 * \param[in] netPortName The name of the asynIPport this will use to communicate */
int scllrfRESwavConfigure(const char *drvPortName, const char *netPortName)
{
	new scllrfRESwavDriver(drvPortName, netPortName);
	return asynSuccess;
}


/* EPICS iocsh shell commands */

static const iocshArg initArg0 = { "drvPortName",iocshArgString};
static const iocshArg initArg1 = { "IP port name",iocshArgString};
static const iocshArg * const initArgs[] = {&initArg0,
		&initArg1};
static const iocshFuncDef initFuncDef = {"scllrfRESwavConfigure",2,initArgs};
static void initCallFunc(const iocshArgBuf *args)
{
	scllrfRESwavConfigure(args[0].sval, args[1].sval);
}

void scllrfRESwavRegister(void)
{
	iocshRegister(&initFuncDef,initCallFunc);
}

epicsExportRegistrar(scllrfRESwavRegister);

}




/**
 *-----------------------------------------------------------------------------
 * Title      : superconducting low level RF EPICS interface
 * ----------------------------------------------------------------------------
 * File       : scllrfRESDriver.h
 * Author     : Garth Brown, gwbrown@slac.stanford.edu
 * Created    : June 17, 2016
 * Last update: September 6, 2016
 * ----------------------------------------------------------------------------
 * Description:
 * Header defining register interface to scllrfRES, autogenerated from a python
 * dictionary.
 *
 * ----------------------------------------------------------------------------
 * This file is part of LCLS II. It is subject to
 * the license terms in the LICENSE.txt file found in the top-level directory
 * of this distribution and at:
    * https://confluence.slac.stanford.edu/display/ppareg/LICENSE.html.
 * No part of LCLS II, including this file, may be
 * copied, modified, propagated, or distributed except according to the terms
 * contained in the LICENSE.txt file.
 * ----------------------------------------------------------------------------
**/

#include "scllrfRESextra.h"
#include <asynOctetSyncIO.h>
#include <asynCommonSyncIO.h>
#include <limits>
#include <netinet/in.h>
#include <iostream>
using namespace std;
#include <math.h>

//const unsigned PiezoWave::piezoWaveRegCount = 1024;
//const unsigned PiezoWave::piezoWaveSegmentCount = (piezoWaveRegCount
//		+ maxRegPerMsg - 1) / maxRegPerMsg; // # of UDP requests, divide and round up
//const unsigned PiezoWave::piezoWaveReqMsgSize = piezoWaveRegCount
//		+ piezoWaveSegmentCount; // All register addresses plus nonce space

PiezoWave::PiezoWave(unsigned int addr, int index, epicsInt32 readBuffer[])
:waveReadback(readBuffer), paramIndex(index), readCount(0), readInProgress(false), keep(false)
{
	std::fill( requestMsg, requestMsg + piezoWaveReqMsgSize,
			(FpgaReg) {flagReadMask|addr,blankData} );
	htonFpgaRegArray(requestMsg, piezoWaveReqMsgSize);
}

const char *scllrfRESextra::PiezoWaveKeepString = "PIEZO_WAVE_KEEP";
const unsigned int scllrfRESextra::maxChannel = 1; // No multi-channel PVs here
/** Constructor for the scllrfRESextra class.
 * Calls constructor for the asynPortDriver derived base class.
 * \param[in] drvPortName The name of the asyn port driver to be created.
 * \param[in] netPortName The name of the asyn port driver to use for the network connection
 * \param[in] maxAddr The number of channels for the paramater with the most channels
 * \paarm[in] paramTableSize The number of asyn params to be created for each device
 *
 * */

scllrfRESextra::scllrfRESextra(const char *drvPortName, const char *netPortName)
: scllrfRESDriver(drvPortName, netPortName, maxChannel, NUM_SCLLRFRESEXTRA_PARAMS),
		Piezo1C1InWave_(Piezo1C1InRAdr, p_Piezo1C1InR, bufPiezo1C1In),
		Piezo1C1IpWave_(Piezo1C1IpRAdr, p_Piezo1C1IpR, bufPiezo1C1Ip),
		Piezo1C1DriveVWave_(Piezo1C1DriveVRAdr, p_Piezo1C1DriveVR, bufPiezo1C1DriveV),
		Piezo1C1OutVWave_(Piezo1C1OutVRAdr, p_Piezo1C1OutVR, bufPiezo1C1OutV),
		Piezo1C2InWave_(Piezo1C2InRAdr, p_Piezo1C2InR, bufPiezo1C2In),
		Piezo1C2IpWave_(Piezo1C2IpRAdr, p_Piezo1C2IpR, bufPiezo1C2Ip),
		Piezo1C2DriveVWave_(Piezo1C2DriveVRAdr, p_Piezo1C2DriveVR, bufPiezo1C2DriveV),
		Piezo1C2OutVWave_(Piezo1C2OutVRAdr, p_Piezo1C2OutVR, bufPiezo1C2OutV),
		Piezo2C1InWave_(Piezo2C1InRAdr, p_Piezo2C1InR, bufPiezo2C1In),
		Piezo2C1IpWave_(Piezo2C1IpRAdr, p_Piezo2C1IpR, bufPiezo2C1Ip),
		Piezo2C1DriveVWave_(Piezo2C1DriveVRAdr, p_Piezo2C1DriveVR, bufPiezo2C1DriveV),
		Piezo2C1OutVWave_(Piezo2C1OutVRAdr, p_Piezo2C1OutVR, bufPiezo2C1OutV),
		Piezo2C2InWave_(Piezo2C2InRAdr, p_Piezo2C2InR, bufPiezo2C2In),
		Piezo2C2IpWave_(Piezo2C2IpRAdr, p_Piezo2C2IpR, bufPiezo2C2Ip),
		Piezo2C2DriveVWave_(Piezo2C2DriveVRAdr, p_Piezo2C2DriveVR, bufPiezo2C2DriveV),
		Piezo2C2OutVWave_(Piezo2C2OutVRAdr, p_Piezo2C2OutVR, bufPiezo2C2OutV),
		Piezo3C1InWave_(Piezo3C1InRAdr, p_Piezo3C1InR, bufPiezo3C1In),
		Piezo3C1IpWave_(Piezo3C1IpRAdr, p_Piezo3C1IpR, bufPiezo3C1Ip),
		Piezo3C1DriveVWave_(Piezo3C1DriveVRAdr, p_Piezo3C1DriveVR, bufPiezo3C1DriveV),
		Piezo3C1OutVWave_(Piezo3C1OutVRAdr, p_Piezo3C1OutVR, bufPiezo3C1OutV),
		Piezo3C2InWave_(Piezo3C2InRAdr, p_Piezo3C2InR, bufPiezo3C2In),
		Piezo3C2IpWave_(Piezo3C2IpRAdr, p_Piezo3C2IpR, bufPiezo3C2Ip),
		Piezo3C2DriveVWave_(Piezo3C2DriveVRAdr, p_Piezo3C2DriveVR, bufPiezo3C2DriveV),
		Piezo3C2OutVWave_(Piezo3C2OutVRAdr, p_Piezo3C2OutVR, bufPiezo3C2OutV),
		Piezo4C1InWave_(Piezo4C1InRAdr, p_Piezo4C1InR, bufPiezo4C1In),
		Piezo4C1IpWave_(Piezo4C1IpRAdr, p_Piezo4C1IpR, bufPiezo4C1Ip),
		Piezo4C1DriveVWave_(Piezo4C1DriveVRAdr, p_Piezo4C1DriveVR, bufPiezo4C1DriveV),
		Piezo4C1OutVWave_(Piezo4C1OutVRAdr, p_Piezo4C1OutVR, bufPiezo4C1OutV),
		Piezo4C2InWave_(Piezo4C2InRAdr, p_Piezo4C2InR, bufPiezo4C2In),
		Piezo4C2IpWave_(Piezo4C2IpRAdr, p_Piezo4C2IpR, bufPiezo4C2Ip),
		Piezo4C2DriveVWave_(Piezo4C2DriveVRAdr, p_Piezo4C2DriveVR, bufPiezo4C2DriveV),
		Piezo4C2OutVWave_(Piezo4C2OutVRAdr, p_Piezo4C2OutVR, bufPiezo4C2OutV)
{
	// Note on the parameter type for piezoWaveKeep: the only unsigned EPICS record types
	// are limited to 16 bits. The 32 bit signed have problems converting to/from unsigned
	// when the calcout record used to combine two 16 bit mbboDirect records into one 32 bit
	// number gives a result over the positive range of a signed int. Ugly though it is,
	// converting a floating point value to/from a 32 bit mask works. Tested working.
    createParam(PiezoWaveKeepString, asynParamFloat64, &p_PiezoWaveKeep);

    epicsThreadSleep(defaultPollPeriod);
    std::cout << __PRETTY_FUNCTION__ << " created " << NUM_SCLLRFRESEXTRA_PARAMS << " parameters." << std::endl;
    startPiezoBufRequester();
}

scllrfRESextra::~scllrfRESextra()
{
	isShuttingDown_ = true;
	epicsThreadSleep(0.1); // Allow threads to run and exit
	wakeupPoller();
	wakeupReader();
	epicsThreadSleep(0.1); // Allow threads to run and exit
	wakeupPoller(); // call this twice in case the poller was never set to run
	wakeupReader();
	epicsThreadSleep(0.1); // Allow threads to run and exit
	wakeupReader();
	pasynOctetSyncIO->disconnect(pOctetAsynUser_);
	pasynCommonSyncIO->disconnectDevice(pCommonAsynUser_);
	pasynCommonSyncIO->disconnect(pCommonAsynUser_);
}

static void piezoBufRequesterC(void *drvPvt)
{
	//printf("%s: starting\n", __PRETTY_FUNCTION__);
	scllrfRESextra *pscllrfDriver = (scllrfRESextra*)drvPvt;
	pscllrfDriver->piezoBufRequester();
	//printf("%s: exiting\n", __PRETTY_FUNCTION__);
}

/** Starts the poller thread.
 ** Derived classes will typically call this at near the end of their constructor.
 ** Derived classes can typically use the base class implementation of the poller thread,
 ** but are free to re-implement it if necessary.
 ** \param[in] pollPeriod The time between polls. */
asynStatus scllrfRESextra::startPiezoBufRequester()
{
	epicsThreadCreate("piezoWaveformRequester",
			epicsThreadPriorityMedium,
			epicsThreadGetStackSize(epicsThreadStackMedium),
			(EPICSTHREADFUNC)piezoBufRequesterC, (void *)this);
	return asynSuccess;
}

void scllrfRESextra::piezoBufRequester()
{
	epicsUInt32 activeChannels;
	double activeChannelsSigned;
	epicsUInt32 channelsWithData;
	uint32_t thisChannel;
	epicsUInt32 piezoCntl; // For setting the buffer triggers when reading is done

	// Main polling loop
	while (1)
	{
		reqPiezoWave_.wait();
		asynPrint(pasynUserSelf, ASYN_TRACEIO_DRIVER, "%s: got data ready flag\n", __PRETTY_FUNCTION__);

		if (isShuttingDown_)
		{
			break;
		}

		asynPrint(pasynUserSelf, ASYN_TRACEIO_DRIVER, "%s: signaled by reqWaveEventId_\n", __PRETTY_FUNCTION__);

		// Check which channels have data, and request them
		getDoubleParam(p_PiezoWaveKeep, &activeChannelsSigned);  // using double type as mask
		activeChannels = (epicsUInt32)(activeChannelsSigned);  // because sign bit and signed int range break 32 bit mask otherwise
		getUIntDigitalParam(p_PztWaveAvailR, &channelsWithData, (epicsUInt32) 0xFFFFFFFF);

		for (thisChannel = 1; thisChannel != 0; thisChannel <<= 1)
		{
			// See if thisChannel is active and has data available
			switch (thisChannel & activeChannels & channelsWithData)
			{
			case 0x0: // thisChannel is inactive or doesn't have data
				break;

			case 0x1:
				sendBigBuffer(Piezo1C1InWave_.requestMsg, PiezoWave::piezoWaveRegCount);
				break;

			case 0x2:
				sendBigBuffer(Piezo1C1IpWave_.requestMsg, PiezoWave::piezoWaveRegCount);
				break;

			case 0x4:
				sendBigBuffer(Piezo1C1OutVWave_.requestMsg, PiezoWave::piezoWaveRegCount);
				break;

			case 0x8:
				sendBigBuffer(Piezo1C1DriveVWave_.requestMsg, PiezoWave::piezoWaveRegCount);
				break;

			case 0x10:
				sendBigBuffer(Piezo1C2InWave_.requestMsg, PiezoWave::piezoWaveRegCount);
				break;

			case 0x20:
				sendBigBuffer(Piezo1C2IpWave_.requestMsg, PiezoWave::piezoWaveRegCount);
				break;

			case 0x40:
				sendBigBuffer(Piezo1C2OutVWave_.requestMsg, PiezoWave::piezoWaveRegCount);
				break;

			case 0x80:
				sendBigBuffer(Piezo1C2DriveVWave_.requestMsg, PiezoWave::piezoWaveRegCount);
				break;

			case 0x100:
				sendBigBuffer(Piezo2C1InWave_.requestMsg, PiezoWave::piezoWaveRegCount);
				break;

			case 0x200:
				sendBigBuffer(Piezo2C1IpWave_.requestMsg, PiezoWave::piezoWaveRegCount);
				break;

			case 0x400:
				sendBigBuffer(Piezo2C1OutVWave_.requestMsg, PiezoWave::piezoWaveRegCount);
				break;

			case 0x800:
				sendBigBuffer(Piezo2C1DriveVWave_.requestMsg, PiezoWave::piezoWaveRegCount);
				break;

			case 0x1000:
				sendBigBuffer(Piezo2C2InWave_.requestMsg, PiezoWave::piezoWaveRegCount);
				break;

			case 0x2000:
				sendBigBuffer(Piezo2C2IpWave_.requestMsg, PiezoWave::piezoWaveRegCount);
				break;

			case 0x4000:
				sendBigBuffer(Piezo2C2OutVWave_.requestMsg, PiezoWave::piezoWaveRegCount);
				break;

			case 0x8000:
				sendBigBuffer(Piezo2C2DriveVWave_.requestMsg, PiezoWave::piezoWaveRegCount);
				break;

			case 0x10000:
				sendBigBuffer(Piezo3C1InWave_.requestMsg, PiezoWave::piezoWaveRegCount);
				break;

			case 0x20000:
				sendBigBuffer(Piezo3C1IpWave_.requestMsg, PiezoWave::piezoWaveRegCount);
				break;

			case 0x40000:
				sendBigBuffer(Piezo3C1OutVWave_.requestMsg, PiezoWave::piezoWaveRegCount);
				break;

			case 0x80000:
				sendBigBuffer(Piezo3C1DriveVWave_.requestMsg, PiezoWave::piezoWaveRegCount);
				break;

			case 0x100000:
				sendBigBuffer(Piezo3C2InWave_.requestMsg, PiezoWave::piezoWaveRegCount);
				break;

			case 0x200000:
				sendBigBuffer(Piezo3C2IpWave_.requestMsg, PiezoWave::piezoWaveRegCount);
				break;

			case 0x400000:
				sendBigBuffer(Piezo3C2OutVWave_.requestMsg, PiezoWave::piezoWaveRegCount);
				break;

			case 0x800000:
				sendBigBuffer(Piezo3C2DriveVWave_.requestMsg, PiezoWave::piezoWaveRegCount);
				break;

			case 0x1000000:
				sendBigBuffer(Piezo4C1InWave_.requestMsg, PiezoWave::piezoWaveRegCount);
				break;

			case 0x2000000:
				sendBigBuffer(Piezo4C1IpWave_.requestMsg, PiezoWave::piezoWaveRegCount);
				break;

			case 0x4000000:
				sendBigBuffer(Piezo4C1OutVWave_.requestMsg, PiezoWave::piezoWaveRegCount);
				break;

			case 0x8000000:
				sendBigBuffer(Piezo4C1DriveVWave_.requestMsg, PiezoWave::piezoWaveRegCount);
				break;

			case 0x10000000:
				sendBigBuffer(Piezo4C2InWave_.requestMsg, PiezoWave::piezoWaveRegCount);
				break;

			case 0x20000000:
				sendBigBuffer(Piezo4C2IpWave_.requestMsg, PiezoWave::piezoWaveRegCount);
				break;

			case 0x40000000:
				sendBigBuffer(Piezo4C2OutVWave_.requestMsg, PiezoWave::piezoWaveRegCount);
				break;

			case 0x80000000:
				sendBigBuffer(Piezo4C2DriveVWave_.requestMsg, PiezoWave::piezoWaveRegCount);
				break;

			default:
				break;
			}

			// After waveform requests are sent, toggle piezo_buff_trig_* bits for active waveforms controlled
			// by the same PIEZOx_CNTL register, to tell the FPGA to get more data
			switch (thisChannel) // Even if thisChannel isn't active, we want to execute the next part
			{
			case 0x80:
				getUIntDigitalParam(p_Piezo1CntlR, &piezoCntl, (epicsUInt32) 0xFFFFFFFF);
				piezoCntl |= (activeChannels & 0xFF) << 3; // Set active channel bits high without changing other bits
				pasynUserSelf->reason = p_Piezo1CntlW;
				writeUInt32Digital(pasynUserSelf, piezoCntl, (epicsUInt32) 0xFFFFFFFF);

				piezoCntl &= ~(0xFF << 3); // Set all channel trigger bits low
				pasynUserSelf->reason = p_Piezo1CntlW;
				writeUInt32Digital(pasynUserSelf, piezoCntl, (epicsUInt32) 0xFFFFFFFF);
				break;
			case 0x8000:
				getUIntDigitalParam(p_Piezo2CntlR, &piezoCntl, (epicsUInt32) 0xFFFFFFFF);
				piezoCntl |= ((activeChannels >> 8) & 0xFF) << 3; // Set active channel bits high without changing other bits
				pasynUserSelf->reason = p_Piezo2CntlW;
				writeUInt32Digital(pasynUserSelf, piezoCntl, (epicsUInt32) 0xFFFFFFFF);

				piezoCntl &= ~(0xFF << 3); // Set all channel trigger bits low
				pasynUserSelf->reason = p_Piezo2CntlW;
				writeUInt32Digital(pasynUserSelf, piezoCntl, (epicsUInt32) 0xFFFFFFFF);
				break;
			case 0x800000:
				getUIntDigitalParam(p_Piezo3CntlR, &piezoCntl, (epicsUInt32) 0xFFFFFFFF);
				piezoCntl |= ((activeChannels >> 16) & 0xFF) << 3; // Set active channel bits high without changing other bits
				pasynUserSelf->reason = p_Piezo3CntlW;
				writeUInt32Digital(pasynUserSelf, piezoCntl, (epicsUInt32) 0xFFFFFFFF);

				piezoCntl &= ~(0xFF << 3); // Set all channel trigger bits low
				pasynUserSelf->reason = p_Piezo3CntlW;
				writeUInt32Digital(pasynUserSelf, piezoCntl, (epicsUInt32) 0xFFFFFFFF);
				break;
			case 0x80000000:
				getUIntDigitalParam(p_Piezo4CntlR, &piezoCntl, (epicsUInt32) 0xFFFFFFFF);
				piezoCntl |= ((activeChannels >> 24) & 0xFF) << 3; // Set active channel bits high without changing other bits
				pasynUserSelf->reason = p_Piezo4CntlW;
				writeUInt32Digital(pasynUserSelf, piezoCntl, (epicsUInt32) 0xFFFFFFFF);

				piezoCntl &= ~(0xFF << 3); // Set all channel trigger bits low
				pasynUserSelf->reason = p_Piezo4CntlW;
				writeUInt32Digital(pasynUserSelf, piezoCntl, (epicsUInt32) 0xFFFFFFFF);
				break;

			default:
				// This isn't the last waveform controlled by a cntl register, do nothing
				break;
			}
		}
	}
}

asynStatus PiezoWave::processPiezoBufReadback(const FpgaReg *pFromFpga, scllrfRESDriver *pDriver)
{
	waveReadback[readCount] = pFromFpga->data;
	readCount = (readCount + 1)%piezoWaveRegCount;
	if(readCount ==0 ) //we just got the last point
	{
		pDriver->doCallbacksInt32Array(waveReadback, piezoWaveRegCount, paramIndex, 0);
	}
	return asynSuccess;
}
/**  Extract register address and data from the received message and set the appropriate
 * asyn parameter.
 * Some registers have a "new waveform data ready" flag. If they have this and it is set,
 * set weveIsReady to true.
 * Note: This function should not set waveIsReady to false. That is done by a loop in the
 * calling function.
* \param[in] pFromFpga Data returned from the FPGA for a single register
* \param[in] waveIsReady A flag that gets set to true if the appropriate bit was set by the FPGA
*/
asynStatus scllrfRESextra::processRegReadback(const FpgaReg *pFromFpga, bool &waveIsReady)
{
	epicsUInt32 activeChannels;
	double activeChannelsSigned;
	asynStatus status = asynSuccess;
	assert(pFromFpga->addr&flagReadMask); // This function is only for read registers

	/* Map address to parameter, set the parameter in the parameter library. */
	switch (pFromFpga->addr)
    {
    case PztWaveAvailRAdr|flagReadMask:

        status = (asynStatus) setUIntDigitalParam(p_PztWaveAvailR,
                                pFromFpga->data , PztWaveAvailMask);
		// Check which channels are selected by the user
		getDoubleParam(p_PiezoWaveKeep, &activeChannelsSigned);  // using double type as mask
		activeChannels = (epicsUInt32)(activeChannelsSigned);  // because sign bit and signed int range break 32 bit mask otherwise
        if((pFromFpga->data | activeChannels) != 0) // If any waveform has data or is active
        {
            reqPiezoWave_.signal(); // Trigger a waveform read cycle
        }

            asynPrint(pasynUserSelf, ASYN_TRACEIO_DRIVER,
                                "%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
                                PztWaveAvailRString, (unsigned ) pFromFpga->data);
    break;

    case Piezo1C1InRAdr|flagReadMask:

		status = (asynStatus) Piezo1C1InWave_.processPiezoBufReadback(pFromFpga, this);
		asynPrint(pasynUserSelf, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1C1InRString, (unsigned ) pFromFpga->data);
	break;
    case Piezo1C1IpRAdr|flagReadMask:

		status = (asynStatus) Piezo1C1IpWave_.processPiezoBufReadback(pFromFpga, this);
		asynPrint(pasynUserSelf, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1C1IpRString, (unsigned ) pFromFpga->data);
	break;
    case Piezo1C1OutVRAdr|flagReadMask:

		status = (asynStatus) Piezo1C1OutVWave_.processPiezoBufReadback(pFromFpga, this);
		asynPrint(pasynUserSelf, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1C1OutVRString, (unsigned ) pFromFpga->data);
	break;
    case Piezo1C1DriveVRAdr|flagReadMask:

		status = (asynStatus) Piezo1C1DriveVWave_.processPiezoBufReadback(pFromFpga, this);
		asynPrint(pasynUserSelf, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1C1DriveVRString, (unsigned ) pFromFpga->data);
	break;
    case Piezo1C2InRAdr|flagReadMask:

		status = (asynStatus) Piezo1C2InWave_.processPiezoBufReadback(pFromFpga, this);
		asynPrint(pasynUserSelf, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1C2InRString, (unsigned ) pFromFpga->data);
	break;
    case Piezo1C2IpRAdr|flagReadMask:

		status = (asynStatus) Piezo1C2IpWave_.processPiezoBufReadback(pFromFpga, this);
		asynPrint(pasynUserSelf, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1C2IpRString, (unsigned ) pFromFpga->data);
	break;
    case Piezo1C2OutVRAdr|flagReadMask:

		status = (asynStatus) Piezo1C2OutVWave_.processPiezoBufReadback(pFromFpga, this);
		asynPrint(pasynUserSelf, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1C2OutVRString, (unsigned ) pFromFpga->data);
	break;
    case Piezo1C2DriveVRAdr|flagReadMask:

		status = (asynStatus) Piezo1C2DriveVWave_.processPiezoBufReadback(pFromFpga, this);
		asynPrint(pasynUserSelf, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo1C2DriveVRString, (unsigned ) pFromFpga->data);
	break;
    case Piezo2C1InRAdr|flagReadMask:

		status = (asynStatus) Piezo2C1InWave_.processPiezoBufReadback(pFromFpga, this);
		asynPrint(pasynUserSelf, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2C1InRString, (unsigned ) pFromFpga->data);
	break;
    case Piezo2C1IpRAdr|flagReadMask:

		status = (asynStatus) Piezo2C1IpWave_.processPiezoBufReadback(pFromFpga, this);
		asynPrint(pasynUserSelf, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2C1IpRString, (unsigned ) pFromFpga->data);
	break;
    case Piezo2C1OutVRAdr|flagReadMask:

		status = (asynStatus) Piezo2C1OutVWave_.processPiezoBufReadback(pFromFpga, this);
		asynPrint(pasynUserSelf, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2C1OutVRString, (unsigned ) pFromFpga->data);
	break;
    case Piezo2C1DriveVRAdr|flagReadMask:

		status = (asynStatus) Piezo2C1DriveVWave_.processPiezoBufReadback(pFromFpga, this);
		asynPrint(pasynUserSelf, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2C1DriveVRString, (unsigned ) pFromFpga->data);
	break;
    case Piezo2C2InRAdr|flagReadMask:

		status = (asynStatus) Piezo2C2InWave_.processPiezoBufReadback(pFromFpga, this);
		asynPrint(pasynUserSelf, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2C2InRString, (unsigned ) pFromFpga->data);
	break;
    case Piezo2C2IpRAdr|flagReadMask:

		status = (asynStatus) Piezo2C2IpWave_.processPiezoBufReadback(pFromFpga, this);
		asynPrint(pasynUserSelf, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2C2IpRString, (unsigned ) pFromFpga->data);
	break;
    case Piezo2C2OutVRAdr|flagReadMask:

		status = (asynStatus) Piezo2C2OutVWave_.processPiezoBufReadback(pFromFpga, this);
		asynPrint(pasynUserSelf, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2C2OutVRString, (unsigned ) pFromFpga->data);
	break;
    case Piezo2C2DriveVRAdr|flagReadMask:

		status = (asynStatus) Piezo2C2DriveVWave_.processPiezoBufReadback(pFromFpga, this);
		asynPrint(pasynUserSelf, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo2C2DriveVRString, (unsigned ) pFromFpga->data);
	break;
    case Piezo3C1InRAdr|flagReadMask:

		status = (asynStatus) Piezo3C1InWave_.processPiezoBufReadback(pFromFpga, this);
		asynPrint(pasynUserSelf, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3C1InRString, (unsigned ) pFromFpga->data);
	break;
    case Piezo3C1IpRAdr|flagReadMask:

		status = (asynStatus) Piezo3C1IpWave_.processPiezoBufReadback(pFromFpga, this);
		asynPrint(pasynUserSelf, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3C1IpRString, (unsigned ) pFromFpga->data);
	break;
    case Piezo3C1OutVRAdr|flagReadMask:

		status = (asynStatus) Piezo3C1OutVWave_.processPiezoBufReadback(pFromFpga, this);
		asynPrint(pasynUserSelf, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3C1OutVRString, (unsigned ) pFromFpga->data);
	break;
    case Piezo3C1DriveVRAdr|flagReadMask:

		status = (asynStatus) Piezo3C1DriveVWave_.processPiezoBufReadback(pFromFpga, this);
		asynPrint(pasynUserSelf, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3C1DriveVRString, (unsigned ) pFromFpga->data);
	break;
    case Piezo3C2InRAdr|flagReadMask:

		status = (asynStatus) Piezo3C2InWave_.processPiezoBufReadback(pFromFpga, this);
		asynPrint(pasynUserSelf, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3C2InRString, (unsigned ) pFromFpga->data);
	break;
    case Piezo3C2IpRAdr|flagReadMask:

		status = (asynStatus) Piezo3C2IpWave_.processPiezoBufReadback(pFromFpga, this);
		asynPrint(pasynUserSelf, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3C2IpRString, (unsigned ) pFromFpga->data);
	break;
    case Piezo3C2OutVRAdr|flagReadMask:

		status = (asynStatus) Piezo3C2OutVWave_.processPiezoBufReadback(pFromFpga, this);
		asynPrint(pasynUserSelf, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3C2OutVRString, (unsigned ) pFromFpga->data);
	break;
    case Piezo3C2DriveVRAdr|flagReadMask:

		status = (asynStatus) Piezo3C2DriveVWave_.processPiezoBufReadback(pFromFpga, this);
		asynPrint(pasynUserSelf, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo3C2DriveVRString, (unsigned ) pFromFpga->data);
	break;
    case Piezo4C1InRAdr|flagReadMask:

		status = (asynStatus) Piezo4C1InWave_.processPiezoBufReadback(pFromFpga, this);
		asynPrint(pasynUserSelf, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4C1InRString, (unsigned ) pFromFpga->data);
	break;
    case Piezo4C1IpRAdr|flagReadMask:

		status = (asynStatus) Piezo4C1IpWave_.processPiezoBufReadback(pFromFpga, this);
		asynPrint(pasynUserSelf, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4C1IpRString, (unsigned ) pFromFpga->data);
	break;
    case Piezo4C1OutVRAdr|flagReadMask:

		status = (asynStatus) Piezo4C1OutVWave_.processPiezoBufReadback(pFromFpga, this);
		asynPrint(pasynUserSelf, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4C1OutVRString, (unsigned ) pFromFpga->data);
	break;
    case Piezo4C1DriveVRAdr|flagReadMask:
		status = (asynStatus) Piezo4C1DriveVWave_.processPiezoBufReadback(pFromFpga, this);
		asynPrint(pasynUserSelf, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4C1DriveVRString, (unsigned ) pFromFpga->data);
	break;
    case Piezo4C2InRAdr|flagReadMask:

		status = (asynStatus) Piezo4C2InWave_.processPiezoBufReadback(pFromFpga, this);
		asynPrint(pasynUserSelf, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4C2InRString, (unsigned ) pFromFpga->data);
	break;
    case Piezo4C2IpRAdr|flagReadMask:

		status = (asynStatus) Piezo4C2IpWave_.processPiezoBufReadback(pFromFpga, this);
		asynPrint(pasynUserSelf, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4C2IpRString, (unsigned ) pFromFpga->data);
	break;
    case Piezo4C2OutVRAdr|flagReadMask:

		status = (asynStatus) Piezo4C2OutVWave_.processPiezoBufReadback(pFromFpga, this);
		asynPrint(pasynUserSelf, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4C2OutVRString, (unsigned ) pFromFpga->data);
	break;
    case Piezo4C2DriveVRAdr|flagReadMask:

		status = (asynStatus) Piezo4C2DriveVWave_.processPiezoBufReadback(pFromFpga, this);
		asynPrint(pasynUserSelf, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Piezo4C2DriveVRString, (unsigned ) pFromFpga->data);
	break;
	default:
		// Arrays larger than 32 elements should be handled in a subclass, generally more complicated
		{
			scllrfRESDriver::processRegReadback(pFromFpga, waveIsReady);
		}

		break;
    }

    return status;
}



extern "C" {

/* Configuration routine.  Called directly, or from the iocsh function below */

/** EPICS iocsh callable function to call constructor for the scllrfRES class.
 * \param[in] portName The name of the asyn port driver to be created.
 * \param[in] netPortName The name of the asynIPport this will use to communicate */
int scllrfRESextraConfigure(const char *drvPortName, const char *netPortName)
{
	new scllrfRESextra(drvPortName, netPortName);
	return asynSuccess;
}


/* EPICS iocsh shell commands */

static const iocshArg initArg0 = { "drvPortName",iocshArgString};
static const iocshArg initArg1 = { "IP port name",iocshArgString};
static const iocshArg * const initArgs[] = {&initArg0,
		&initArg1};

/* NOTE: The command name defined below, "scllrfRESConfigure", conflicts
 * with the same command defined in the base class if both register functions
 * are left in the dbd file. If it's renamed here, it breaks the macro definition
 * scheme used in iocBoot/common/regInterface.cmd. Is there a better way to resolve
 * the conflict than this duplicate name and leaving scllrfRESRegister out of the
 * dbd file?
 */
static const iocshFuncDef initFuncDef = {"scllrfRESextraConfigure",2,initArgs};
static void initCallFunc(const iocshArgBuf *args)
{
	scllrfRESextraConfigure(args[0].sval, args[1].sval);
}

void scllrfRESextraRegister(void)
{
	iocshRegister(&initFuncDef,initCallFunc);
}

epicsExportRegistrar(scllrfRESextraRegister);

}


/**
 *-----------------------------------------------------------------------------
 * Title      : superconducting low level RF EPICS interface
 * ----------------------------------------------------------------------------
 * File       : scllrfAsynPortDriver.cpp
 * Author     : Garth Brown, gwbrown@slac.stanford.edu
 * Created    : June 17, 2016
 * Last update: September 6, 2016
 * ----------------------------------------------------------------------------
 * Description:
 * Prototype for FPGA register access to FPGAs using protocol defined in papers
 * given to SLAC by LBNL (Larry Doolittle). Uses asynPortDriver interface. Some of this
 * should eventually be autogenerated from json files or some such, and templates.
 *
 * ----------------------------------------------------------------------------
 * This file is part of LCLS II. It is subject to
 * the license terms in the LICENSE.txt file found in the top-level directory
 * of this distribution and at:
    * https://confluence.slac.stanford.edu/display/ppareg/LICENSE.html.
 * No part of LCLS II, including this file, may be
 * copied, modified, propagated, or distributed except according to the terms
 * contained in the LICENSE.txt file.
 * ----------------------------------------------------------------------------
**/

#include "scllrfPRCextra.h"

#include <asynOctetSyncIO.h>
#include <asynCommonSyncIO.h>
#include <limits>
#include <netinet/in.h>
#include <iostream>
using namespace std;
#include <math.h>

/** Constructor for the scllrfPRC class.
 * Calls constructor for the asynPortDriver base class.
 * \param[in] portName The name of the asyn port driver to be created.
 * \param[in] path The path to the peripherial as built by the builder api
 * \param[in] nelms The number of elements of this device (max addr)
 * \paarm[in] nEntries The number of asyn params to be created for each device
 *
 * */
scllrfPRCextra::scllrfPRCextra(const char *drvPortName, const char *netPortName)
: scllrfPRCDriver(drvPortName, netPortName, maxChannel, NUM_SCLLRFPRCEXTRA_PARAMS),
	newCircIQBufAvailable_(0), newCircIQBufRead_ (0)
{
    createParam(WaveformI16BitString, asynParamInt16Array, &p_WaveformI16Bit);
    createParam(WaveformQ16BitString, asynParamInt16Array, &p_WaveformQ16Bit);
    createParam(WaveformI22BitString, asynParamInt32Array, &p_WaveformI22Bit);
    createParam(WaveformQ22BitString, asynParamInt32Array, &p_WaveformQ22Bit);

    createParam(WaveformA16BitString, asynParamInt16Array, &p_WaveformA16Bit);
    createParam(WaveformP16BitString, asynParamInt16Array, &p_WaveformP16Bit);
    createParam(WaveformA22BitString, asynParamInt32Array, &p_WaveformA22Bit);
    createParam(WaveformP22BitString, asynParamInt32Array, &p_WaveformP22Bit);

    createParam(IQNActiveString, asynParamInt32, &p_IQNActive);
    createParam(IQBitWidthString, asynParamInt32, &p_IQBitWidth);
    createParam(IQ16BitNELMString, asynParamInt32, &p_IQ16BitNELM);
    createParam(IQ22BitNELMString, asynParamInt32, &p_IQ22BitNELM);

    // Circle Buffer waveforms

    createParam(CircIQBufString, asynParamInt32Array, &p_CircIQBuf);
    createParam(Circ0NActiveString, asynParamInt32, &p_Circ0NActive);
    createParam(Circ1NActiveString, asynParamInt32, &p_Circ1NActive);
    createParam(CircIQBuf0IString, asynParamInt32Array, &p_CircIQBuf0I);
    createParam(CircIQBuf0QString, asynParamInt32Array, &p_CircIQBuf0Q);
    createParam(CircIQBuf0AString, asynParamInt32Array, &p_CircIQBuf0A);
    createParam(CircIQBuf0PString, asynParamInt32Array, &p_CircIQBuf0P);
    createParam(CircIQBuf1IString, asynParamInt32Array, &p_CircIQBuf1I);
    createParam(CircIQBuf1QString, asynParamInt32Array, &p_CircIQBuf1Q);
    createParam(CircIQBuf1AString, asynParamInt32Array, &p_CircIQBuf1A);
    createParam(CircIQBuf1PString, asynParamInt32Array, &p_CircIQBuf1P);

    createParam(Shell0CircleCountRString, asynParamInt32, &p_Shell0CircleCountR);
    createParam(Shell0CircleStatRString, asynParamInt32, &p_Shell0CircleStatR);
    createParam(Shell0MmRString, asynParamInt32, &p_Shell0MmR);
    createParam(Shell0TagNowRString, asynParamInt32, &p_Shell0TagNowR);
    createParam(Shell0TagOldRString, asynParamInt32, &p_Shell0TagOldR);
    createParam(Shell0TimeStampHighRString, asynParamInt32, &p_Shell0TimeStampHighR);
    createParam(Shell0TimeStampLowRString, asynParamInt32, &p_Shell0TimeStampLowR);
    createParam(Shell0SlowDataBufferRString, asynParamInt8Array, &p_Shell0SlowDataBufferR);

    createParam(Shell1CircleCountRString, asynParamInt32, &p_Shell1CircleCountR);
    createParam(Shell1CircleStatRString, asynParamInt32, &p_Shell1CircleStatR);
    createParam(Shell1MmRString, asynParamInt32, &p_Shell1MmR);
    createParam(Shell1TagNowRString, asynParamInt32, &p_Shell1TagNowR);
    createParam(Shell1TagOldRString, asynParamInt32, &p_Shell1TagOldR);
    createParam(Shell1TimeStampHighRString, asynParamInt32, &p_Shell1TimeStampHighR);
    createParam(Shell1TimeStampLowRString, asynParamInt32, &p_Shell1TimeStampLowR);
    createParam(Shell1SlowDataBufferRString, asynParamInt8Array, &p_Shell1SlowDataBufferR);

//    // A canned request to read all registers
//    static const FpgaReg pCustomPolledRegMsg[] =
//	{
//		{ 0, 0 },
//		{ (flagReadMask | Hello0RAdr), blankData },
//		{ (flagReadMask | Hello1RAdr), blankData },
//		{ (flagReadMask | Hello2RAdr), blankData },
//		{ (flagReadMask | Hello3RAdr), blankData },
//		{ (flagReadMask | ClkStatusOutRAdr), blankData },
//		{ (flagReadMask | FfffffffRAdr), blankData },
//		{ (flagReadMask | FrequencyAdcRAdr), blankData },
//		{ (flagReadMask | Frequency4XoutRAdr), blankData },
//		{ (flagReadMask | FrequencyClkout3RAdr), blankData },
//		{ (flagReadMask | FrequencyDcoRAdr), blankData },
//		{ (flagReadMask | Wave0OutRAdr), blankData },
//		{ (flagReadMask | Wave1OutRAdr), blankData },
//		{ (flagReadMask | AdcTestWave1OutRAdr), blankData },
//		{ (flagReadMask | AdcTestWave2OutRAdr), blankData },
//		{ (flagReadMask | AdcTestWave3OutRAdr), blankData },
//		{ (flagReadMask | AdcTestWave4OutRAdr), blankData },
//		{ (flagReadMask | CtraceRunningRAdr), blankData },
//		{ (flagReadMask | FrequencyGtxTxRAdr), blankData },
//		{ (flagReadMask | FrequencyGtxRxRAdr), blankData },
//		{ (flagReadMask | HistStatusRAdr), blankData },
//		{ (flagReadMask | PhasexStatusRAdr), blankData },
//		{ (flagReadMask | CrcErrorsRAdr), blankData },
//		{ (flagReadMask | Cavity0DetuneRAdr), blankData },
//		{ (flagReadMask | Cavity1DetuneRAdr), blankData },
//		{ (flagReadMask | AdcTestTrigCntRAdr), blankData },
//		{ (flagReadMask | WaveformsAvailableRAdr), blankData },
//		{ (flagReadMask | BanyanStatusRAdr), blankData },
//		{ (flagReadMask | SlowChainOutRAdr), blankData },
//		{ (flagReadMask | TraceStatus1RAdr), blankData },
//		{ (flagReadMask | TraceStatus2RAdr), blankData },
//		{ (flagReadMask | LlrfCircleReadyRAdr), blankData },
//		{ (flagReadMask | IdelayBaseRAdr), blankData },
//		{ (flagReadMask | IdelayBaseRAdr) + 1, blankData },
//		{ (flagReadMask | IdelayBaseRAdr) + 2, blankData },
//		{ (flagReadMask | IdelayBaseRAdr) + 3, blankData },
//		{ (flagReadMask | IdelayBaseRAdr) + 4, blankData },
//		{ (flagReadMask | IdelayBaseRAdr) + 5, blankData },
//		{ (flagReadMask | IdelayBaseRAdr) + 6, blankData },
//		{ (flagReadMask | IdelayBaseRAdr) + 7, blankData },
//		{ (flagReadMask | IdelayBaseRAdr) + 8, blankData },
//		{ (flagReadMask | IdelayBaseRAdr) + 9, blankData },
//		{ (flagReadMask | IdelayBaseRAdr) + 10, blankData },
//		{ (flagReadMask | IdelayBaseRAdr) + 11, blankData },
//		{ (flagReadMask | IdelayBaseRAdr) + 12, blankData },
//		{ (flagReadMask | IdelayBaseRAdr) + 13, blankData },
//		{ (flagReadMask | IdelayBaseRAdr) + 14, blankData },
//		{ (flagReadMask | IdelayBaseRAdr) + 15, blankData },
//		{ (flagReadMask | Shell0DspPiezoSfConstsRAdr), blankData },
//		{ (flagReadMask | Shell0DspPiezoSfConstsRAdr) + 1, blankData },
//		{ (flagReadMask | Shell0DspPiezoSfConstsRAdr) + 2, blankData },
//		{ (flagReadMask | Shell0DspPiezoSfConstsRAdr) + 3, blankData },
//		{ (flagReadMask | Shell0DspPiezoSfConstsRAdr) + 4, blankData },
//		{ (flagReadMask | Shell0DspPiezoSfConstsRAdr) + 5, blankData },
//		{ (flagReadMask | Shell0DspPiezoSfConstsRAdr) + 6, blankData },
//		{ (flagReadMask | Shell0DspPiezoSfConstsRAdr) + 7, blankData },
//		{ (flagReadMask | Shell1DspPiezoSfConstsRAdr), blankData },
//		{ (flagReadMask | Shell1DspPiezoSfConstsRAdr) + 1, blankData },
//		{ (flagReadMask | Shell1DspPiezoSfConstsRAdr) + 2, blankData },
//		{ (flagReadMask | Shell1DspPiezoSfConstsRAdr) + 3, blankData },
//		{ (flagReadMask | Shell1DspPiezoSfConstsRAdr) + 4, blankData },
//		{ (flagReadMask | Shell1DspPiezoSfConstsRAdr) + 5, blankData },
//		{ (flagReadMask | Shell1DspPiezoSfConstsRAdr) + 6, blankData },
//		{ (flagReadMask | Shell1DspPiezoSfConstsRAdr) + 7, blankData },
//		{ (flagReadMask | Shell0DspFdbkCoreMpProcCoeffRAdr), blankData },
//		{ (flagReadMask | Shell0DspFdbkCoreMpProcCoeffRAdr) + 1, blankData },
//		{ (flagReadMask | Shell0DspFdbkCoreMpProcCoeffRAdr) + 2, blankData },
//		{ (flagReadMask | Shell0DspFdbkCoreMpProcCoeffRAdr) + 3, blankData },
//		{ (flagReadMask | Shell0DspFdbkCoreMpProcLimRAdr), blankData },
//		{ (flagReadMask | Shell0DspFdbkCoreMpProcLimRAdr) + 1, blankData },
//		{ (flagReadMask | Shell0DspFdbkCoreMpProcLimRAdr) + 2, blankData },
//		{ (flagReadMask | Shell0DspFdbkCoreMpProcLimRAdr) + 3, blankData },
//		{ (flagReadMask | Shell0DspFdbkCoreMpProcSetmpRAdr), blankData },
//		{ (flagReadMask | Shell0DspFdbkCoreMpProcSetmpRAdr) + 1, blankData },
//		{ (flagReadMask | Shell0DspFdbkCoreMpProcSetmpRAdr) + 2, blankData },
//		{ (flagReadMask | Shell0DspFdbkCoreMpProcSetmpRAdr) + 3, blankData },
//		{ (flagReadMask | Shell1DspFdbkCoreMpProcCoeffRAdr), blankData },
//		{ (flagReadMask | Shell1DspFdbkCoreMpProcCoeffRAdr) + 1, blankData },
//		{ (flagReadMask | Shell1DspFdbkCoreMpProcCoeffRAdr) + 2, blankData },
//		{ (flagReadMask | Shell1DspFdbkCoreMpProcCoeffRAdr) + 3, blankData },
//		{ (flagReadMask | Shell1DspFdbkCoreMpProcLimRAdr), blankData },
//		{ (flagReadMask | Shell1DspFdbkCoreMpProcLimRAdr) + 1, blankData },
//		{ (flagReadMask | Shell1DspFdbkCoreMpProcLimRAdr) + 2, blankData },
//		{ (flagReadMask | Shell1DspFdbkCoreMpProcLimRAdr) + 3, blankData },
//		{ (flagReadMask | Shell1DspFdbkCoreMpProcSetmpRAdr), blankData },
//		{ (flagReadMask | Shell1DspFdbkCoreMpProcSetmpRAdr) + 1, blankData },
//		{ (flagReadMask | Shell1DspFdbkCoreMpProcSetmpRAdr) + 2, blankData },
//		{ (flagReadMask | Shell1DspFdbkCoreMpProcSetmpRAdr) + 3, blankData },
//		{ (flagReadMask | Cavity0DriveCoupleOutCouplingRAdr), blankData },
//		{ (flagReadMask | Cavity0DriveCoupleOutCouplingRAdr) + 1, blankData },
//		{ (flagReadMask | Cavity0DriveCoupleOutPhaseOffsetRAdr), blankData },
//		{ (flagReadMask | Cavity0DriveCoupleOutPhaseOffsetRAdr) + 1, blankData },
//		{ (flagReadMask | Cavity0Mode0CoupleOutCouplingRAdr), blankData },
//		{ (flagReadMask | Cavity0Mode0CoupleOutCouplingRAdr) + 1, blankData },
//		{ (flagReadMask | Cavity0Mode0CoupleOutPhaseOffsetRAdr), blankData },
//		{ (flagReadMask | Cavity0Mode0CoupleOutPhaseOffsetRAdr) + 1, blankData },
//		{ (flagReadMask | Cavity0Mode1CoupleOutCouplingRAdr), blankData },
//		{ (flagReadMask | Cavity0Mode1CoupleOutCouplingRAdr) + 1, blankData },
//		{ (flagReadMask | Cavity0Mode1CoupleOutPhaseOffsetRAdr), blankData },
//		{ (flagReadMask | Cavity0Mode1CoupleOutPhaseOffsetRAdr) + 1, blankData },
//		{ (flagReadMask | Cavity0Mode2CoupleOutCouplingRAdr), blankData },
//		{ (flagReadMask | Cavity0Mode2CoupleOutCouplingRAdr) + 1, blankData },
//		{ (flagReadMask | Cavity0Mode2CoupleOutPhaseOffsetRAdr), blankData },
//		{ (flagReadMask | Cavity0Mode2CoupleOutPhaseOffsetRAdr) + 1, blankData },
//		{ (flagReadMask | Cavity1DriveCoupleOutCouplingRAdr), blankData },
//		{ (flagReadMask | Cavity1DriveCoupleOutCouplingRAdr) + 1, blankData },
//		{ (flagReadMask | Cavity1DriveCoupleOutPhaseOffsetRAdr), blankData },
//		{ (flagReadMask | Cavity1DriveCoupleOutPhaseOffsetRAdr) + 1, blankData },
//		{ (flagReadMask | Cavity1Mode0CoupleOutCouplingRAdr), blankData },
//		{ (flagReadMask | Cavity1Mode0CoupleOutCouplingRAdr) + 1, blankData },
//		{ (flagReadMask | Cavity1Mode0CoupleOutPhaseOffsetRAdr), blankData },
//		{ (flagReadMask | Cavity1Mode0CoupleOutPhaseOffsetRAdr) + 1, blankData },
//		{ (flagReadMask | Cavity1Mode1CoupleOutCouplingRAdr), blankData },
//		{ (flagReadMask | Cavity1Mode1CoupleOutCouplingRAdr) + 1, blankData },
//		{ (flagReadMask | Cavity1Mode1CoupleOutPhaseOffsetRAdr), blankData },
//		{ (flagReadMask | Cavity1Mode1CoupleOutPhaseOffsetRAdr) + 1, blankData },
//		{ (flagReadMask | Cavity1Mode2CoupleOutCouplingRAdr), blankData },
//		{ (flagReadMask | Cavity1Mode2CoupleOutCouplingRAdr) + 1, blankData },
//		{ (flagReadMask | Cavity1Mode2CoupleOutPhaseOffsetRAdr), blankData },
//		{ (flagReadMask | Cavity1Mode2CoupleOutPhaseOffsetRAdr) + 1, blankData },
//		{ (flagReadMask | Shell0DspLpNotchLp1AKxRAdr), blankData },
//		{ (flagReadMask | Shell0DspLpNotchLp1AKxRAdr) + 1, blankData },
//		{ (flagReadMask | Shell0DspLpNotchLp1AKyRAdr), blankData },
//		{ (flagReadMask | Shell0DspLpNotchLp1AKyRAdr) + 1, blankData },
//		{ (flagReadMask | Shell0DspLpNotchLp1BKxRAdr), blankData },
//		{ (flagReadMask | Shell0DspLpNotchLp1BKxRAdr) + 1, blankData },
//		{ (flagReadMask | Shell0DspLpNotchLp1BKyRAdr), blankData },
//		{ (flagReadMask | Shell0DspLpNotchLp1BKyRAdr) + 1, blankData },
//		{ (flagReadMask | Shell1DspLpNotchLp1AKxRAdr), blankData },
//		{ (flagReadMask | Shell1DspLpNotchLp1AKxRAdr) + 1, blankData },
//		{ (flagReadMask | Shell1DspLpNotchLp1AKyRAdr), blankData },
//		{ (flagReadMask | Shell1DspLpNotchLp1AKyRAdr) + 1, blankData },
//		{ (flagReadMask | Shell1DspLpNotchLp1BKxRAdr), blankData },
//		{ (flagReadMask | Shell1DspLpNotchLp1BKxRAdr) + 1, blankData },
//		{ (flagReadMask | Shell1DspLpNotchLp1BKyRAdr), blankData },
//		{ (flagReadMask | Shell1DspLpNotchLp1BKyRAdr) + 1, blankData },
//		{ (flagReadMask | AdcMmcmRAdr), blankData },
//		{ (flagReadMask | CcErrorClearRAdr), blankData },
//		{ (flagReadMask | CcLoc1RAdr), blankData },
//		{ (flagReadMask | Cct1Cavity0StatusAuxRAdr), blankData },
//		{ (flagReadMask | Cct1Cavity1StatusAuxRAdr), blankData },
//		{ (flagReadMask | ConfigBanyanMaskRAdr), blankData },
//		{ (flagReadMask | ConfigBitslipRAdr), blankData },
//		{ (flagReadMask | ConfigClkStatusWeRAdr), blankData },
//		{ (flagReadMask | ConfigIdelayctrlResetRRAdr), blankData },
//		{ (flagReadMask | ConfigMmcmResetRRAdr), blankData },
//		{ (flagReadMask | ConfigPeriphConfigRAdr), blankData },
//		{ (flagReadMask | ConfigPhasexTrigRAdr), blankData },
//		{ (flagReadMask | ConfigRawadcTrigRAdr), blankData },
//		{ (flagReadMask | ConfigScanTriggerWeRAdr), blankData },
//		{ (flagReadMask | ConfigScannerDebugRAdr), blankData },
//		{ (flagReadMask | ConfigSyncAd7794CsetRAdr), blankData },
//		{ (flagReadMask | ConfigSyncTps62210CsetRAdr), blankData },
//		{ (flagReadMask | AdcTestModeRAdr), blankData },
//		{ (flagReadMask | AdcTestResetRAdr), blankData },
//		{ (flagReadMask | AmplitudeRAdr), blankData },
//		{ (flagReadMask | AverageLenRAdr), blankData },
//		{ (flagReadMask | BufTrigRAdr), blankData },
//		{ (flagReadMask | CicPeriodRAdr), blankData },
//		{ (flagReadMask | CicShiftRAdr), blankData },
//		{ (flagReadMask | CircleBufFlipRAdr), blankData },
//		{ (flagReadMask | DacDdsResetRAdr), blankData },
//		{ (flagReadMask | DacModeRAdr), blankData },
//		{ (flagReadMask | DdsaModuloRAdr), blankData },
//		{ (flagReadMask | DdsaPhstepHRAdr), blankData },
//		{ (flagReadMask | DdsaPhstepLRAdr), blankData },
//		{ (flagReadMask | HistCountWStrobeRAdr), blankData },
//		{ (flagReadMask | LlrfDspDacEnRAdr), blankData },
//		{ (flagReadMask | LoAmpRAdr), blankData },
//		{ (flagReadMask | ModuloRAdr), blankData },
//		{ (flagReadMask | PhaseStepHRAdr), blankData },
//		{ (flagReadMask | PhaseStepLRAdr), blankData },
//		{ (flagReadMask | PrcDspCavSelRAdr), blankData },
//		{ (flagReadMask | PrcDspPrlCfgRAdr), blankData },
//		{ (flagReadMask | PrcDspPrlGainRAdr), blankData },
//		{ 0, 0 }, // This should stay on line 273, 175 registers from the start of this structure on line 98
//		{ (flagReadMask | Beam0ModuloRAdr), blankData },
//		{ (flagReadMask | Beam0PhaseInitRAdr), blankData },
//		{ (flagReadMask | Beam0PhaseStepRAdr), blankData },
//		{ (flagReadMask | Beam1ModuloRAdr), blankData },
//		{ (flagReadMask | Beam1PhaseInitRAdr), blankData },
//		{ (flagReadMask | Beam1PhaseStepRAdr), blankData },
//		{ (flagReadMask | Cav4MechPrngIvaRAdr), blankData },
//		{ (flagReadMask | Cav4MechPrngIvbRAdr), blankData },
//		{ (flagReadMask | Cav4MechPrngRandomRunRAdr), blankData },
//		{ (flagReadMask | Cavity0ACavOffsetRAdr), blankData },
//		{ (flagReadMask | Cavity0AForOffsetRAdr), blankData },
//		{ (flagReadMask | Cavity0ARflOffsetRAdr), blankData },
//		{ (flagReadMask | Cavity0AmpLpBwRAdr), blankData },
//		{ (flagReadMask | Cavity0Freq0CoarseFreqRAdr), blankData },
//		{ (flagReadMask | Cavity0Freq1CoarseFreqRAdr), blankData },
//		{ (flagReadMask | Cavity0Freq2CoarseFreqRAdr), blankData },
//		{ (flagReadMask | Cavity0Mode0BeamCouplingRAdr), blankData },
//		{ (flagReadMask | Cavity0Mode0BwRAdr), blankData },
//		{ (flagReadMask | Cavity0Mode0DriveCouplingRAdr), blankData },
//		{ (flagReadMask | Cavity0Mode1BeamCouplingRAdr), blankData },
//		{ (flagReadMask | Cavity0Mode1BwRAdr), blankData },
//		{ (flagReadMask | Cavity0Mode1DriveCouplingRAdr), blankData },
//		{ (flagReadMask | Cavity0Mode2BeamCouplingRAdr), blankData },
//		{ (flagReadMask | Cavity0Mode2BwRAdr), blankData },
//		{ (flagReadMask | Cavity0Mode2DriveCouplingRAdr), blankData },
//		{ (flagReadMask | Cavity0ModuloRAdr), blankData },
//		{ (flagReadMask | Cavity0PhaseStepRAdr), blankData },
//		{ (flagReadMask | Cavity0ComprSatCtlRAdr), blankData },
//		{ (flagReadMask | Cavity0PrngIvaRAdr), blankData },
//		{ (flagReadMask | Cavity0PrngIvbRAdr), blankData },
//		{ (flagReadMask | Cavity0PrngRandomRunRAdr), blankData },
//		{ (flagReadMask | Cavity1ACavOffsetRAdr), blankData },
//		{ (flagReadMask | Cavity1AForOffsetRAdr), blankData },
//		{ (flagReadMask | Cavity1ARflOffsetRAdr), blankData },
//		{ (flagReadMask | Cavity1AmpLpBwRAdr), blankData },
//		{ (flagReadMask | Cavity1Freq0CoarseFreqRAdr), blankData },
//		{ (flagReadMask | Cavity1Freq1CoarseFreqRAdr), blankData },
//		{ (flagReadMask | Cavity1Freq2CoarseFreqRAdr), blankData },
//		{ (flagReadMask | Cavity1Mode0BeamCouplingRAdr), blankData },
//		{ (flagReadMask | Cavity1Mode0BwRAdr), blankData },
//		{ (flagReadMask | Cavity1Mode0DriveCouplingRAdr), blankData },
//		{ (flagReadMask | Cavity1Mode1BeamCouplingRAdr), blankData },
//		{ (flagReadMask | Cavity1Mode1BwRAdr), blankData },
//		{ (flagReadMask | Cavity1Mode1DriveCouplingRAdr), blankData },
//		{ (flagReadMask | Cavity1Mode2BeamCouplingRAdr), blankData },
//		{ (flagReadMask | Cavity1Mode2BwRAdr), blankData },
//		{ (flagReadMask | Cavity1Mode2DriveCouplingRAdr), blankData },
//		{ (flagReadMask | Cavity1ModuloRAdr), blankData },
//		{ (flagReadMask | Cavity1PhaseStepRAdr), blankData },
//		{ (flagReadMask | Cavity1ComprSatCtlRAdr), blankData },
//		{ (flagReadMask | Cavity1PrngIvaRAdr), blankData },
//		{ (flagReadMask | Cavity1PrngIvbRAdr), blankData },
//		{ (flagReadMask | Cavity1PrngRandomRunRAdr), blankData },
//		{ (flagReadMask | DacIqPhaseRAdr), blankData },
//		{ (flagReadMask | Shell0DspChanKeepRAdr), blankData },
//		{ (flagReadMask | Shell0DspFdbkCoreCoarseScaleRAdr), blankData },
//		{ (flagReadMask | Shell0DspFdbkCoreMpProcPhOffsetRAdr), blankData },
//		{ (flagReadMask | Shell0DspFdbkCoreMpProcSelEnRAdr), blankData },
//		{ (flagReadMask | Shell0DspFdbkCoreMpProcSelThreshRAdr), blankData },
//		{ (flagReadMask | Shell0DspModuloRAdr), blankData },
//		{ (flagReadMask | Shell0DspPhaseStepRAdr), blankData },
//		{ (flagReadMask | Shell0DspPiezoPiezoDcRAdr), blankData },
//		{ (flagReadMask | Shell0DspTagRAdr), blankData },
//		{ (flagReadMask | Shell0DspUseFiberIqRAdr), blankData },
//		{ (flagReadMask | Shell0DspWaveSampPerRAdr), blankData },
//		{ (flagReadMask | Shell0DspWaveShiftRAdr), blankData },
//		{ (flagReadMask | Shell1DspChanKeepRAdr), blankData },
//		{ (flagReadMask | Shell1DspFdbkCoreCoarseScaleRAdr), blankData },
//		{ (flagReadMask | Shell1DspFdbkCoreMpProcPhOffsetRAdr), blankData },
//		{ (flagReadMask | Shell1DspFdbkCoreMpProcSelEnRAdr), blankData },
//		{ (flagReadMask | Shell1DspFdbkCoreMpProcSelThreshRAdr), blankData },
//		{ (flagReadMask | Shell1DspModuloRAdr), blankData },
//		{ (flagReadMask | Shell1DspPhaseStepRAdr), blankData },
//		{ (flagReadMask | Shell1DspPiezoPiezoDcRAdr), blankData },
//		{ (flagReadMask | Shell1DspTagRAdr), blankData },
//		{ (flagReadMask | Shell1DspUseFiberIqRAdr), blankData },
//		{ (flagReadMask | Shell1DspWaveSampPerRAdr), blankData },
//		{ (flagReadMask | Shell1DspWaveShiftRAdr), blankData },
//		{ (flagReadMask | RewindRAdr), blankData },
//		{ (flagReadMask | SsaStimAmpstepRAdr), blankData },
//		{ (flagReadMask | SsaStimEnRAdr), blankData },
//		{ (flagReadMask | SsaStimGPeriodRAdr), blankData },
//		{ (flagReadMask | SsaStimPertstepRAdr), blankData },
//		{ (flagReadMask | TraceKeepRAdr), blankData },
//		{ (flagReadMask | TraceResetWeRAdr), blankData },
//		{ (flagReadMask | TrigInternalRAdr), blankData },
//		{ (flagReadMask | TrigModeRAdr), blankData },
//		{ (flagReadMask | Wave0SrcRAdr), blankData },
//		{ (flagReadMask | Wave1SrcRAdr), blankData },
//		{ (flagReadMask | DomainJumpRealignRAdr), blankData },
//		{ (flagReadMask | IccCfgRAdr), blankData },
//		{ (flagReadMask | QsfpI2CRegRAdr), blankData },
//		{ (flagReadMask | SfpAddressSetRAdr), blankData },
//		{ (flagReadMask | TagNowRAdr), blankData },
//	};//pCustomPolledRegMsg
//
//    PolledRegMsgSize_ = sizeof( pCustomPolledRegMsg )/sizeof( *pCustomPolledRegMsg);
//
//    if (pPolledRegMsg_ != NULL)
//    {
//    	//printf("%s rejects the base class's message and replaces it with its own.\n",__PRETTY_FUNCTION__);
//    	delete[] pPolledRegMsg_;
//    	pPolledRegMsg_ = new FpgaReg[sizeof( pCustomPolledRegMsg )/sizeof( *pCustomPolledRegMsg)];
//        std::copy( pCustomPolledRegMsg, pCustomPolledRegMsg + sizeof( pCustomPolledRegMsg )/sizeof( *pCustomPolledRegMsg), (FpgaReg) pPolledRegMsg_ );
//        for(int i = 0; i<PolledRegMsgSize_; i++)
//        	{
//        	pPolledRegMsg_[i] = pCustomPolledRegMsg[i];
//        	std::cout << std::hex << "{ 0x" << pCustomPolledRegMsg[i].addr << ", 0x"  << pCustomPolledRegMsg[i].data << "} --> ";
//        	std::cout << std::hex << "{ 0x" << pPolledRegMsg_[i].addr << ", 0x"  << pPolledRegMsg_[i].data << "}, ";
//        	}
//        std::cout << std::endl;
//    }
//
//    std::cout << "polled register msg size is " << PolledRegMsgSize_ << std::endl;
//	htonFpgaRegArray(pPolledRegMsg_, PolledRegMsgSize_);

    epicsThreadSleep(defaultPollPeriod);
    std::cout << __PRETTY_FUNCTION__ << " created " << NUM_SCLLRFPRCEXTRA_PARAMS << " parameters." << std::endl;

	reqWaveEventId_ = epicsEventMustCreate(epicsEventEmpty);
	startTraceIQWaveformRequester();

	reqCircIQBufEventId_ = epicsEventMustCreate(epicsEventEmpty);
	startCircIQBufRequester();

	singleMsgQueueEventId_ = epicsEventMustCreate(epicsEventEmpty);
	startSingleMessageQueuer();

    epicsThreadSleep(defaultPollPeriod);
    wakeupPoller();
    wakeupReader();
}

scllrfPRCextra::~scllrfPRCextra()
{
	isShuttingDown_ = true;
	epicsThreadSleep(0.1); // Allow threads to run and exit
	epicsEventSignal(reqWaveEventId_);
	wakeupPoller();
	wakeupReader();
	epicsThreadSleep(0.1); // Allow threads to run and exit
	wakeupPoller(); // call this twice in case the poller was never set to run
	wakeupReader();
	epicsThreadSleep(0.1); // Allow threads to run and exit
	wakeupReader();
	pasynOctetSyncIO->disconnect(pOctetAsynUser_);
	pasynCommonSyncIO->disconnectDevice(pCommonAsynUser_);
	pasynCommonSyncIO->disconnect(pCommonAsynUser_);
}


/** Called when asyn clients call pasynInt32->read().
 * \param[in] pasynUser pasynUser structure that encodes the reason and address.
 * \param[in] value Pointer to the value to read. */
asynStatus scllrfPRCextra::writeInt32(asynUser *pasynUser, epicsInt32 value)
{
	int function = pasynUser->reason;
//	int addr = 0;
	asynStatus status = asynSuccess;
    const char *paramName;
//    FpgaReg regSendBuf[2];

	epicsTimeStamp timeStamp; getTimeStamp(&timeStamp);

    /* Fetch the parameter string name for possible use in debugging */
    getParamName(function, &paramName);
    asynPrint(pasynUser, ASYN_TRACEIO_DRIVER, "--> %s: function=%d, %s, set to %d\n",
			__PRETTY_FUNCTION__, function, paramName, value);

    if (function == p_IQBitWidth)
    {
    	wavBitWidth_ = (scllrfPRCextra::traceIQWavBitWidth) value;
        /* Set the parameter in the parameter library. */
        status = (asynStatus) setIntegerParam(function, value);
    }

    scllrfAsynPortDriver::writeInt32(pasynUser, value);

	/* Do callbacks so higher layers see any changes */
	status = (asynStatus) callParamCallbacks();

    if (status)
        epicsSnprintf(pasynUser->errorMessage, pasynUser->errorMessageSize,
                  "%s: status=%d, function=%d, name=%s, value=%d",
				  __PRETTY_FUNCTION__, status, function, paramName, value);
    else
        asynPrint(pasynUser, ASYN_TRACEIO_DRIVER,
              "<-- %s: function=%d, name=%s, value=%d\n",
			  __PRETTY_FUNCTION__, function, paramName, value);
    return status;
}


static void waveformRequesterC(void *drvPvt)
{
	//printf("%s: starting\n", __PRETTY_FUNCTION__);
	scllrfPRCextra *pscllrfDriver = (scllrfPRCextra*)drvPvt;
	pscllrfDriver->traceIQWaveformRequester();
	//printf("%s: exiting\n", __PRETTY_FUNCTION__);
}

/** Starts the poller thread.
 ** Derived classes will typically call this at near the end of their constructor.
 ** Derived classes can typically use the base class implementation of the poller thread,
 ** but are free to re-implement it if necessary.
 ** \param[in] pollPeriod The time between polls. */
asynStatus scllrfPRCextra::startTraceIQWaveformRequester()
{
	epicsThreadCreate("waveformRequester",
			epicsThreadPriorityMedium,
			epicsThreadGetStackSize(epicsThreadStackMedium),
			(EPICSTHREADFUNC)waveformRequesterC, (void *)this);
	return asynSuccess;
}

// When a new value for npt_ (number of points in each waveform) is calculated,
// run this to compose new waveform request messages with the new size.
void scllrfPRCextra::fillTraceIQWavReqMsg()
{
	int i, segmentNum, segmentOffset;
	unsigned int addr=0, segStartAddr = traceIQWavesStart;
	FpgaReg reqWaveMsg[traceIQWaveSegmentCount][traceIQWaveSegmentSize];

	for(i = 0; i<4; i++)
	{
		segmentNum = 0;
		segmentOffset = 1; // Start data past the nonce
		reqWaveMsg[segmentNum][0] = {0,0};
//		//printf("\n%s filling waveform request %d: [%u][%u]={0x%x,0x%x}", __PRETTY_FUNCTION__, i, segmentNum, 0,
//				addr, reqWaveMsg[segmentNum][0].data);
		for (addr = segStartAddr; addr < segStartAddr+npt_; addr++, segmentOffset++)
		{
			reqWaveMsg[segmentNum][segmentOffset].addr = (uint32_t) (addr | flagReadMask);
			reqWaveMsg[segmentNum][segmentOffset].data = blankData + addr;
//			//printf(", [%u][%u]={0x%x,0x%x}", segmentNum, segmentOffset,
//					addr, reqWaveMsg[segmentNum][segmentOffset].data);

			// If there's more to send than will fit in the max message size, break
			// it up into chunks and send each chunk individually
			if(segmentOffset == maxMsgSize/sizeof(FpgaReg)-1)
			{
				segmentNum++;
				reqWaveMsg[segmentNum][0] = {0,0};
//				//printf(" %lu bytes in this segment.\n", (segmentOffset +1) * sizeof (FpgaReg));
				segmentOffset = 0; // will be incremented to 1 at the top of the loop
//				//printf("\nfilling waveform request %d: [%u][%u]={0x0,0x0}", i, segmentNum, segmentOffset);
			}
		}
//		//printf(" %lu of %lu bytes filled in this segment.\n",
//				(segmentOffset +1) * sizeof (FpgaReg), waveSegmentSize * sizeof (FpgaReg));

		// Each segment has unused elements at the end. Safest to convert whole thing.
		////printf("\n%s calling htonFpgaRegArray for waveform %u, %u registers\n", __PRETTY_FUNCTION__, i, waveSegmentCount * waveSegmentSize );

		htonFpgaRegArray(reqWaveMsg[0], traceIQWaveSegmentCount * traceIQWaveSegmentSize);

		switch (i)
		{
		case 0:
			std::copy(&reqWaveMsg[0][0], &reqWaveMsg[0][0]+traceIQWaveSegmentCount * traceIQWaveSegmentSize,
					&pReqIQ16bAMsg_[0][0]); // Canned message to request 16 bit I/Q data, first npt_ points
			break;
		case 1:
			std::copy(&reqWaveMsg[0][0], &reqWaveMsg[0][0]+traceIQWaveSegmentCount * traceIQWaveSegmentSize,
					&pReqIQ16bBMsg_[0][0]); // Canned message to request 16 bit I/Q data, last npt_ points
			break;
		case 2:
			std::copy(&reqWaveMsg[0][0], &reqWaveMsg[0][0]+traceIQWaveSegmentCount * traceIQWaveSegmentSize,
					&pReqI22bMsg_[0][0]); // Canned message to request 22 bit I data
			break;
		case 3:
			std::copy(&reqWaveMsg[0][0], &reqWaveMsg[0][0]+traceIQWaveSegmentCount * traceIQWaveSegmentSize,
					&pReqQ22bMsg_[0][0]); // Canned message to request 22 bit Q data
			break;
		}
//		//printf("Filled up %d of %d segments, last one with %d points\n",
//				segmentNum, waveSegmentCount, segmentOffset);
//		//printf("Setting start address of next waveform segment to 0x%x\n", addr);
		segStartAddr = addr;
	}
}


void scllrfPRCextra::reqTraceIQWWaveform(FpgaReg (*readWaveformsMsg)[traceIQWaveSegmentSize])
{
	int regsLeftToSend = npt_;
	uint i;

//	//printf(" --> %s\n", __PRETTY_FUNCTION__);
//	//printf("%s waveSegmentSize = %u, waveSegmentCount = %u, regsLeftToSend = %d\n",
//			__PRETTY_FUNCTION__, waveSegmentSize, waveSegmentCount, regsLeftToSend);
//	//printf("%s waveBufferRegCount = %u, waveBuffSize = %u, waveSegmentCount = %d\n",
//			__PRETTY_FUNCTION__, waveBufferRegCount, waveBuffSize, waveSegmentCount);
	for (i=0; i<traceIQWaveSegmentCount; ++i)
	{
		if(regsLeftToSend > (int) (maxMsgSize/sizeof(FpgaReg)))
		{
			sendRegRequest(&readWaveformsMsg[i][0], maxMsgSize/sizeof(FpgaReg));
			regsLeftToSend -= maxMsgSize/sizeof(FpgaReg) - 1;
//			//printf("%s sent segment %u, regsLeftToSend = %d\n", __PRETTY_FUNCTION__, i, regsLeftToSend);
		}
		else
		{
			sendRegRequest(&readWaveformsMsg[i][0], regsLeftToSend + 1);
//			//printf("%s sent segment %u, last %d registers\n", __PRETTY_FUNCTION__, i, regsLeftToSend);
			break;
		}
	}
//	//printf(" <-- %s\n", __PRETTY_FUNCTION__);
}

void scllrfPRCextra::traceIQWaveformRequester()
{
	epicsEventWaitStatus status;
	FpgaReg traceAck[5] =
	{
			{0,0},
			{TraceResetWeWAdr,1},
			{BufTrigWAdr,0},
			{BufTrigWAdr,1},
			{BufTrigWAdr,0}
	};

//	FpgaReg traceAck[5] =
//	{
//			{0,0},
//			{CircleBufFlipWAdr,1},
//			{CircleBufFlipWAdr,2},
//			{CircleBufFlipRAdr | flagReadMask,1},
//			{CircleBufFlipRAdr | flagReadMask,2},
//	};
	////printf("\n%s calling htonFpgaRegArray for %u registers of traceAck\n", __PRETTY_FUNCTION__, 5 );
    htonFpgaRegArray(traceAck, sizeof(traceAck)/sizeof(FpgaReg));
    //htonFpgaRegArray(traceAck, 5);
    sendRegRequest(traceAck, sizeof(traceAck)/sizeof(FpgaReg));

	// Main polling loop
	while (1)
	{
		status = epicsEventWait(reqWaveEventId_);

		if (isShuttingDown_)
		{
			break;
		}

		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: signaled by reqWaveEventId_\n", __PRETTY_FUNCTION__);

		// avoid divide by 0 errors when waveforms are inactive
		if (nchan_ <=0 || npt_ <=0)
		{
			epicsThreadSleep(pollPeriod_);
		}
		else {
			/* We got an event, rather than a timeout.
			 **/
			switch (wavBitWidth_)
			{
			case read16bit:
				reqTraceIQWWaveform(pReqIQ16bAMsg_);
				reqTraceIQWWaveform(pReqIQ16bBMsg_);
				break;
			case read22bit:
				reqTraceIQWWaveform(pReqI22bMsg_);
				reqTraceIQWWaveform(pReqQ22bMsg_);
				break;
			default:
				//printf("%s: impossible bit width\n", __PRETTY_FUNCTION__);
				break;
			}

			newWaveRead_ = newWaveAvailable_; // Indicate that we got the signal
			sendRegRequest(traceAck, sizeof(traceAck)/sizeof(FpgaReg));
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
					"%s: done sending waveform request\n", __PRETTY_FUNCTION__);
		}
	}
	//	//printf("%s: exiting\n", __PRETTY_FUNCTION__);
}

// parse register data, write to array PV
asynStatus scllrfPRCextra::processTraceIQWaveReadback(const FpgaReg *pFromFpga)
{
	// avoid divide by 0 errors when waveforms are inactive
	if (nchan_ <=0)
	{
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
			"%s can't process waveform data with 0 active channels\n", __PRETTY_FUNCTION__);
		return asynError;
	}
	if (npt_ <=0)
	{
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
			"%s waveform length set to %u but array index is %u\n",
			__PRETTY_FUNCTION__, (unsigned int) npt_, pFromFpga->addr);
		return asynError;
	}

	unsigned int bufferOffset = (pFromFpga->addr & addrMask) - traceIQWavesStart;
	// additional base offsets
	//   0 * npt  16-bit I and Q
	//   1 * npt  16-bit I and Q
	//   2 * npt  22-bit I
	//   3 * npt  22-bit Q
	unsigned int bufferNumber = bufferOffset / npt_; // of the 4 buffers above, which range are we in?
	unsigned int bufferBase = npt_ * bufferNumber; // in bufferNumber, base address offset
	unsigned int waveOffset = (bufferOffset - bufferBase);
	unsigned int waveNumber = waveOffset % nchan_;
	unsigned int waveIndex = waveOffset / nchan_;
	unsigned int i;

	asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
			"%s bufferOffset = %u, npt_ = %zu, waveNumber = %u waveIndex =%u\n", __PRETTY_FUNCTION__, bufferOffset, npt_, waveNumber, waveIndex);

	switch (bufferNumber)
	{
	case 0: //TODO: verify the packing of the bits for 16 bit data
		pWave16bitI_[waveNumber][waveIndex] = (epicsInt16) pFromFpga->data;
		pWave16bitQ_[waveNumber][waveIndex] = (epicsInt16) (pFromFpga->data >> 16);
		// Amplitude = sqrt(I^2+Q^2)
		pWave16bitA_[waveNumber][waveIndex] = (epicsFloat32) sqrt((pWave16bitI_[waveNumber][waveIndex]^2)+(pWave16bitQ_[waveNumber][waveIndex]^2));
		// phase = arctan(Q/I)
		pWave16bitP_[waveNumber][waveIndex] = (epicsFloat32) atan(pWave16bitQ_[waveNumber][waveIndex] / pWave16bitI_[waveNumber][waveIndex]);
		break;

	case 1:
		waveIndex += npt_; // continued from addresses in "case 0"
		pWave16bitI_[waveNumber][waveIndex] = (epicsInt16) pFromFpga->data;
		pWave16bitQ_[waveNumber][waveIndex] = (epicsInt16) (pFromFpga->data >> 16);
		// Amplitude = sqrt(I^2+Q^2)
		pWave16bitA_[waveNumber][waveIndex] = (epicsFloat32) sqrt((pWave16bitI_[waveNumber][waveIndex]^2)+(pWave16bitQ_[waveNumber][waveIndex]^2));
		// phase = arctan(Q/I)
		pWave16bitP_[waveNumber][waveIndex] = (epicsFloat32) atan(pWave16bitQ_[waveNumber][waveIndex] / pWave16bitI_[waveNumber][waveIndex]);
		if (waveOffset +1 == npt_) // if this is the last point of the waveform
		{
			setIntegerParam(p_IQ16BitNELM, npt_ * 2/nchan_);
			for (i=0; i<maxTraceIQWavesCount; ++i)
			{
				if(i<nchan_)
				{
					doCallbacksInt16Array(pWave16bitI_[i], 2*npt_/nchan_, p_WaveformI16Bit, i);
					doCallbacksInt16Array(pWave16bitQ_[i], 2*npt_/nchan_, p_WaveformQ16Bit, i);
					doCallbacksFloat32Array(pWave16bitA_[i], 2*npt_/nchan_, p_WaveformA16Bit, i);
					doCallbacksFloat32Array(pWave16bitP_[i], 2*npt_/nchan_, p_WaveformP16Bit, i);
				} else { // clear inactive channels
					doCallbacksInt16Array(pWave16bitI_[i], 0, p_WaveformI16Bit, i);
					doCallbacksInt16Array(pWave16bitQ_[i], 0, p_WaveformQ16Bit, i);
					doCallbacksFloat32Array(pWave16bitA_[i], 0, p_WaveformA16Bit, i);
					doCallbacksFloat32Array(pWave16bitP_[i], 0, p_WaveformP16Bit, i);
				}
				std::fill( pWave16bitI_[i], pWave16bitI_[i] + sizeof( pWave16bitI_[i] )/sizeof( *pWave16bitI_[i]), 0 );
				std::fill( pWave16bitQ_[i], pWave16bitQ_[i] + sizeof( pWave16bitQ_[i] )/sizeof( *pWave16bitQ_[i]), 0 );
				std::fill( pWave16bitA_[i], pWave16bitA_[i] + sizeof( pWave16bitA_[i] )/sizeof( *pWave16bitA_[i]), 0 );
				std::fill( pWave16bitP_[i], pWave16bitP_[i] + sizeof( pWave16bitP_[i] )/sizeof( *pWave16bitP_[i]), 0 );
			}
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
					"%s: got last waveform datapoint. Publishing.\n", __PRETTY_FUNCTION__);
		}
		break;

	case 2:
		pWave22bitI_[waveNumber][waveIndex] =
                     ((epicsInt32) pFromFpga->data) >> 10;
		break;

	case 3:
		pWave22bitQ_[waveNumber][waveIndex] =
                     ((epicsInt32) pFromFpga->data) >> 10;
		// Amplitude = sqrt(I^2+Q^2)
		pWave22bitA_[waveNumber][waveIndex] = (epicsFloat32) sqrt((pWave22bitI_[waveNumber][waveIndex]^2)+(pWave22bitQ_[waveNumber][waveIndex]^2));
		// phase = arctan(Q/I)
		pWave22bitP_[waveNumber][waveIndex] = (epicsFloat32) atan(pWave22bitQ_[waveNumber][waveIndex] / pWave22bitI_[waveNumber][waveIndex]);
		if (waveOffset +1 == npt_) // if this is the last point of the waveform
		{
			setIntegerParam(p_IQ22BitNELM, npt_/nchan_);
			for (i=0; i<maxTraceIQWavesCount; ++i)
			{
				if(i<nchan_) // update both I and Q here, so they stay in sync
				{
					doCallbacksInt32Array(pWave22bitI_[i], npt_/nchan_, p_WaveformI22Bit, i);
					doCallbacksInt32Array(pWave22bitQ_[i], npt_/nchan_, p_WaveformQ22Bit, i);
					doCallbacksFloat32Array(pWave22bitA_[i], npt_/nchan_, p_WaveformA22Bit, i);
					doCallbacksFloat32Array(pWave22bitP_[i], npt_/nchan_, p_WaveformP22Bit, i);
				} else { // clear inactive channels
					doCallbacksInt32Array(pWave22bitI_[i], 0, p_WaveformI22Bit, i);
					doCallbacksInt32Array(pWave22bitQ_[i], 0, p_WaveformQ22Bit, i);
					doCallbacksFloat32Array(pWave22bitA_[i], 0, p_WaveformA22Bit, i);
					doCallbacksFloat32Array(pWave22bitP_[i], 0, p_WaveformP22Bit, i);
				}
				std::fill( pWave22bitI_[i], pWave22bitI_[i] + sizeof( pWave22bitI_[i] )/sizeof( *pWave22bitI_[i]), 0 );
				std::fill( pWave22bitQ_[i], pWave22bitQ_[i] + sizeof( pWave22bitQ_[i] )/sizeof( *pWave22bitQ_[i]), 0 );
				std::fill( pWave22bitA_[i], pWave22bitA_[i] + sizeof( pWave22bitA_[i] )/sizeof( *pWave22bitA_[i]), 0 );
				std::fill( pWave22bitP_[i], pWave22bitP_[i] + sizeof( pWave22bitP_[i] )/sizeof( *pWave22bitP_[i]), 0 );
			}
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
					"%s: got last waveform datapoint. Publishing.\n", __PRETTY_FUNCTION__);
		}
		break;

	}

//	//printf("<-- %s\n", __PRETTY_FUNCTION__);
	return asynSuccess;
}
static void circIQBufRequesterC(void *drvPvt)
{
	//printf("%s: starting\n", __PRETTY_FUNCTION__);
	scllrfPRCextra *pscllrfDriver = (scllrfPRCextra*)drvPvt;
	pscllrfDriver->circIQBufRequester();
	//printf("%s: exiting\n", __PRETTY_FUNCTION__);
}

/** Starts the poller thread.
 ** Derived classes will typically call this at near the end of their constructor.
 ** Derived classes can typically use the base class implementation of the poller thread,
 ** but are free to re-implement it if necessary.
 ** \param[in] pollPeriod The time between polls. */
asynStatus scllrfPRCextra::startCircIQBufRequester()
{
	epicsThreadCreate("waveformRequester",
			epicsThreadPriorityMedium,
			epicsThreadGetStackSize(epicsThreadStackMedium),
			(EPICSTHREADFUNC)circIQBufRequesterC, (void *)this);
	return asynSuccess;
}

// run this to compose new waveform request message for circle buffer.
void scllrfPRCextra::fillCircIQBufReqMsg()
{
	fillWaveRequestMsg(pReqCircIQBufMsg_, sizeof(pReqCircIQBufMsg_)/sizeof(*pReqCircIQBufMsg_), circIQBufStart);

	// Also get "slow data registers" every time
	fillWaveRequestMsg(pReqSlowBuf0Msg_, sizeof(pReqSlowBuf0Msg_)/sizeof(*pReqSlowBuf0Msg_), Shell0SlowDataRAdr);
	fillWaveRequestMsg(pReqSlowBuf1Msg_, sizeof(pReqSlowBuf1Msg_)/sizeof(*pReqSlowBuf1Msg_), Shell1SlowDataRAdr);

}


void scllrfPRCextra::reqCircIQBuf()
{
	int regsLeftToSend = circIQBufWaveRegCount;
	uint i;

	// Slow buffer request is packed into one UDP packet, so this is safe.
	sendRegRequest(pReqSlowBuf0Msg_, sizeof(pReqSlowBuf0Msg_)/sizeof(*pReqSlowBuf0Msg_));
	sendRegRequest(pReqSlowBuf1Msg_, sizeof(pReqSlowBuf1Msg_)/sizeof(*pReqSlowBuf1Msg_));

	for (i=0; i<circIQBufSegmentCount; ++i)
	{
		if(regsLeftToSend > (int) (maxRegPerMsg + nonceSize))
		{
			sendRegRequest(&pReqCircIQBufMsg_[i * (maxRegPerMsg + nonceSize)], maxRegPerMsg + nonceSize);
			regsLeftToSend -= maxRegPerMsg;
		}
		else
		{
			sendRegRequest(&pReqCircIQBufMsg_[i * (maxRegPerMsg + nonceSize)], regsLeftToSend + nonceSize);
			//printf("%s sent segment %u, last %d registers\n", __PRETTY_FUNCTION__, i, regsLeftToSend);
			break;
		}
	}
}

void scllrfPRCextra::circIQBufRequester()
{
	epicsEventWaitStatus status;

	FpgaReg circAck[] =
	{
			{0,0},
			{CircleBufFlipWAdr,1},
			{CircleBufFlipWAdr,2},
			{CircleBufFlipWAdr,0},
			{CircleBufFlipRAdr | flagReadMask,blankData},
			{CircleBufFlipRAdr | flagReadMask,blankData},
			{LlrfCircleReadyRAdr | flagReadMask,blankData},
	};
	////printf("\n%s calling htonFpgaRegArray for %u registers of circAck\n", __PRETTY_FUNCTION__, 5 );
    htonFpgaRegArray(circAck, sizeof(circAck)/sizeof(FpgaReg));

    fillCircIQBufReqMsg();

	// Main polling loop
	while (1)
	{
		status = epicsEventWait(reqCircIQBufEventId_);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
					"%s: got data ready flag\n", __PRETTY_FUNCTION__);

		if (isShuttingDown_)
		{
			break;
		}

		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: signaled by reqWaveEventId_\n", __PRETTY_FUNCTION__);

		// Don't request data if no active channels
		if (nCirc0Chan_ <=0 && nCirc1Chan_ <=0)
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
						"%s: nCirc0Chan_=%d, nCirc1Chan_=%d\n", __PRETTY_FUNCTION__, nCirc0Chan_, nCirc1Chan_);
			epicsThreadSleep(pollPeriod_);
		}
		else
		{
			/* We got an event, rather than a timeout.
			 **/
			reqCircIQBuf();

			newCircIQBufRead_ = newCircIQBufAvailable_; // Indicate that we got the signal
			sendRegRequest(circAck, sizeof(circAck)/sizeof(FpgaReg));
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
					"%s: done sending waveform request\n", __PRETTY_FUNCTION__);

		}
	}
}


// parse register data, write to array PV
asynStatus scllrfPRCextra::processCircIQBufReadback(const FpgaReg *pFromFpga)
{
	unsigned int regOffset = (pFromFpga->addr & addrMask) - circIQBufStart;
	// avoid divide by 0 errors when waveforms are inactive
	if ((nCirc0Chan_ <=0) && (nCirc1Chan_ <=0) && regOffset == 0)
	{
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s can't process waveform data with 0 active channels, chan0=%d, chan1=%d\n",
				__PRETTY_FUNCTION__, nCirc0Chan_, nCirc1Chan_);
		return asynError;
	}

	unsigned int bufOffset = regOffset/2; // Data is packed with I at one address, Q at the next, so 2 addresses per I/Q pair
	unsigned int buf0Number = nCirc0Chan_>0? bufOffset % nCirc0Chan_ : 0;
	unsigned int buf0Index = nCirc0Chan_>0? bufOffset / nCirc0Chan_ : 0;
	unsigned int buf1Number = nCirc1Chan_>0? bufOffset % nCirc1Chan_ : 0;
	unsigned int buf1Index = nCirc1Chan_>0? bufOffset / nCirc1Chan_ : 0;
	unsigned int i;

	pCircIQBuf_[regOffset] = pFromFpga->data;
	// Even number addresses are I, odd are Q
	switch(regOffset & 1)
	{
	case 0: // even numbered address
		pCircIQBuf0I_[buf0Number][buf0Index] = (epicsInt16) pFromFpga->data;
		pCircIQBuf1I_[buf1Number][buf1Index] = (epicsInt16) (pFromFpga->data >> 16);
		break;

	case 1: // odd numbered address
		pCircIQBuf0Q_[buf0Number][buf0Index] = (epicsInt16) pFromFpga->data;
		// Amplitude = sqrt(I^2+Q^2)
		pCircIQBuf0A_[buf0Number][buf0Index] = (epicsFloat32) sqrt((pCircIQBuf0I_[buf0Number][buf0Index]^2)+(pCircIQBuf0Q_[buf0Number][buf0Index]^2));
		// phase = arctan(Q/I)
		pCircIQBuf0P_[buf0Number][buf0Index] = (epicsFloat32) pCircIQBuf0I_[buf0Number][buf0Index]==0? NAN: atan(pCircIQBuf0Q_[buf0Number][buf0Index] / pCircIQBuf0I_[buf0Number][buf0Index]);

		pCircIQBuf1Q_[buf1Number][buf1Index] = (epicsInt16) (pFromFpga->data >> 16);
		// Amplitude = sqrt(I^2+Q^2)
		pCircIQBuf1A_[buf1Number][buf1Index] = (epicsFloat32) sqrt((pCircIQBuf1I_[buf1Number][buf1Index]^2)+(pCircIQBuf1Q_[buf1Number][buf1Index]^2));
		// phase = arctan(Q/I)
		pCircIQBuf1P_[buf1Number][buf1Index] = (epicsFloat32) pCircIQBuf1I_[buf1Number][buf1Index]==0? NAN: atan(pCircIQBuf1Q_[buf1Number][buf1Index] / pCircIQBuf1I_[buf1Number][buf1Index]);

		if ((pFromFpga->addr & addrMask) == circIQBufEnd) // if this is the last point of the buffer
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
					"%s: got last waveform datapoint. Publishing.\n", __PRETTY_FUNCTION__);
			doCallbacksInt32Array(pCircIQBuf_, circIQBufWaveRegCount, p_CircIQBuf, 0);
			std::fill( pCircIQBuf_, pCircIQBuf_ + sizeof( pCircIQBuf_ )/sizeof( *pCircIQBuf_), 0 );

			for (i=0; i<maxCircIQBufWavesCount; ++i)
			{
				if(i<nCirc0Chan_)
				{
					doCallbacksInt16Array(pCircIQBuf0I_[i], circIQBufWavePoints/nCirc0Chan_, p_CircIQBuf0I, i);
					doCallbacksInt16Array(pCircIQBuf0Q_[i], circIQBufWavePoints/nCirc0Chan_, p_CircIQBuf0Q, i);
					doCallbacksFloat32Array(pCircIQBuf0A_[i], circIQBufWavePoints/nCirc0Chan_, p_CircIQBuf0A, i);
					doCallbacksFloat32Array(pCircIQBuf0P_[i], circIQBufWavePoints/nCirc0Chan_, p_CircIQBuf0P, i);
				} else { // clear inactive channels
					doCallbacksInt16Array(pCircIQBuf0I_[i], 0, p_CircIQBuf0I, i);
					doCallbacksInt16Array(pCircIQBuf0Q_[i], 0, p_CircIQBuf0Q, i);
					doCallbacksFloat32Array(pCircIQBuf0A_[i], 0, p_CircIQBuf0A, i);
					doCallbacksFloat32Array(pCircIQBuf0P_[i], 0, p_CircIQBuf0P, i);
				}
				std::fill( pCircIQBuf0I_[i], pCircIQBuf0I_[i] + sizeof( pCircIQBuf0I_[i] )/sizeof( *pCircIQBuf0I_[i]), 0 );
				std::fill( pCircIQBuf0Q_[i], pCircIQBuf0Q_[i] + sizeof( pCircIQBuf0Q_[i] )/sizeof( *pCircIQBuf0Q_[i]), 0 );
				std::fill( pCircIQBuf0A_[i], pCircIQBuf0A_[i] + sizeof( pCircIQBuf0A_[i] )/sizeof( *pCircIQBuf0A_[i]), 0 );
				std::fill( pCircIQBuf0P_[i], pCircIQBuf0P_[i] + sizeof( pCircIQBuf0P_[i] )/sizeof( *pCircIQBuf0P_[i]), 0 );

				if(i<nCirc1Chan_)
				{
					doCallbacksInt16Array(pCircIQBuf1I_[i], circIQBufWavePoints/nCirc1Chan_, p_CircIQBuf1I, i);
					doCallbacksInt16Array(pCircIQBuf1Q_[i], circIQBufWavePoints/nCirc1Chan_, p_CircIQBuf1Q, i);
					doCallbacksFloat32Array(pCircIQBuf1A_[i], circIQBufWavePoints/nCirc1Chan_, p_CircIQBuf1A, i);
					doCallbacksFloat32Array(pCircIQBuf1P_[i], circIQBufWavePoints/nCirc1Chan_, p_CircIQBuf1P, i);
				} else { // clear inactive channels
					doCallbacksInt16Array(pCircIQBuf1I_[i], 0, p_CircIQBuf1I, i);
					doCallbacksInt16Array(pCircIQBuf1Q_[i], 0, p_CircIQBuf1Q, i);
					doCallbacksFloat32Array(pCircIQBuf1A_[i], 0, p_CircIQBuf1A, i);
					doCallbacksFloat32Array(pCircIQBuf1P_[i], 0, p_CircIQBuf1P, i);
				}
				std::fill( pCircIQBuf1I_[i], pCircIQBuf1I_[i] + sizeof( pCircIQBuf1I_[i] )/sizeof( *pCircIQBuf1I_[i]), 1 );
				std::fill( pCircIQBuf1Q_[i], pCircIQBuf1Q_[i] + sizeof( pCircIQBuf1Q_[i] )/sizeof( *pCircIQBuf1Q_[i]), 1 );
				std::fill( pCircIQBuf1A_[i], pCircIQBuf1A_[i] + sizeof( pCircIQBuf1A_[i] )/sizeof( *pCircIQBuf1A_[i]), 1 );
				std::fill( pCircIQBuf1P_[i], pCircIQBuf1P_[i] + sizeof( pCircIQBuf1P_[i] )/sizeof( *pCircIQBuf1P_[i]), 1 );
			}
		}
		break;

	default:
		printf("SEE %s, %s, %d. SHOULDN'T BE POSSIBLE TO REACH HERE.\n", __PRETTY_FUNCTION__, __FILE__, __LINE__);
		break;
	}

	return asynSuccess;
}


//asynStatus scllrfPRC::catGitSHA1()
//{
//	int oneByte;
//	int i;
//	asynStatus status;
//
//	strGitSHA1.str("");
//	strGitSHA1.clear();
//	strGitSHA1<<std::hex;
//
////	for (i=p_GitSHA1a; i<=p_GitSHA1t; i++)
////	{
////		status = (asynStatus) getIntegerParam(i, &oneByte);
////		strGitSHA1<< std::setw(2) << oneByte;
////	}
////	// used with stringin reccord, which unfortunately can only handle 19 of the 20 characters
////	status = setStringParam(p_GitSHA1, strGitSHA1.str().c_str());
//
//	return asynSuccess;
//}


static void singleMessageQueuerC(void *drvPvt)
{
	//printf("%s: starting\n", __PRETTY_FUNCTION__);
//	scllrfPRCextra *pscllrfDriver = (scllrfPRCextra*)drvPvt;
//	pscllrfDriver->traceIQWaveformRequester();
	//printf("%s: exiting\n", __PRETTY_FUNCTION__);
}

/** Starts the poller thread.
 ** Derived classes will typically call this at near the end of their constructor.
 ** Derived classes can typically use the base class implementation of the poller thread,
 ** but are free to re-implement it if necessary.
 ** \param[in] pollPeriod The time between polls. */
asynStatus scllrfPRCextra::startSingleMessageQueuer()
{
	epicsThreadCreate("singleMessageQueuer",
			epicsThreadPriorityMedium,
			epicsThreadGetStackSize(epicsThreadStackMedium),
			(EPICSTHREADFUNC)singleMessageQueuerC, (void *)this);
	return asynSuccess;
}


void scllrfPRCextra::singleMessageQueuer()
{
//	epicsEventWaitStatus status;
//	static FpgaReg traceAck[] =
//	{
//			{0,0},
////			{TraceResetWeWAdr,1},
//			{BufTrigWAdr,0},
//			{BufTrigWAdr,1},
//			{BufTrigWAdr,0}
//	};
//	////printf("\n%s calling htonFpgaRegArray for %u registers of traceAck\n", __PRETTY_FUNCTION__, 5 );
//    htonFpgaRegArray(traceAck, sizeof(traceAck)/sizeof(FpgaReg));
//
//	// Main polling loop
//	while (1)
//	{
//		status = epicsEventWait(reqWaveEventId_);
//
//		if (isShuttingDown_)
//		{
//			break;
//		}
//
//		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
//				"%s: signaled by reqWaveEventId_\n", __PRETTY_FUNCTION__);
//
//		// avoid divide by 0 errors when waveforms are inactive
//		if (nchan_ <=0 || npt_ <=0)
//		{
//			epicsThreadSleep(pollPeriod_);
//		}
//		else {
//			/* We got an event, rather than a timeout.
//			 **/
//			switch (wavBitWidth_)
//			{
//			case read16bit:
//				reqOneWaveform(pReqIQ16bAMsg_);
//				reqOneWaveform(pReqIQ16bBMsg_);
//				break;
//			case read22bit:
//				reqOneWaveform(pReqI22bMsg_);
//				reqOneWaveform(pReqQ22bMsg_);
//				break;
//			default:
//				//printf("%s: impossible bit width\n", __PRETTY_FUNCTION__);
//				break;
//			}
//
//			newWaveRead_ = newWaveAvailable_; // Indicate that we got the signal
//			sendRegRequest(traceAck, sizeof(traceAck)/sizeof(FpgaReg));
//			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
//					"%s: done sending waveform request\n", __PRETTY_FUNCTION__);
//		}
//	}
	//	//printf("%s: exiting\n", __PRETTY_FUNCTION__);
}

/**  Extract register address and data from the received message and set the appropriate
 * asyn parameter.
 * Some registers have a "new waveform data ready" flag. If they have this and it is set,
 * set weveIsReady to true.
 * Note: This function should not set waveIsReady to false. That is done by a loop in the
 * calling function.
* \param[in] pFromFpga Data returned from the FPGA for a single register
* \param[in] waveIsReady A flag that gets set to true if the appropriate bit was set by the FPGA
*/
asynStatus scllrfPRCextra::processRegReadback(const FpgaReg *pFromFpga, bool &waveIsReady)
{
	unsigned int i;
	asynStatus status = asynSuccess;
	assert(pFromFpga->addr&flagReadMask); // This function is only for read registers
	epicsInt32 tmpData;
	epicsInt8 slowDataFromFpga[slowDataBuffRegCount];
	uint64_t timeStamp = 0;
	int16_t minMax[6];

	/* Map address to parameter, set the parameter in the parameter library. */
	switch (pFromFpga->addr)
    {
    case ModuloRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_ModuloR,
				(pFromFpga->data & ModuloMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				ModuloRString,
				(unsigned ) pFromFpga->data & ModuloMask);
		iFrequency = ADCfrequency * ((phaseStepH + (phaseStepL/(4096-phaseModulo))));

	break;

    case PhaseStepHRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_PhaseStepHR,
				(pFromFpga->data & PhaseStepHMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				PhaseStepHRString,
				(unsigned ) pFromFpga->data & PhaseStepHMask);
		iFrequency = ADCfrequency * ((phaseStepH + (phaseStepL/(4096-phaseModulo))));
	break;

    case PhaseStepLRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_PhaseStepLR,
				(pFromFpga->data & PhaseStepLMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				PhaseStepLRString,
				(unsigned ) pFromFpga->data & PhaseStepLMask);
		iFrequency = ADCfrequency * ((phaseStepH + (phaseStepL/(4096-phaseModulo))));
	break;

    case TraceStatus1RAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_TraceStatus1R,
				(pFromFpga->data & TraceStatus1Mask));
		if (pFromFpga->data & waveIsReadyMask)
		{
			waveIsReady = true;
		}
		// Calculate number of points per waveform, and update request
		// waveform messages if it has changed.
		if(npt_ != (size_t) (1 << ((pFromFpga->data & nptMask)>> 24)))
		{
			npt_ = 1 << ((pFromFpga->data & nptMask)>> 24);

			if(npt_ > traceIQWaveSegmentCount * (traceIQWaveSegmentSize - 1)) // protect against register saying more points than buffer space
			{
				npt_ = traceIQWaveSegmentCount * (traceIQWaveSegmentSize - 1);
			}
			fillTraceIQWavReqMsg();
		}
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				TraceStatus1RString,
				(unsigned ) pFromFpga->data & TraceStatus1Mask);
	break;

    case TraceKeepRAdr|flagReadMask:
		tmpData = pFromFpga->data & TraceKeepMask;

		status = (asynStatus) setUIntDigitalParam(p_TraceKeepR,
				(pFromFpga->data & TraceKeepMask) , TraceKeepMask);
		// Count the number of bits set
		for (nchan_ = 0; tmpData; nchan_++)
		{
		  tmpData &= tmpData - 1; // clear the least significant bit set
		}
		setIntegerParam(p_IQNActive, nchan_);

		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				TraceKeepRString,
				(unsigned ) pFromFpga->data & TraceKeepMask);
	break;

    case CircleBufFlipRAdr|flagReadMask:
	status = (asynStatus) setUIntDigitalParam(p_CircleBufFlipR,
			(pFromFpga->data & CircleBufFlipMask) , CircleBufFlipMask);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				CircleBufFlipRString,
				(unsigned ) pFromFpga->data & CircleBufFlipMask);
	break;

    case LlrfCircleReadyRAdr|flagReadMask:
	status = (asynStatus) setUIntDigitalParam(p_LlrfCircleReadyR,
			(pFromFpga->data & LlrfCircleReadyMask) , LlrfCircleReadyMask);

		// if flags are set for any active channels,
		if ( (pFromFpga->data & 0x3) &&
		// and there isn't a pending waveform read, and there is at least one active channel
		(newCircIQBufAvailable_ == newCircIQBufRead_) && (nCirc0Chan_+nCirc1Chan_ > 0))
		{
			// Set the message counter with a "new waveform" notification
			// to the message counter value for the message we just received
			newCircIQBufAvailable_ = lastResponseCount_;
			epicsEventSignal(reqCircIQBufEventId_);
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,"%s: new waveform data available, signaling the waveform requester\n",
					__PRETTY_FUNCTION__);
		}
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				LlrfCircleReadyRString,
				(unsigned ) pFromFpga->data & LlrfCircleReadyMask);
	break;

    case Shell0DspChanKeepRAdr|flagReadMask:
		tmpData = pFromFpga->data & Shell0DspChanKeepMask;
		status = (asynStatus) setUIntDigitalParam(p_Shell0DspChanKeepR,
				(pFromFpga->data & Shell0DspChanKeepMask) , Shell0DspChanKeepMask);
		// Count the number of bits set
		for (nCirc0Chan_ = 0; tmpData; nCirc0Chan_++)
		{
		  tmpData &= tmpData - 1; // clear the least significant bit set
		}
		setIntegerParam(p_Circ0NActive, nCirc0Chan_);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell0DspChanKeepRString,
				(unsigned ) pFromFpga->data & Shell0DspChanKeepMask);
	break;

    case Shell1DspChanKeepRAdr|flagReadMask:
		tmpData = pFromFpga->data & Shell1DspChanKeepMask;
		status = (asynStatus) setUIntDigitalParam(p_Shell1DspChanKeepR,
				(pFromFpga->data & Shell1DspChanKeepMask), Shell1DspChanKeepMask);
		// Count the number of bits set
		for (nCirc1Chan_ = 0; tmpData; nCirc1Chan_++)
		{
			tmpData &= tmpData - 1; // clear the least significant bit set
		}
		setIntegerParam(p_Circ1NActive, nCirc1Chan_);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
			"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
			Shell1DspChanKeepRString,
			(unsigned ) pFromFpga->data & Shell1DspChanKeepMask);
	break;

    case Shell0SlowDataRAdr |flagReadMask:
	////XXXX A few variables for testing, can be removed along with code that uses them once we know this stuff works
	int lastCount, newCount, tagNow, tagOld;
	////XXXX
//printf("Raw slow data: ");
		// Slow buffer request is packed into one UDP packet, so this is safe.
		for(i=0; i<slowDataBuffRegCount;i++)
		{
//printf("%d, ",pFromFpga[i].data);
			slowDataFromFpga[i] = pFromFpga[i].data & Shell0SlowDataMask;
		}
//printf("\n");
		getIntegerParam(p_Shell0CircleCountR, &lastCount);
		setIntegerParam(p_Shell0CircleCountR, (slowDataFromFpga[0]<<8)+ slowDataFromFpga[1]);
		getIntegerParam(p_Shell0CircleCountR, &newCount);
		if(newCount == lastCount +1)
		{
			//printf("Last shell0 waveform #%d, new one #%d, we're keeping up\n", lastCount, newCount);
		}
		else
		{
			//printf("Not keeping up with shell0 waveform, had #%d, new one #%d\n", lastCount, newCount);
		}
		setIntegerParam(p_Shell0CircleStatR, (slowDataFromFpga[2]<<8)+ slowDataFromFpga[3]);
		setIntegerParam(p_Shell0TagNowR, slowDataFromFpga[16]);
		setIntegerParam(p_Shell0TagOldR, slowDataFromFpga[17]);

		getIntegerParam(p_Shell0TagNowR, &tagNow);
		getIntegerParam(p_Shell0TagOldR, &tagOld);
		if(tagNow != tagOld)
		{
			//printf("Parameters changed mid-data, skip this waveform. Old tag = %d, new = %d\n", tagOld, tagNow);
		}

		for(i=4; i<16; i+=2)
		{
			minMax[i-4] = static_cast<int16_t>(slowDataFromFpga[i])<<8 | static_cast<int16_t>(slowDataFromFpga[i+1]);
			//printf("Scale %d is %d\n", i, minMax[i-4]);
		}

		for(i=0; i<8; i++)
		{
			timeStamp = (timeStamp << 8) | static_cast<uint64_t>(slowDataFromFpga[i]);
		}
		timeStamp >>= 5;

		setIntegerParam(p_Shell0TimeStampHighR, (int) (timeStamp>>32));
		setIntegerParam(p_Shell0TimeStampLowR, (int) timeStamp & ((2^32) - 1));
//printf("Time stamp is %u %u\n", (timeStamp>>32), timeStamp & ((2^32) - 1));

		doCallbacksInt8Array(slowDataFromFpga, slowDataBuffRegCount, p_Shell0SlowDataBufferR, 0);

	break;

    case Shell1SlowDataRAdr |flagReadMask:

	//printf("Raw slow data: ");
		// Slow buffer request is packed into one UDP packet, so this is safe.
		for(i=0; i<slowDataBuffRegCount;i++)
		{
			//printf("%d, ",pFromFpga[i].data);
			slowDataFromFpga[i] = pFromFpga[i].data & Shell1SlowDataMask;
		}
		//printf("\n");

		doCallbacksInt8Array(slowDataFromFpga, slowDataBuffRegCount, p_Shell1SlowDataBufferR, 0);
		getIntegerParam(p_Shell1CircleCountR, &lastCount);
		setIntegerParam(p_Shell1CircleCountR, (slowDataFromFpga[0]<<8)+ slowDataFromFpga[1]);
		getIntegerParam(p_Shell1CircleCountR, &newCount);
		if(newCount == lastCount +1)
		{
			//printf("Last shell0 waveform #%d, new one #%d, we're keeping up\n", lastCount, newCount);
		}
		else
		{
			//printf("Not keeping up with shell0 waveform, had #%d, new one #%d\n", lastCount, newCount);
		}
		setIntegerParam(p_Shell1CircleStatR, (slowDataFromFpga[2]<<8)+ slowDataFromFpga[3]);
		setIntegerParam(p_Shell1TagNowR, slowDataFromFpga[16]);
		setIntegerParam(p_Shell1TagOldR, slowDataFromFpga[17]);

		getIntegerParam(p_Shell1TagNowR, &tagNow);
		getIntegerParam(p_Shell1TagOldR, &tagOld);
		if(tagNow != tagOld)
		{
			//printf("Parameters changed mid-data, skip this waveform. Old tag = %d, new = %d\n", tagOld, tagNow);
		}

		for(i=4; i<16; i+=2)
		{
			minMax[i-4] = static_cast<int16_t>(slowDataFromFpga[i])<<8 | static_cast<int16_t>(slowDataFromFpga[i+1]);
			//printf("Scale %d is %d\n", i, minMax[i-4]);
		}

		for(i=0; i<8; i++)
		{
			timeStamp = (timeStamp << 8) | static_cast<uint64_t>(slowDataFromFpga[i]);
		}
		timeStamp >>= 5;

		setIntegerParam(p_Shell1TimeStampHighR, (int) (timeStamp>>32));
		setIntegerParam(p_Shell1TimeStampLowR, (int) timeStamp & ((2^32) - 1));
		//printf("Time stamp is %u %u\n", (timeStamp>>32), timeStamp & ((2^32) - 1));

	break;

	default:
		if( traceIQWavesStart <= (pFromFpga->addr & addrMask) && (pFromFpga->addr & addrMask) <= traceIQWavesEnd )
		{
			////printf("%s waveform address 0x%x, value %d\n", __PRETTY_FUNCTION__, (pFromFpga->addr & addrMask), pFromFpga->data);
			processTraceIQWaveReadback(pFromFpga);
		}
		else
		if( circIQBufStart <= (pFromFpga->addr & addrMask) && (pFromFpga->addr & addrMask) <= circIQBufEnd )
		{
			////printf("%s waveform addres 0x%x, value %d\n", __PRETTY_FUNCTION__, (pFromFpga->addr & addrMask), pFromFpga->data);
			processCircIQBufReadback(pFromFpga);
		}
		else
		if(Shell0SlowDataRAdr + 1 <= (pFromFpga->addr & addrMask) && (pFromFpga->addr & addrMask) <= Shell0SlowDataRAdr + slowDataBuffRegCount - 1)
		{
			// Ignore this, it's handled in the slow data case statement
		}
		else
		if(Shell1SlowDataRAdr + 1 <= (pFromFpga->addr & addrMask) && (pFromFpga->addr & addrMask) <= Shell1SlowDataRAdr + slowDataBuffRegCount - 1)
		{
			// Ignore this, it's handled in the slow data case statement
		}
		else
		{
                       // //printf("%s passing processing of register 0c%x to parent class\n", __PRETTY_FUNCTION__, (pFromFpga->addr & addrMask));
			status = scllrfPRCDriver::processRegReadback(pFromFpga, waveIsReady);
		}
		break;
    }

    return status;
}


/**  Extract register address and data from the received message and set the appropriate
 * asyn parameter.
 * Some registers have a "new waveform data ready" flag. If they have this and it is set,
 * set weveIsReady to true.
 * Note: This function should not set waveIsReady to false. That is done by a loop in the
 * calling function.
* \param[in] pFromFpga Data returned from the FPGA for a single register
* \param[in] waveIsReady A flag that gets set to true if the appropriate bit was set by the FPGA
*/
asynStatus scllrfPRCextra::processRegWriteResponse(const FpgaReg *pFromFpga)
{
	asynStatus status = asynSuccess;
	epicsInt32 valueSet[maxMsgSize/sizeof(FpgaReg)]; // Put the value sent to the FPGA here for comparison
	epicsUInt32 uValueSet[maxMsgSize/sizeof(FpgaReg)];
//	epicsUInt32 uValueSet;
	epicsInt32 tmpData;
	epicsInt32 errorCount;
//  variables that may be useful for checking array data
//	asynUser *pAsynArrayUser;
//	unsigned int i;
	assert(!(pFromFpga->addr&flagReadMask)); // This function is only for read registers

	/* Map address to parameter, set the parameter in the parameter library. */
	switch (pFromFpga->addr)
    {
    case ModuloWAdr:
		status = (asynStatus) getIntegerParam(p_ModuloW, valueSet );
		if( (int32_t)(valueSet[0] & ModuloMask) == (pFromFpga->data & ModuloMask))
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				ModuloWString, (unsigned ) pFromFpga->data & ModuloMask);
			iFrequency = ADCfrequency * ((phaseStepH + (phaseStepL/(4096-phaseModulo))));
		}
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				ModuloWString, valueSet[0] & ModuloMask, (unsigned ) pFromFpga->data & ModuloMask);
			status = asynError;
			setParamStatus(p_ModuloW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case PhaseStepHWAdr:
		status = (asynStatus) getIntegerParam(p_PhaseStepHW, valueSet );
		if( (int32_t)(valueSet[0] & PhaseStepHMask) == (pFromFpga->data & PhaseStepHMask))
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				PhaseStepHWString, (unsigned ) pFromFpga->data & PhaseStepHMask);
			iFrequency = ADCfrequency * ((phaseStepH + (phaseStepL/(4096-phaseModulo))));
		}
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				PhaseStepHWString, valueSet[0] & PhaseStepHMask, (unsigned ) pFromFpga->data & PhaseStepHMask);
			status = asynError;
			setParamStatus(p_PhaseStepHW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case PhaseStepLWAdr:
		status = (asynStatus) getIntegerParam(p_PhaseStepLW, valueSet );
		if( (int32_t)(valueSet[0] & PhaseStepLMask) == (pFromFpga->data & PhaseStepLMask))
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				PhaseStepLWString, (unsigned ) pFromFpga->data & PhaseStepLMask);
			iFrequency = ADCfrequency * ((phaseStepH + (phaseStepL/(4096-phaseModulo))));
		}
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				PhaseStepLWString, valueSet[0] & PhaseStepLMask, (unsigned ) pFromFpga->data & PhaseStepLMask);
			status = asynError;
			setParamStatus(p_PhaseStepLW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case BufTrigWAdr:
		status = (asynStatus) getUIntDigitalParam(p_BufTrigW, uValueSet , BufTrigMask);
		if( (uValueSet[0] & BufTrigMask) == (pFromFpga->data & BufTrigMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				BufTrigWString, (unsigned ) pFromFpga->data & BufTrigMask);
		else
		{
			// We don't care, since this is typically part of a canned sequence of writes
		}

		break;
    case TraceKeepWAdr:
		status = (asynStatus) getIntegerParam(p_TraceKeepW, valueSet);
		if( (valueSet[0] & TraceKeepMask) == (pFromFpga->data & TraceKeepMask))
		{		// Count the number of bits set
			tmpData = (pFromFpga->data & TraceKeepMask);
			for (nchan_ = 0; tmpData; nchan_++)
			{
			  tmpData &= tmpData - 1; // clear the least significant bit set
			}
			setIntegerParam(p_IQNActive, nchan_);
		    //printf("%s TraceKeepWAdr says %d active channels\n",__PRETTY_FUNCTION__,nchan_);

			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				TraceKeepWString, (unsigned ) pFromFpga->data & TraceKeepMask);
		}
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				TraceKeepWString, valueSet[0] & TraceKeepMask, (unsigned ) pFromFpga->data & TraceKeepMask);
			status = asynError;
			setParamStatus(p_TraceKeepW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case TraceResetWeWAdr:
		status = (asynStatus) getUIntDigitalParam(p_TraceKeepW, uValueSet , TraceKeepMask);
		if( (uValueSet[0] & TraceResetWeMask) == (pFromFpga->data & TraceResetWeMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				TraceResetWeWString, (unsigned ) pFromFpga->data & TraceResetWeMask);
		else
		{
			// We don't care, since there are typically several writes to this per message: 0, 1, 0
		}

		break;
    case CircleBufFlipWAdr:
		status = (asynStatus) getUIntDigitalParam(p_CircleBufFlipW, uValueSet , CircleBufFlipMask);
		if( (uValueSet[0] & CircleBufFlipMask) == (pFromFpga->data & CircleBufFlipMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				CircleBufFlipWString, (unsigned ) pFromFpga->data & CircleBufFlipMask);
		else
		{
			// That's normal for this register
		}

		break;

    case Shell0DspChanKeepWAdr:
		status = (asynStatus) getUIntDigitalParam(p_Shell0DspChanKeepW, uValueSet , Shell0DspChanKeepMask);
		////XXXXX Trigger a read whenever we change a bit, whether data is ready or not.
		//newCircIQBufAvailable_ = lastResponseCount_;
		//epicsEventSignal(reqCircIQBufEventId_);
		////XXXX

		if( (uValueSet[0] & Shell0DspChanKeepMask) == (pFromFpga->data & Shell0DspChanKeepMask))
		{
			// Count the number of bits set
			tmpData = (pFromFpga->data & Shell0DspChanKeepMask);
			for (nchan_ = 0; tmpData; nchan_++)
			{
			  tmpData &= tmpData - 1; // clear the least significant bit set
			}
			setIntegerParam(p_Circ0NActive, nCirc0Chan_);
			//printf("%s Shell0DspChanKeepWAdr says %d active channels\n",__PRETTY_FUNCTION__,nCirc0Chan_);
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell0DspChanKeepWString, (unsigned ) pFromFpga->data & Shell0DspChanKeepMask);
		}
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Shell0DspChanKeepWString, uValueSet[0] & Shell0DspChanKeepMask, (unsigned ) pFromFpga->data & Shell0DspChanKeepMask);
			status = asynError;
			setParamStatus(p_Shell0DspChanKeepW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;

    case Shell1DspChanKeepWAdr:
		status = (asynStatus) getUIntDigitalParam(p_Shell1DspChanKeepW, uValueSet , Shell1DspChanKeepMask);
		if( (uValueSet[0] & Shell1DspChanKeepMask) == (pFromFpga->data & Shell1DspChanKeepMask))
		{
			// Count the number of bits set
			tmpData = (pFromFpga->data & Shell1DspChanKeepMask);
			for (nchan_ = 0; tmpData; nchan_++)
			{
			  tmpData &= tmpData - 1; // clear the least significant bit set
			}
			setIntegerParam(p_Circ1NActive, nCirc1Chan_);
			//printf("%s Shell1DspChanKeepWAdr says %d active channels\n",__PRETTY_FUNCTION__,nCirc1Chan_);
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell1DspChanKeepWString, (unsigned ) pFromFpga->data & Shell1DspChanKeepMask);
		}
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Shell1DspChanKeepWString, uValueSet[0] & Shell1DspChanKeepMask, (unsigned ) pFromFpga->data & Shell1DspChanKeepMask);
			status = asynError;
			setParamStatus(p_Shell1DspChanKeepW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;

	default:
// TODO: Add checking for arrays. Until then, we'll hit "default" for array values, so not really an error. GWB 8-23-2016
//		getIntegerParam(p_CommErrorCount, &errorCount);
//		setIntegerParam(p_CommErrorCount, errorCount + 1);
		status = scllrfPRCDriver::processRegWriteResponse(pFromFpga);

		break;
    }

	// TODO: handle arrays

    return status;
}



extern "C" {

/* Configuration routine.  Called directly, or from the iocsh function below */

/** EPICS iocsh callable function to call constructor for the scllrfPRC class.
 * \param[in] portName The name of the asyn port driver to be created.
 * \param[in] netPortName The name of the asynIPport this will use to communicate */
int scllrfPRCextraConfigure(const char *drvPortName, const char *netPortName)
{
	new scllrfPRCextra(drvPortName, netPortName);
	return asynSuccess;
}


/* EPICS iocsh shell commands */

static const iocshArg initArg0 = { "drvPortName",iocshArgString};
static const iocshArg initArg1 = { "IP port name",iocshArgString};
static const iocshArg * const initArgs[] = {&initArg0,
		&initArg1};

/* NOTE: The command name defined below, "scllrfPRCConfigure", conflicts
 * with the same command defined in the base class if both register functions
 * are left in the dbd file. If it's renamed here, it breaks the macro definition
 * scheme used in iocBoot/common/regInterface.cmd. Is there a better way to resolve
 * the conflict than this duplicate name and leaving scllrfPRCRegister out of the
 * dbd file?
 */
static const iocshFuncDef initFuncDef = {"scllrfPRCConfigure",2,initArgs};
static void initCallFunc(const iocshArgBuf *args)
{
	scllrfPRCextraConfigure(args[0].sval, args[1].sval);
}

void scllrfPRCextraRegister(void)
{
	iocshRegister(&initFuncDef,initCallFunc);
}

epicsExportRegistrar(scllrfPRCextraRegister);

}




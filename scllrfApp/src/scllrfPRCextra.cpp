
/**
 *-----------------------------------------------------------------------------
 * Title      : superconducting low level RF EPICS interface
 * ----------------------------------------------------------------------------
 * File       : scllrfAsynPortDriver.cpp
 * Author     : Garth Brown, gwbrown@slac.stanford.edu
 * Created    : June 17, 2016
 * Last update: September 6, 2016
 * ----------------------------------------------------------------------------
 * Description:
 * Prototype for FPGA register access to FPGAs using protocol defined in papers
 * given to SLAC by LBNL (Larry Doolittle). Uses asynPortDriver interface. Some of this
 * should eventually be autogenerated from json files or some such, and templates.
 *
 * ----------------------------------------------------------------------------
 * This file is part of LCLS II. It is subject to
 * the license terms in the LICENSE.txt file found in the top-level directory
 * of this distribution and at:
    * https://confluence.slac.stanford.edu/display/ppareg/LICENSE.html.
 * No part of LCLS II, including this file, may be
 * copied, modified, propagated, or distributed except according to the terms
 * contained in the LICENSE.txt file.
 * ----------------------------------------------------------------------------
**/

#include "scllrfPRCextra.h"

#include <asynOctetSyncIO.h>
#include <asynCommonSyncIO.h>
#include <limits>
#include <netinet/in.h>
#include <iostream>
using namespace std;
#include <math.h>

/** Constructor for the scllrfPRC class.
 * Calls constructor for the asynPortDriver base class.
 * \param[in] portName The name of the asyn port driver to be created.
 * \param[in] path The path to the peripherial as built by the builder api
 * \param[in] nelms The number of elements of this device (max addr)
 * \paarm[in] nEntries The number of asyn params to be created for each device
 *
 * */
scllrfPRCextra::scllrfPRCextra(const char *drvPortName, const char *netPortName)
: scllrfPRCDriver(drvPortName, netPortName, maxWavesCount, NUM_SCLLRFPRCEXTRA_PARAMS)
{
	unsigned int i;

    createParam(WaveformI16BitString, asynParamInt16Array, &p_WaveformI16Bit);
    createParam(WaveformQ16BitString, asynParamInt16Array, &p_WaveformQ16Bit);
    createParam(WaveformI22BitString, asynParamInt32Array, &p_WaveformI22Bit);
    createParam(WaveformQ22BitString, asynParamInt32Array, &p_WaveformQ22Bit);
    createParam(IQNActiveString, asynParamInt32, &p_IQNActive);
    createParam(IQBitWidthString, asynParamInt32, &p_IQBitWidth);
    createParam(IQ16BitNELMString, asynParamInt32, &p_IQ16BitNELM);
    createParam(IQ22BitNELMString, asynParamInt32, &p_IQ22BitNELM);

// Is this next line wrong, or is the generated one wrong?
    PolledRegMsgSize_ = scllrfPRCReadRegCount + (scllrfPRCReadRegCount / 175) + 1;
    if (pPolledRegMsg_ != NULL)
    {
    	printf("%s rejects the base class's message and replaces it with its own.\n",__PRETTY_FUNCTION__);
    	delete pPolledRegMsg_;
    }

    // A canned request to read all registers
    // NOTE: To avoid side effects, any registers with U or spi in their name have been
    // manually replaced with H0D0A0D0ARAdr
    pPolledRegMsg_ = new FpgaReg[PolledRegMsgSize_]
	{
		{ 0, 0 },
		{ flagReadMask | HellRAdr, blankData },
		{ flagReadMask | OWoRAdr, blankData },
		{ flagReadMask | RldRAdr, blankData },
		{ flagReadMask | H0D0A0D0ARAdr, blankData },
		{ flagReadMask | H0D0A0D0ARAdr, blankData },
		{ flagReadMask | H0D0A0D0ARAdr, blankData },
		{ flagReadMask | ClkStatusOutRAdr, blankData },
		{ flagReadMask | FfffffffRAdr, blankData },
		{ flagReadMask | FrequencyAdcRAdr, blankData },
		{ flagReadMask | Frequency4XoutRAdr, blankData },
		{ flagReadMask | FrequencyClkout3RAdr, blankData },
		{ flagReadMask | FrequencyDcoRAdr, blankData },
		{ flagReadMask | H0D0A0D0ARAdr, blankData },
		{ flagReadMask | H0D0A0D0ARAdr, blankData },
		{ flagReadMask | H0D0A0D0ARAdr, blankData },
		{ flagReadMask | H0D0A0D0ARAdr, blankData },
		{ flagReadMask | H0D0A0D0ARAdr, blankData },
		{ flagReadMask | H0D0A0D0ARAdr, blankData },
		{ flagReadMask | H0D0A0D0ARAdr, blankData },
		{ flagReadMask | H0D0A0D0ARAdr, blankData },
		{ flagReadMask | Wave0OutRAdr, blankData },
		{ flagReadMask | Wave1OutRAdr, blankData },
		{ flagReadMask | AdcTestWave1OutRAdr, blankData },
		{ flagReadMask | AdcTestWave2OutRAdr, blankData },
		{ flagReadMask | AdcTestWave3OutRAdr, blankData },
		{ flagReadMask | AdcTestWave4OutRAdr, blankData },
		{ flagReadMask | CtraceRunningRAdr, blankData },
		{ flagReadMask | FrequencyGtxTxRAdr, blankData },
		{ flagReadMask | FrequencyGtxRxRAdr, blankData },
		{ flagReadMask | HistStatusRAdr, blankData },
		{ flagReadMask | PhasexStatusRAdr, blankData },
		{ flagReadMask | H0D0A0D0ARAdr, blankData },
		{ flagReadMask | H0D0A0D0ARAdr, blankData },
		{ flagReadMask | CrcErrorsRAdr, blankData },
		{ flagReadMask | H0D0A0D0ARAdr, blankData },
		{ flagReadMask | H0D0A0D0ARAdr, blankData },
		{ flagReadMask | H0D0A0D0ARAdr, blankData },
		{ flagReadMask | H0D0A0D0ARAdr, blankData },
		{ flagReadMask | AdcTestTrigCntRAdr, blankData },
		{ flagReadMask | WaveformsAvailableRAdr, blankData },
		{ flagReadMask | BanyanStatusRAdr, blankData },
		{ flagReadMask | SlowChainOutRAdr, blankData },
		{ flagReadMask | TraceStatus1RAdr, blankData },
		{ flagReadMask | TraceStatus2RAdr, blankData },
		{ flagReadMask | LlrfCircleReadyRAdr, blankData },
		{ flagReadMask | IdelayBaseRAdr, blankData },
		{ flagReadMask | HistDoutRAdr, blankData },
		{ flagReadMask | PhasexDoutRAdr, blankData },
		{ flagReadMask | BanyanBufRAdr, blankData },
		{ flagReadMask | ScannerResultRAdr, blankData },
		{ flagReadMask | TraceIqBufRAdr, blankData },
		{ flagReadMask | TraceIBufRAdr, blankData },
		{ flagReadMask | TraceQBufRAdr, blankData },
		{ flagReadMask | QsfpBufRAdr, blankData },
		{ flagReadMask | LlrfCircleDataRAdr, blankData },
		{ flagReadMask | Shell0SlowDataRAdr, blankData },
		{ flagReadMask | Shell1SlowDataRAdr, blankData },
		{ flagReadMask | NoiseCouplekOutRAdr, blankData },
		{ flagReadMask | PropConstRAdr, blankData },
		{ flagReadMask | C0Cav4Elecdot0KOutRAdr, blankData },
		{ flagReadMask | C0Cav4Elecdot1KOutRAdr, blankData },
		{ flagReadMask | Cav0Cav4Elecdot2KOutRAdr, blankData },
		{ flagReadMask | Digdsprsmcav0Cav4ElecouterProd0KOutRAdr, blankData },
		{ flagReadMask | Cav0Cav4ElecouterProd1KOutRAdr, blankData },
		{ flagReadMask | C0Cav4ElecouterProd2KOutRAdr, blankData },
		{ flagReadMask | Cav0PiezoCouplekOutRAdr, blankData },
		{ flagReadMask | C1Cav4Elecdot0KOutRAdr, blankData },
		{ flagReadMask | Cav1Cav4Elecdot1KOutRAdr, blankData },
		{ flagReadMask | C1Cav4Elecdot2KOutRAdr, blankData },
		{ flagReadMask | Rsmcav1Cav4ElecouterProd0KOutRAdr, blankData },
		{ flagReadMask | Cav1Cav4ElecouterProd1KOutRAdr, blankData },
		{ flagReadMask | C1Cav4ElecouterProd2KOutRAdr, blankData },
		{ flagReadMask | C1PiezoCouplekOutRAdr, blankData },
		{ flagReadMask | C0DelayPcXxxRAdr, blankData },
		{ flagReadMask | C1DelayPcXxxRAdr, blankData },
		{ flagReadMask | C0DsppiezosfConstsRAdr, blankData },
		{ flagReadMask | Rsmshell1DsppiezosfConstsRAdr, blankData },
		{ flagReadMask | Shell0DspfdbkCorempProccoeffRAdr, blankData },
		{ flagReadMask | C0DspfdbkCorempProclimRAdr, blankData },
		{ flagReadMask | C0DspfdbkCorempProcsetmp0RAdr, blankData },
		{ flagReadMask | C0DspfdbkCorempProcsetmp1RAdr, blankData },
		{ flagReadMask | C0DspfdbkCorempProcsetmp2RAdr, blankData },
		{ flagReadMask | C0DspfdbkCorempProcsetmp3RAdr, blankData },
		{ flagReadMask | Digdsprsmshell1DspfdbkCorempProccoeffRAdr, blankData },
		{ flagReadMask | C1DspfdbkCorempProclimRAdr, blankData },
		{ flagReadMask | Shell1DspfdbkCorempProcsetmp0RAdr, blankData },
		{ flagReadMask | Shell1DspfdbkCorempProcsetmp1RAdr, blankData },
		{ flagReadMask | Shell1DspfdbkCorempProcsetmp2RAdr, blankData },
		{ flagReadMask | Shell1DspfdbkCorempProcsetmp3RAdr, blankData },
		{ flagReadMask | C0Cav4ElecdriveCoupleoutCouplingRAdr, blankData },
		{ flagReadMask | Rsmcav0Cav4ElecdriveCoupleophoffRAdr, blankData },
		{ flagReadMask | Cav0Cav4Elecmode0OcoupoutCouplingRAdr, blankData },
		{ flagReadMask | Rsmcav0Cav4Elecmode0OcoupophoffRAdr, blankData },
		{ flagReadMask | Cav0Cav4Elecmode1OcoupoutCouplingRAdr, blankData },
		{ flagReadMask | Cav0Cav4Elecmode1OcoupophoffRAdr, blankData },
		{ flagReadMask | C0Cav4Elecmode2OcoupoutCouplingRAdr, blankData },
		{ flagReadMask | C0Cav4Elecmode2OcoupophoffRAdr, blankData },
		{ flagReadMask | Cav1Cav4ElecdriveCoupleoutCouplingRAdr, blankData },
		{ flagReadMask | C1Cav4ElecdriveCoupleophoffRAdr, blankData },
		{ flagReadMask | C1Cav4Elecmode0OcoupoutCouplingRAdr, blankData },
		{ flagReadMask | Cav1Cav4Elecmode0OcoupophoffRAdr, blankData },
		{ flagReadMask | Cav1Cav4Elecmode1OcoupoutCouplingRAdr, blankData },
		{ flagReadMask | C1Cav4Elecmode1OcoupophoffRAdr, blankData },
		{ flagReadMask | Rsmcav1Cav4Elecmode2OcoupoutCouplingRAdr, blankData },
		{ flagReadMask | C1Cav4Elecmode2OcoupophoffRAdr, blankData },
		{ flagReadMask | Digdsprsmshell0DsplpNotchlp1AkxRAdr, blankData },
		{ flagReadMask | C0DsplpNotchlp1AkyRAdr, blankData },
		{ flagReadMask | Rsmshell0DsplpNotchlp1BkxRAdr, blankData },
		{ flagReadMask | C0DsplpNotchlp1BkyRAdr, blankData },
		{ flagReadMask | C1DsplpNotchlp1AkxRAdr, blankData },
		{ flagReadMask | Atopdigdsprsmshell1DsplpNotchlp1AkyRAdr, blankData },
		{ flagReadMask | C1DsplpNotchlp1BkxRAdr, blankData },
		{ flagReadMask | C1DsplpNotchlp1BkyRAdr, blankData },
		{ flagReadMask | AdcMmcmRAdr, blankData },
		{ flagReadMask | H0D0A0D0ARAdr, blankData },
		{ flagReadMask | H0D0A0D0ARAdr, blankData },
		{ flagReadMask | H0D0A0D0ARAdr, blankData },
		{ flagReadMask | H0D0A0D0ARAdr, blankData },
		{ flagReadMask | H0D0A0D0ARAdr, blankData },
		{ flagReadMask | H0D0A0D0ARAdr, blankData },
		{ flagReadMask | H0D0A0D0ARAdr, blankData },
		{ flagReadMask | H0D0A0D0ARAdr, blankData },
		{ flagReadMask | H0D0A0D0ARAdr, blankData },
		{ flagReadMask | BanyanMaskRAdr, blankData },
		{ flagReadMask | BitslipRAdr, blankData },
		{ flagReadMask | ClkStatusWeRAdr, blankData },
		{ flagReadMask | DigcfgidelayctrlResetRRAdr, blankData },
		{ flagReadMask | H0D0A0D0ARAdr, blankData },
		{ flagReadMask | MmcmResetRRAdr, blankData },
		{ flagReadMask | PeriphConfigRAdr, blankData },
		{ flagReadMask | PhasexTrigRAdr, blankData },
		{ flagReadMask | DigcfgrawadcTrigRAdr, blankData },
		{ flagReadMask | ScanTriggerWeRAdr, blankData },
		{ flagReadMask | ScannerDebugRAdr, blankData },
		{ flagReadMask | SyncAd7794CsetRAdr, blankData },
		{ flagReadMask | DigcfgsyncTps62210CsetRAdr, blankData },
		{ flagReadMask | AdcTestModeRAdr, blankData },
		{ flagReadMask | AdcTestResetRAdr, blankData },
		{ flagReadMask | DigdspamplitudeRAdr, blankData },
		{ flagReadMask | AverageLenRAdr, blankData },
		{ flagReadMask | BufTrigRAdr, blankData },
		{ flagReadMask | CicPeriodRAdr, blankData },
		{ flagReadMask | CicShiftRAdr, blankData },
		{ flagReadMask | CircleBufFlipRAdr, blankData },
		{ flagReadMask | DacDdsResetRAdr, blankData },
		{ flagReadMask | DigdspdacModeRAdr, blankData },
		{ flagReadMask | DdsaModuloRAdr, blankData },
		{ flagReadMask | DdsaPhstepHRAdr, blankData },
		{ flagReadMask | DigdspddsaPhstepLRAdr, blankData },
		{ flagReadMask | HistCountWStrobeRAdr, blankData },
		{ flagReadMask | LlrfDspDacEnRAdr, blankData },
		{ flagReadMask | LoAmpRAdr, blankData },
		{ flagReadMask | DigdspmoduloRAdr, blankData },
		{ flagReadMask | DigdspphaseStepHRAdr, blankData },
		{ flagReadMask | PhaseStepLRAdr, blankData },
		{ flagReadMask | CavSelRAdr, blankData },
		{ flagReadMask | PrlCfgRAdr, blankData },
		{ flagReadMask | PrcDspprlGainRAdr, blankData },
		{ flagReadMask | Beam0ModuloRAdr, blankData },
		{ flagReadMask | Rsmbeam0PhaseInitRAdr, blankData },
		{ flagReadMask | C0PhaseStepRAdr, blankData },
		{ flagReadMask | C1ModuloRAdr, blankData },
		{ flagReadMask | C1PhaseInitRAdr, blankData },
		{ flagReadMask | Rsmbeam1PhaseStepRAdr, blankData },
		{ flagReadMask | Cav4MechprngivaRAdr, blankData },
		{ flagReadMask | Rsmcav4MechprngivbRAdr, blankData },
		{ flagReadMask | Cav4MechprngrandomRunRAdr, blankData },
		{ flagReadMask | Cav0ACavoffsRAdr, blankData },
		{ flagReadMask | C0AForoffsRAdr, blankData },
		{ flagReadMask | C0ARfloffsRAdr, blankData },
		{ flagReadMask | C0AmpLpbwRAdr, blankData },
		{ flagReadMask | C0Cav4Elecfq0CoarseFreqRAdr, blankData },
		{ flagReadMask | C0Cav4Elecfq1CoarseFreqRAdr, blankData },
		{ flagReadMask | C0Cav4Elecfq2CoarseFreqRAdr, blankData },
		{ 0, 0 }, // This should stay on line 246, 176 registers from the start of this structure
		{ flagReadMask | Rsmcav0Cav4Elecmode0BeamCouplingRAdr, blankData },
		{ flagReadMask | C0Cav4Elecmode0BwRAdr, blankData },
		{ flagReadMask | C0Cav4Elecmode0DriveCouplingRAdr, blankData },
		{ flagReadMask | Atopdigdsprsmcav0Cav4Elecmode1BeamCouplingRAdr, blankData },
		{ flagReadMask | Cav0Cav4Elecmode1BwRAdr, blankData },
		{ flagReadMask | C0Cav4Elecmode1DriveCouplingRAdr, blankData },
		{ flagReadMask | Atopdigdsprsmcav0Cav4Elecmode2BeamCouplingRAdr, blankData },
		{ flagReadMask | C0Cav4Elecmode2BwRAdr, blankData },
		{ flagReadMask | C0Cav4Elecmode2DriveCouplingRAdr, blankData },
		{ flagReadMask | C0Cav4ElecmoduloRAdr, blankData },
		{ flagReadMask | Cav0Cav4ElecphaseStepRAdr, blankData },
		{ flagReadMask | C0ComprsatCtlRAdr, blankData },
		{ flagReadMask | Cav0PrngivaRAdr, blankData },
		{ flagReadMask | C0PrngivbRAdr, blankData },
		{ flagReadMask | C0PrngrandomRunRAdr, blankData },
		{ flagReadMask | C1ACavoffsRAdr, blankData },
		{ flagReadMask | Digdsprsmcav1AForoffsRAdr, blankData },
		{ flagReadMask | C1ARfloffsRAdr, blankData },
		{ flagReadMask | Rsmcav1AmpLpbwRAdr, blankData },
		{ flagReadMask | C1Cav4Elecfq0CoarseFreqRAdr, blankData },
		{ flagReadMask | C1Cav4Elecfq1CoarseFreqRAdr, blankData },
		{ flagReadMask | C1Cav4Elecfq2CoarseFreqRAdr, blankData },
		{ flagReadMask | C1Cav4Elecmode0BeamCouplingRAdr, blankData },
		{ flagReadMask | Cav1Cav4Elecmode0BwRAdr, blankData },
		{ flagReadMask | C1Cav4Elecmode0DriveCouplingRAdr, blankData },
		{ flagReadMask | C1Cav4Elecmode1BeamCouplingRAdr, blankData },
		{ flagReadMask | Rsmcav1Cav4Elecmode1BwRAdr, blankData },
		{ flagReadMask | C1Cav4Elecmode1DriveCouplingRAdr, blankData },
		{ flagReadMask | Rsmcav1Cav4Elecmode2BeamCouplingRAdr, blankData },
		{ flagReadMask | Cav1Cav4Elecmode2BwRAdr, blankData },
		{ flagReadMask | C1Cav4ElecmoduloRAdr, blankData },
		{ flagReadMask | C1Cav4ElecphaseStepRAdr, blankData },
		{ flagReadMask | Rsmcav1ComprsatCtlRAdr, blankData },
		{ flagReadMask | C1PrngivaRAdr, blankData },
		{ flagReadMask | Cav1PrngivbRAdr, blankData },
		{ flagReadMask | C1PrngrandomRunRAdr, blankData },
		{ flagReadMask | RsmdacIqPhaseRAdr, blankData },
		{ flagReadMask | C0DspchanKeepRAdr, blankData },
		{ flagReadMask | C0DspfdbkCorecoarseScaleRAdr, blankData },
		{ flagReadMask | Shell0DspfdbkCorempProcphOffsetRAdr, blankData },
		{ flagReadMask | Shell0DspfdbkCorempProcselEnRAdr, blankData },
		{ flagReadMask | C0DspfdbkCorempProcselThreshRAdr, blankData },
		{ flagReadMask | Shell0DspmoduloRAdr, blankData },
		{ flagReadMask | Shell0DspphaseStepRAdr, blankData },
		{ flagReadMask | C0DsppiezopiezoDcRAdr, blankData },
		{ flagReadMask | Shell0DsptagRAdr, blankData },
		{ flagReadMask | C0DspuseFiberIqRAdr, blankData },
		{ flagReadMask | C0DspwaveSampPerRAdr, blankData },
		{ flagReadMask | C0DspwaveShiftRAdr, blankData },
		{ flagReadMask | Shell1DspchanKeepRAdr, blankData },
		{ flagReadMask | C1DspfdbkCorecoarseScaleRAdr, blankData },
		{ flagReadMask | C1DspfdbkCorempProcphOffsetRAdr, blankData },
		{ flagReadMask | C1DspfdbkCorempProcselEnRAdr, blankData },
		{ flagReadMask | C1DspfdbkCorempProcselThreshRAdr, blankData },
		{ flagReadMask | C1DspmoduloRAdr, blankData },
		{ flagReadMask | C1DspphaseStepRAdr, blankData },
		{ flagReadMask | C1DsppiezopiezoDcRAdr, blankData },
		{ flagReadMask | C1DsptagRAdr, blankData },
		{ flagReadMask | C1DspuseFiberIqRAdr, blankData },
		{ flagReadMask | C1DspwaveSampPerRAdr, blankData },
		{ flagReadMask | Shell1DspwaveShiftRAdr, blankData },
		{ flagReadMask | AtopdigdsprewindRAdr, blankData },
		{ flagReadMask | AmpstepRAdr, blankData },
		{ flagReadMask | SsaStimEnRAdr, blankData },
		{ flagReadMask | SsaStimgPeriodRAdr, blankData },
		{ flagReadMask | SsaStimpertstepRAdr, blankData },
		{ flagReadMask | DigdsptraceKeepRAdr, blankData },
		{ flagReadMask | TraceResetWeRAdr, blankData },
		{ flagReadMask | TrigInternalRAdr, blankData },
		{ flagReadMask | TrigModeRAdr, blankData },
		{ flagReadMask | Wave0SrcRAdr, blankData },
		{ flagReadMask | Wave1SrcRAdr, blankData },
		{ flagReadMask | DomainJumpRealignRAdr, blankData },
		{ flagReadMask | IccCfgRAdr, blankData },
		{ flagReadMask | QsfpI2CRegRAdr, blankData },
		{ flagReadMask | SfpAddressSetRAdr, blankData },
		{ flagReadMask | TagNowRAdr, blankData },
	};

    printf(" polled register msg size is %d.\n", (int) PolledRegMsgSize_);
	htonFpgaRegArray(pPolledRegMsg_, PolledRegMsgSize_);

    epicsThreadSleep(defaultPollPeriod);
    printf("%s created %d parameters.\n",__PRETTY_FUNCTION__, NUM_SCLLRFPRCEXTRA_PARAMS);

	reqWaveEventId_ = epicsEventMustCreate(epicsEventEmpty);
	startWaveformRequester();

	singleMsgQueueEventId_ = epicsEventMustCreate(epicsEventEmpty);
	startSingleMessageQueuer();

    epicsThreadSleep(defaultPollPeriod);
    wakeupPoller();
    wakeupReader();
}

scllrfPRCextra::~scllrfPRCextra()
{
	isShuttingDown_ = true;
	epicsThreadSleep(0.1); // Allow threads to run and exit
	epicsEventSignal(reqWaveEventId_);
	wakeupPoller();
	wakeupReader();
	epicsThreadSleep(0.1); // Allow threads to run and exit
	wakeupPoller(); // call this twice in case the poller was never set to run
	wakeupReader();
	epicsThreadSleep(0.1); // Allow threads to run and exit
	wakeupReader();
	pasynOctetSyncIO->disconnect(pOctetAsynUser_);
	pasynCommonSyncIO->disconnectDevice(pCommonAsynUser_);
	pasynCommonSyncIO->disconnect(pCommonAsynUser_);
}


/** Called when asyn clients call pasynInt32->read().
 * \param[in] pasynUser pasynUser structure that encodes the reason and address.
 * \param[in] value Pointer to the value to read. */
asynStatus scllrfPRCextra::writeInt32(asynUser *pasynUser, epicsInt32 value)
{
	int function = pasynUser->reason;
//	int addr = 0;
	asynStatus status = asynSuccess;
    const char *paramName;
//    FpgaReg regSendBuf[2];

	epicsTimeStamp timeStamp; getTimeStamp(&timeStamp);

    /* Set the parameter in the parameter library. */
    status = (asynStatus) setIntegerParam(function, value);

    /* Fetch the parameter string name for possible use in debugging */
    getParamName(function, &paramName);
    asynPrint(pasynUser, ASYN_TRACEIO_DRIVER, "--> %s: function=%d, %s, set to %d\n",
			__PRETTY_FUNCTION__, function, paramName, value);

    if (function == p_IQBitWidth)
    {
    	wavBitWidth_ = (scllrfPRCextra::WavBitWidth) value;
    }

    scllrfAsynPortDriver::writeInt32(pasynUser, value);

	/* Do callbacks so higher layers see any changes */
	status = (asynStatus) callParamCallbacks();

    if (status)
        epicsSnprintf(pasynUser->errorMessage, pasynUser->errorMessageSize,
                  "%s: status=%d, function=%d, name=%s, value=%d",
				  __PRETTY_FUNCTION__, status, function, paramName, value);
    else
        asynPrint(pasynUser, ASYN_TRACEIO_DRIVER,
              "<-- %s: function=%d, name=%s, value=%d\n",
			  __PRETTY_FUNCTION__, function, paramName, value);
    return status;
}

/** Called when asyn clients call pasynInt32Array->write().
  * The base class implementation simply prints an error message.
  * Derived classes may reimplement this function if required.
  * \param[in] pasynUser pasynUser structure that encodes the reason and address.
  * \param[in] value Pointer to the array to write.
  * \param[in] nElements Number of elements to write. */
asynStatus scllrfPRCextra::writeInt32Array(asynUser *pasynUser, epicsInt32 *value,
                                size_t nElements)
{
	int function = pasynUser->reason;
	asynStatus status = asynSuccess;
//	int nCopy;
	FpgaReg regSendBuf[maxMsgSize/sizeof(FpgaReg)];
	unsigned int i, uOutBuffIndex;
	uint32_t uRegAddr;
    const char *paramName;

    printf("%s: %d elements\n", __PRETTY_FUNCTION__, (int) nElements);
	//getIntegerParam(P_ArrayLength, &nCopy);
	//if ((int) nElements < nCopy)
	//	nCopy = (int) nElements;

    /* Fetch the parameter string name for possible use in debugging */
    getParamName(function, &paramName);

	if(nElements < 2)
	{
		asynPrint(pasynUser, ASYN_TRACEIO_DRIVER, "%s: array with %d elements, function=%d, %s\n",
				__PRETTY_FUNCTION__, (int) nElements, function, paramName);
		return status;
	}
	else
		asynPrint(pasynUser, ASYN_TRACEIO_DRIVER, "%s: array with %d elements, function=%d, %s\n",
				__PRETTY_FUNCTION__, (int) nElements, function, paramName);

	status = functionToRegister(function, &regSendBuf[1]);
	if (status != asynSuccess)
		return status;

	uRegAddr = regSendBuf[1].addr;
	uOutBuffIndex = 1; // index of first register past the nonce

	for(i=0; i<nElements; ++i, ++uOutBuffIndex)
	{
		regSendBuf[uOutBuffIndex].data = (int32_t) value[i];
		regSendBuf[uOutBuffIndex].addr = (uint32_t) uRegAddr + i;

		// If there's more to send than will fit in the max message size, break
		// it up into chunks and send each chunk individually
		if(uOutBuffIndex == maxMsgSize/sizeof(FpgaReg)-1)
		{
			//printf("\n%s calling htonFpgaRegArray for %u registers\n", __PRETTY_FUNCTION__, uOutBuffIndex );
                        htonFpgaRegArray(regSendBuf, uOutBuffIndex);
			sendRegRequest(regSendBuf, uOutBuffIndex+1);

			if (status)
				epicsSnprintf(pasynUser->errorMessage, pasynUser->errorMessageSize,
						"%s: status=%d, function=%d, sending array segment %u of %s", __PRETTY_FUNCTION__,
						status, function, i/uOutBuffIndex +1, paramName);
			else
				asynPrint(pasynUser, ASYN_TRACEIO_DRIVER, "%s: function=%d, sending array segment %u of %s\n",
						__PRETTY_FUNCTION__, function, i/uOutBuffIndex +1, paramName);
			uOutBuffIndex = 0; // loop will increment to index of first register past the nonce
		}
	}
        //printf("\n%s calling htonFpgaRegArray for %u registers\n", __PRETTY_FUNCTION__, uOutBuffIndex );

	htonFpgaRegArray(regSendBuf, uOutBuffIndex);
	sendRegRequest(regSendBuf, uOutBuffIndex+1);

	if (status)
		epicsSnprintf(pasynUser->errorMessage, pasynUser->errorMessageSize,
				"%s: status=%d, function=%d, sent %s", __PRETTY_FUNCTION__,
				status, function, paramName);
	else
		asynPrint(pasynUser, ASYN_TRACEIO_DRIVER, "%s: function=%d, sent %s\n",
				__PRETTY_FUNCTION__, function, paramName);

	return status; //(writeArray < epicsInt32 > (pasynUser, value, nElements));
}



static void waveformRequesterC(void *drvPvt)
{
	printf("%s: starting\n", __PRETTY_FUNCTION__);
	scllrfPRCextra *pscllrfDriver = (scllrfPRCextra*)drvPvt;
	pscllrfDriver->waveformRequester();
	printf("%s: exiting\n", __PRETTY_FUNCTION__);
}

/** Starts the poller thread.
 ** Derived classes will typically call this at near the end of their constructor.
 ** Derived classes can typically use the base class implementation of the poller thread,
 ** but are free to re-implement it if necessary.
 ** \param[in] pollPeriod The time between polls. */
asynStatus scllrfPRCextra::startWaveformRequester()
{
	epicsThreadCreate("waveformRequester",
			epicsThreadPriorityMedium,
			epicsThreadGetStackSize(epicsThreadStackMedium),
			(EPICSTHREADFUNC)waveformRequesterC, (void *)this);
	return asynSuccess;
}

// When a new value for npt_ (number of points in each waveform) is calculated,
// run this to compose new waveform request messages with the new size.
void scllrfPRCextra::fillWavReqMsg()
{
	int i, segmentNum, segmentOffset;
	unsigned int addr=0, segStartAddr = wavesStart;
	FpgaReg reqWaveMsg[waveSegmentCount][waveSegmentSize];

	for(i = 0; i<4; i++)
	{
		segmentNum = 0;
		segmentOffset = 1; // Start data past the nonce
		reqWaveMsg[segmentNum][0] = {0,0};
//		printf("\n%s filling waveform request %d: [%u][%u]={0x%x,0x%x}", __PRETTY_FUNCTION__, i, segmentNum, 0,
//				addr, reqWaveMsg[segmentNum][0].data);
		for (addr = segStartAddr; addr < segStartAddr+npt_; addr++, segmentOffset++)
		{
			reqWaveMsg[segmentNum][segmentOffset].addr = (uint32_t) (addr | flagReadMask);
			reqWaveMsg[segmentNum][segmentOffset].data = blankData + addr;
//			printf(", [%u][%u]={0x%x,0x%x}", segmentNum, segmentOffset,
//					addr, reqWaveMsg[segmentNum][segmentOffset].data);

			// If there's more to send than will fit in the max message size, break
			// it up into chunks and send each chunk individually
			if(segmentOffset == maxMsgSize/sizeof(FpgaReg)-1)
			{
				segmentNum++;
				reqWaveMsg[segmentNum][0] = {0,0};
//				printf(" %lu bytes in this segment.\n", (segmentOffset +1) * sizeof (FpgaReg));
				segmentOffset = 0; // will be incremented to 1 at the top of the loop
//				printf("\nfilling waveform request %d: [%u][%u]={0x0,0x0}", i, segmentNum, segmentOffset);
			}
		}
//		printf(" %lu of %lu bytes filled in this segment.\n",
//				(segmentOffset +1) * sizeof (FpgaReg), waveSegmentSize * sizeof (FpgaReg));

		// Each segment has unused elements at the end. Safest to convert whole thing.
		//printf("\n%s calling htonFpgaRegArray for waveform %u, %u registers\n", __PRETTY_FUNCTION__, i, waveSegmentCount * waveSegmentSize );

		htonFpgaRegArray(reqWaveMsg[0], waveSegmentCount * waveSegmentSize);

		switch (i)
		{
		case 0:
			std::copy(&reqWaveMsg[0][0], &reqWaveMsg[0][0]+waveSegmentCount * waveSegmentSize,
					&pReqIQ16bAMsg_[0][0]); // Canned message to request 16 bit I/Q data, first npt_ points
			break;
		case 1:
			std::copy(&reqWaveMsg[0][0], &reqWaveMsg[0][0]+waveSegmentCount * waveSegmentSize,
					&pReqIQ16bBMsg_[0][0]); // Canned message to request 16 bit I/Q data, last npt_ points
			break;
		case 2:
			std::copy(&reqWaveMsg[0][0], &reqWaveMsg[0][0]+waveSegmentCount * waveSegmentSize,
					&pReqI22bMsg_[0][0]); // Canned message to request 22 bit I data
			break;
		case 3:
			std::copy(&reqWaveMsg[0][0], &reqWaveMsg[0][0]+waveSegmentCount * waveSegmentSize,
					&pReqQ22bMsg_[0][0]); // Canned message to request 22 bit Q data
			break;
		}
//		printf("Filled up %d of %d segments, last one with %d points\n",
//				segmentNum, waveSegmentCount, segmentOffset);
//		printf("Setting start address of next waveform segment to 0x%x\n", addr);
		segStartAddr = addr;
	}
}


void scllrfPRCextra::reqOneWaveform(FpgaReg (*readWaveformsMsg)[waveSegmentSize])
{
	int regsLeftToSend = npt_;
	uint i;

//	printf(" --> %s\n", __PRETTY_FUNCTION__);
//	printf("%s waveSegmentSize = %u, waveSegmentCount = %u, regsLeftToSend = %d\n",
//			__PRETTY_FUNCTION__, waveSegmentSize, waveSegmentCount, regsLeftToSend);
//	printf("%s waveBufferRegCount = %u, waveBuffSize = %u, waveSegmentCount = %d\n",
//			__PRETTY_FUNCTION__, waveBufferRegCount, waveBuffSize, waveSegmentCount);
	for (i=0; i<waveSegmentCount; ++i)
	{
		if(regsLeftToSend > (int) (maxMsgSize/sizeof(FpgaReg)))
		{
			sendRegRequest(&readWaveformsMsg[i][0], maxMsgSize/sizeof(FpgaReg));
			regsLeftToSend -= maxMsgSize/sizeof(FpgaReg) - 1;
//			printf("%s sent segment %u, regsLeftToSend = %d\n", __PRETTY_FUNCTION__, i, regsLeftToSend);
		}
		else
		{
			sendRegRequest(&readWaveformsMsg[i][0], regsLeftToSend + 1);
//			printf("%s sent segment %u, last %d registers\n", __PRETTY_FUNCTION__, i, regsLeftToSend);
			break;
		}
	}
//	printf(" <-- %s\n", __PRETTY_FUNCTION__);
}

void scllrfPRCextra::waveformRequester()
{
	epicsEventWaitStatus status;
//	FpgaReg traceAck[5] =
//	{
//			{0,0},
//			{TraceResetWeWAdr,1},
//			{BufTrigWAdr,0},
//			{BufTrigWAdr,1},
//			{BufTrigWAdr,0}
//	};

	FpgaReg traceAck[5] =
	{
			{0,0},
			{CircleBufFlipWAdr,1},
			{CircleBufFlipWAdr,2},
			{CircleBufFlipRAdr | flagReadMask,1},
			{CircleBufFlipRAdr | flagReadMask,2},
	};
	//printf("\n%s calling htonFpgaRegArray for %u registers of traceAck\n", __PRETTY_FUNCTION__, 5 );
    htonFpgaRegArray(traceAck, sizeof(traceAck)/sizeof(FpgaReg));
    //htonFpgaRegArray(traceAck, 5);
    sendRegRequest(traceAck, sizeof(traceAck)/sizeof(FpgaReg));

	// Main polling loop
	while (1)
	{
		status = epicsEventWait(reqWaveEventId_);

		if (isShuttingDown_)
		{
			break;
		}

		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: signaled by reqWaveEventId_\n", __PRETTY_FUNCTION__);

		// avoid divide by 0 errors when waveforms are inactive
		if (nchan_ <=0 || npt_ <=0)
		{
			epicsThreadSleep(pollPeriod_);
		}
		else {
			/* We got an event, rather than a timeout.
			 **/
			switch (wavBitWidth_)
			{
			case read16bit:
				reqOneWaveform(pReqIQ16bAMsg_);
				reqOneWaveform(pReqIQ16bBMsg_);
				break;
			case read22bit:
				reqOneWaveform(pReqI22bMsg_);
				reqOneWaveform(pReqQ22bMsg_);
				break;
			default:
				printf("%s: impossible bit width\n", __PRETTY_FUNCTION__);
				break;
			}

			newWaveRead_ = newWaveAvailable_; // Indicate that we got the signal
			sendRegRequest(traceAck, sizeof(traceAck)/sizeof(FpgaReg));
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
					"%s: done sending waveform request\n", __PRETTY_FUNCTION__);
		}
	}
	//	printf("%s: exiting\n", __PRETTY_FUNCTION__);
}

template <typename T, unsigned B>
inline T signextend(const T x)
{
  struct {T x:B;} s;
  return s.x = x;
}

// parse register data, write to array PV
asynStatus scllrfPRCextra::processWaveReadback(const FpgaReg *pFromFpga)
{
	// avoid divide by 0 errors when waveforms are inactive
	if (nchan_ <=0)
	{
//		printf("%s can't process waveform data with 0 active channels\n", __PRETTY_FUNCTION__);
		return asynError;
	}
	if (npt_ <=0)
	{
		printf("%s waveform length set to %u but array index is %u\n",
				__PRETTY_FUNCTION__, (unsigned int) npt_, pFromFpga->addr);
		return asynError;
	}

//	printf("--> %s\n", __PRETTY_FUNCTION__);
	unsigned int bufferOffset = (pFromFpga->addr & addrMask) - wavesStart;
	// additional base offsets
	//   0 * npt  16-bit I and Q
	//   1 * npt  16-bit I and Q
	//   2 * npt  22-bit I
	//   3 * npt  22-bit Q
	unsigned int bufferNumber = bufferOffset / npt_; // of the 4 buffers above, which range are we in?
	unsigned int bufferBase = npt_ * bufferNumber; // in bufferNumber, base address offset
	unsigned int waveOffset = (bufferOffset - bufferBase);
	unsigned int waveNumber = waveOffset % nchan_;
	unsigned int waveIndex = waveOffset / nchan_;
	unsigned int i;
//	printf("%s bufferOffset = %u, npt_ = %u, waveNumber = %u waveIndex =%u\n", __PRETTY_FUNCTION__, bufferOffset, npt_, waveNumber, waveIndex);

	switch (bufferNumber)
	{
	case 0: //TODO: verify the packing of the bits for 16 bit data
		pWave16bitI_[waveNumber][waveIndex] = (epicsInt16) pFromFpga->data;
		pWave16bitQ_[waveNumber][waveIndex] = (epicsInt16) (pFromFpga->data >> 16);
		// Amplitude = sqrt(I^2+Q^2)
		//pWave16bitA_[waveNumber][waveIndex] = (epicsInt16) sqrt(pWave16bitI_[waveNumber][waveIndex]^2+pWave16bitQ_[waveNumber][waveIndex]^2);
		// phase = arctan(Q/I)
		break;

	case 1:
		waveIndex += npt_; // continued from addresses in "case 0"
		pWave16bitI_[waveNumber][waveIndex] = (epicsInt16) pFromFpga->data;
		pWave16bitQ_[waveNumber][waveIndex] = (epicsInt16) (pFromFpga->data >> 16);
		if (waveOffset +1 == npt_) // if this is the last point of the waveform
		{
			setIntegerParam(p_IQ16BitNELM, npt_ * 2/nchan_);
			for (i=0; i<8; ++i)
			{
				if(i<nchan_)
				{
					doCallbacksInt16Array(pWave16bitI_[i], 2*npt_/nchan_, p_WaveformI16Bit, i);
					doCallbacksInt16Array(pWave16bitQ_[i], 2*npt_/nchan_, p_WaveformQ16Bit, i);
				} else { // clear inactive channels
					doCallbacksInt16Array(pWave16bitI_[i], 0, p_WaveformI16Bit, i);
					doCallbacksInt16Array(pWave16bitQ_[i], 0, p_WaveformQ16Bit, i);
				}
			}
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
					"%s: got last waveform datapoint. Publishing.\n", __PRETTY_FUNCTION__);
		}
		break;

	case 2:
		pWave22bitI_[waveNumber][waveIndex] =
                     ((epicsInt32) pFromFpga->data) >> 10;
        //             (epicsInt32) signextend<signed int,22>(pFromFpga->data);

		if (waveOffset +1 == npt_) // if this is the last point of the waveform
		{
			setIntegerParam(p_IQ22BitNELM, npt_/nchan_);
			for (i=0; i<8; ++i)
			{
				if(i<nchan_)
				{
					doCallbacksInt32Array(pWave22bitI_[i], npt_/nchan_, p_WaveformI22Bit, i);
				} else { // clear inactive channels
					doCallbacksInt32Array(pWave22bitI_[i], 0, p_WaveformI22Bit, i);
				}
			}
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
					"%s: got last waveform datapoint. Publishing.\n", __PRETTY_FUNCTION__);
		}
		break;

	case 3:
		pWave22bitQ_[waveNumber][waveIndex] =
                     ((epicsInt32) pFromFpga->data) >> 10;
        //             (epicsInt32) signextend<signed int,22>(pFromFpga->data);
		if (waveOffset +1 == npt_) // if this is the last point of the waveform
		{
			setIntegerParam(p_IQ22BitNELM, npt_/nchan_);
			for (i=0; i<8; ++i)
			{
				if(i<nchan_)
				{
					doCallbacksInt32Array(pWave22bitQ_[i], npt_/nchan_, p_WaveformQ22Bit, i);
				} else { // clear inactive channels
					doCallbacksInt32Array(pWave22bitQ_[i], 0, p_WaveformQ22Bit, i);
				}
			}
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
					"%s: got last waveform datapoint. Publishing.\n", __PRETTY_FUNCTION__);
		}
		break;

	}

//	printf("<-- %s\n", __PRETTY_FUNCTION__);
	return asynSuccess;
}

//asynStatus scllrfPRC::catGitSHA1()
//{
//	int oneByte;
//	int i;
//	asynStatus status;
//
//	strGitSHA1.str("");
//	strGitSHA1.clear();
//	strGitSHA1<<std::hex;
//
////	for (i=p_GitSHA1a; i<=p_GitSHA1t; i++)
////	{
////		status = (asynStatus) getIntegerParam(i, &oneByte);
////		strGitSHA1<< std::setw(2) << oneByte;
////	}
////	// used with stringin reccord, which unfortunately can only handle 19 of the 20 characters
////	status = setStringParam(p_GitSHA1, strGitSHA1.str().c_str());
//
//	return asynSuccess;
//}


static void singleMessageQueuerC(void *drvPvt)
{
	printf("%s: starting\n", __PRETTY_FUNCTION__);
	scllrfPRCextra *pscllrfDriver = (scllrfPRCextra*)drvPvt;
	pscllrfDriver->waveformRequester();
	printf("%s: exiting\n", __PRETTY_FUNCTION__);
}

/** Starts the poller thread.
 ** Derived classes will typically call this at near the end of their constructor.
 ** Derived classes can typically use the base class implementation of the poller thread,
 ** but are free to re-implement it if necessary.
 ** \param[in] pollPeriod The time between polls. */
asynStatus scllrfPRCextra::startSingleMessageQueuer()
{
	epicsThreadCreate("singleMessageQueuer",
			epicsThreadPriorityMedium,
			epicsThreadGetStackSize(epicsThreadStackMedium),
			(EPICSTHREADFUNC)singleMessageQueuerC, (void *)this);
	return asynSuccess;
}


void scllrfPRCextra::singleMessageQueuer()
{
//	epicsEventWaitStatus status;
//	static FpgaReg traceAck[] =
//	{
//			{0,0},
////			{TraceResetWeWAdr,1},
//			{BufTrigWAdr,0},
//			{BufTrigWAdr,1},
//			{BufTrigWAdr,0}
//	};
//	//printf("\n%s calling htonFpgaRegArray for %u registers of traceAck\n", __PRETTY_FUNCTION__, 5 );
//    htonFpgaRegArray(traceAck, sizeof(traceAck)/sizeof(FpgaReg));
//
//	// Main polling loop
//	while (1)
//	{
//		status = epicsEventWait(reqWaveEventId_);
//
//		if (isShuttingDown_)
//		{
//			break;
//		}
//
//		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
//				"%s: signaled by reqWaveEventId_\n", __PRETTY_FUNCTION__);
//
//		// avoid divide by 0 errors when waveforms are inactive
//		if (nchan_ <=0 || npt_ <=0)
//		{
//			epicsThreadSleep(pollPeriod_);
//		}
//		else {
//			/* We got an event, rather than a timeout.
//			 **/
//			switch (wavBitWidth_)
//			{
//			case read16bit:
//				reqOneWaveform(pReqIQ16bAMsg_);
//				reqOneWaveform(pReqIQ16bBMsg_);
//				break;
//			case read22bit:
//				reqOneWaveform(pReqI22bMsg_);
//				reqOneWaveform(pReqQ22bMsg_);
//				break;
//			default:
//				printf("%s: impossible bit width\n", __PRETTY_FUNCTION__);
//				break;
//			}
//
//			newWaveRead_ = newWaveAvailable_; // Indicate that we got the signal
//			sendRegRequest(traceAck, sizeof(traceAck)/sizeof(FpgaReg));
//			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
//					"%s: done sending waveform request\n", __PRETTY_FUNCTION__);
//		}
//	}
	//	printf("%s: exiting\n", __PRETTY_FUNCTION__);
}

/**  Extract register address and data from the received message and set the appropriate
 * asyn parameter.
 * Some registers have a "new waveform data ready" flag. If they have this and it is set,
 * set weveIsReady to true.
 * Note: This function should not set waveIsReady to false. That is done by a loop in the
 * calling function.
* \param[in] pFromFpga Data returned from the FPGA for a single register
* \param[in] waveIsReady A flag that gets set to true if the appropriate bit was set by the FPGA
*/
asynStatus scllrfPRCextra::processRegReadback(const FpgaReg *pFromFpga, bool &waveIsReady)
{
//	unsigned int i;
	asynStatus status = asynSuccess;
	assert(pFromFpga->addr&flagReadMask); // This function is only for read registers
	epicsInt32 errorCount;
	epicsInt32 tmpData;
	int32_t signExtBits = 0;

	/* Map address to parameter, set the parameter in the parameter library. */
	switch (pFromFpga->addr)
    {
    case TraceStatus1RAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_TraceStatus1R,
				(pFromFpga->data & TraceStatus1Mask));
		if (pFromFpga->data & waveIsReadyMask)
		{
			waveIsReady = true;
		}
		// Calculate number of points per waveform, and update request
		// waveform messages if it has changed.
		if(npt_ != (size_t) (1 << ((pFromFpga->data & nptMask)>> 24)))
		{
			npt_ = 1 << ((pFromFpga->data & nptMask)>> 24);
			//XXXX Testing by making the waveform short
			//npt_ = 4095;
			if(npt_ > waveSegmentCount * (waveSegmentSize - 1)) // protect against register saying more points than buffer space
			{
				npt_ = waveSegmentCount * (waveSegmentSize - 1);
			}
			fillWavReqMsg();
		}
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				TraceStatus1RString,
				(unsigned ) pFromFpga->data & TraceStatus1Mask);
	break;

    case DigdsptraceKeepRAdr|flagReadMask:
	tmpData = pFromFpga->data & DigdsptraceKeepMask;
//    printf("%s got data 0x%x for DigdsptraceKeepRAdr\n",__PRETTY_FUNCTION__,tmpData);
		status = (asynStatus) setIntegerParam(p_DigdsptraceKeepR,
				(pFromFpga->data & DigdsptraceKeepMask));
		// Count the number of bits set
		for (nchan_ = 0; tmpData; nchan_++)
		{
		  tmpData &= tmpData - 1; // clear the least significant bit set
		}
		setIntegerParam(p_IQNActive, nchan_);
//	    printf("%s DigdsptraceKeepRAdr says %d active channels\n",__PRETTY_FUNCTION__,nchan_);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigdsptraceKeepRString,
				(unsigned ) pFromFpga->data & DigdsptraceKeepMask);
	break;

    case CircleBufFlipRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_CircleBufFlipR,
				(pFromFpga->data & CircleBufFlipMask));
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				CircleBufFlipRString,
				(unsigned ) pFromFpga->data & CircleBufFlipMask);
	break;

    case LlrfCircleReadyRAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_LlrfCircleReadyR,
				(pFromFpga->data & LlrfCircleReadyMask));
		if ((pFromFpga->data & 0x1) || (pFromFpga->data & 0x2))
		{
			waveIsReady = true;
		}
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				LlrfCircleReadyRString,
				(unsigned ) pFromFpga->data & LlrfCircleReadyMask);
	break;

	default:
		if( wavesStart <= (pFromFpga->addr & addrMask) && (pFromFpga->addr & addrMask) <= wavesEnd )
		{
			//printf("%s waveform addres 0x%x, value %d\n", __PRETTY_FUNCTION__, (pFromFpga->addr & addrMask), pFromFpga->data);
			processWaveReadback(pFromFpga);
		}
		else
		{
                       // printf("%s passing processing of register 0c%x to parent class\n", __PRETTY_FUNCTION__, (pFromFpga->addr & addrMask));
			status = scllrfPRCDriver::processRegReadback(pFromFpga, waveIsReady);
		}
		break;
    }

    return status;
}


/**  Extract register address and data from the received message and set the appropriate
 * asyn parameter.
 * Some registers have a "new waveform data ready" flag. If they have this and it is set,
 * set weveIsReady to true.
 * Note: This function should not set waveIsReady to false. That is done by a loop in the
 * calling function.
* \param[in] pFromFpga Data returned from the FPGA for a single register
* \param[in] waveIsReady A flag that gets set to true if the appropriate bit was set by the FPGA
*/
asynStatus scllrfPRCextra::processRegWriteResponse(const FpgaReg *pFromFpga)
{
	asynStatus status = asynSuccess;
	epicsInt32 valueSet[maxMsgSize/sizeof(FpgaReg)]; // Put the value sent to the FPGA here for comparison
//	epicsUInt32 uValueSet;
	epicsInt32 tmpData;
	epicsInt32 errorCount;
//  variables that may be useful for checking array data
//	asynUser *pAsynArrayUser;
//	unsigned int i;
	assert(!(pFromFpga->addr&flagReadMask)); // This function is only for read registers

	/* Map address to parameter, set the parameter in the parameter library. */
	switch (pFromFpga->addr)
    {
    case BufTrigWAdr:
		status = (asynStatus) getIntegerParam(p_BufTrigW, valueSet);
		if( (valueSet[0] & BufTrigMask) == (pFromFpga->data & BufTrigMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				BufTrigWString, (unsigned ) pFromFpga->data & BufTrigMask);
		else
		{
			// We don't care, since this is typically part of a canned sequence of writes
		}

		break;
    case DigdsptraceKeepWAdr:
		status = (asynStatus) getIntegerParam(p_DigdsptraceKeepW, valueSet);
		if( (valueSet[0] & DigdsptraceKeepMask) == (pFromFpga->data & DigdsptraceKeepMask))
		{		// Count the number of bits set
			tmpData = (pFromFpga->data & DigdsptraceKeepMask);
			for (nchan_ = 0; tmpData; nchan_++)
			{
			  tmpData &= tmpData - 1; // clear the least significant bit set
			}
			setIntegerParam(p_IQNActive, nchan_);
		    printf("%s DigdsptraceKeepWAdr says %d active channels\n",__PRETTY_FUNCTION__,nchan_);

			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DigdsptraceKeepWString, (unsigned ) pFromFpga->data & DigdsptraceKeepMask);
		}
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				DigdsptraceKeepWString, valueSet[0] & DigdsptraceKeepMask, (unsigned ) pFromFpga->data & DigdsptraceKeepMask);
			status = asynError;
			setParamStatus(p_DigdsptraceKeepW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case TraceResetWeWAdr:
		status = (asynStatus) getIntegerParam(p_TraceResetWeW, valueSet);
		if( (valueSet[0] & TraceResetWeMask) == (pFromFpga->data & TraceResetWeMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				TraceResetWeWString, (unsigned ) pFromFpga->data & TraceResetWeMask);
		else
		{
			// We don't care, since there are typically several writes to this per message: 0, 1, 0
		}

		break;
    case CircleBufFlipWAdr:
		status = (asynStatus) getIntegerParam(p_CircleBufFlipW, valueSet);
		if( (valueSet[0] & CircleBufFlipMask) == (pFromFpga->data & CircleBufFlipMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				CircleBufFlipWString, (unsigned ) pFromFpga->data & CircleBufFlipMask);
		else
		{
			// That's normal for this register
		}

		break;
	default:
// TODO: Add checking for arrays. Until then, we'll hit "default" for array values, so not really an error. GWB 8-23-2016
//		getIntegerParam(p_CommErrorCount, &errorCount);
//		setIntegerParam(p_CommErrorCount, errorCount + 1);
		status = scllrfPRCDriver::processRegWriteResponse(pFromFpga);

		break;
    }

	// TODO: handle arrays

    return status;
}



extern "C" {

/* Configuration routine.  Called directly, or from the iocsh function below */

/** EPICS iocsh callable function to call constructor for the scllrfPRC class.
 * \param[in] portName The name of the asyn port driver to be created.
 * \param[in] netPortName The name of the asynIPport this will use to communicate */
int scllrfPRCextraConfigure(const char *drvPortName, const char *netPortName)
{
	new scllrfPRCextra(drvPortName, netPortName);
	return asynSuccess;
}


/* EPICS iocsh shell commands */

static const iocshArg initArg0 = { "drvPortName",iocshArgString};
static const iocshArg initArg1 = { "IP port name",iocshArgString};
static const iocshArg * const initArgs[] = {&initArg0,
		&initArg1};

/* NOTE: The command name defined below, "scllrfPRCConfigure", conflicts
 * with the same command defined in the base class if both register functions
 * are left in the dbd file. If it's renamed here, it breaks the macro definition
 * scheme used in iocBoot/common/regInterface.cmd. Is there a better way to resolve
 * the conflict than this duplicate name and leaving scllrfPRCRegister out of the
 * dbd file?
 */
static const iocshFuncDef initFuncDef = {"scllrfPRCConfigure",2,initArgs};
static void initCallFunc(const iocshArgBuf *args)
{
	scllrfPRCextraConfigure(args[0].sval, args[1].sval);
}

void scllrfPRCextraRegister(void)
{
	iocshRegister(&initFuncDef,initCallFunc);
}

epicsExportRegistrar(scllrfPRCextraRegister);

}




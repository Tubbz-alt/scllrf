
/**
 *-----------------------------------------------------------------------------
 * Title      : superconducting low level RF EPICS interface
 * ----------------------------------------------------------------------------
 * File       : scllrfAsynPortDriver.cpp
 * Author     : Garth Brown, gwbrown@slac.stanford.edu
 * Created    : June 17, 2016
 * Last update: September 6, 2016
 * ----------------------------------------------------------------------------
 * Description:
 * Prototype for FPGA register access to FPGAs using protocol defined in papers
 * given to SLAC by LBNL (Larry Doolittle). Uses asynPortDriver interface. Some of this
 * should eventually be autogenerated from json files or some such, and templates.
 *
 * ----------------------------------------------------------------------------
 * This file is part of LCLS II. It is subject to
 * the license terms in the LICENSE.txt file found in the top-level directory
 * of this distribution and at:
    * https://confluence.slac.stanford.edu/display/ppareg/LICENSE.html.
 * No part of LCLS II, including this file, may be
 * copied, modified, propagated, or distributed except according to the terms
 * contained in the LICENSE.txt file.
 * ----------------------------------------------------------------------------
**/

#include "scllrfPRCextra.h"

#include <asynOctetSyncIO.h>
#include <asynCommonSyncIO.h>
#include <limits>
#include <netinet/in.h>
#include <iostream>
#include <bitset>
using namespace std;

const unsigned scllrfPRCextra::maxChannel = 1024; // for small waveforms, divided into one "channel"/PV per element, this is the size limit

const double scllrfPRCextra::LOfrequency = 1.320e9;
const double scllrfPRCextra::ADCfrequency = LOfrequency/14;

const char *scllrfPRCextra::IfFreqString = "IF_FREQ";
/* Registers */

// I and Q waveforms
const char *scllrfPRCextra::WaveformI16BitString = "WAVEFORM_I_16_BIT";
const char *scllrfPRCextra::WaveformQ16BitString = "WAVEFORM_Q_16_BIT";
const char *scllrfPRCextra::WaveformI22BitString = "WAVEFORM_I_22_BIT";
const char *scllrfPRCextra::WaveformQ22BitString = "WAVEFORM_Q_22_BIT";

// Amplitude and Phase waveforms
const char *scllrfPRCextra::WaveformA16BitString = "WAVEFORM_A_16_BIT";
const char *scllrfPRCextra::WaveformP16BitString = "WAVEFORM_P_16_BIT";
const char *scllrfPRCextra::WaveformA22BitString = "WAVEFORM_A_22_BIT";
const char *scllrfPRCextra::WaveformP22BitString = "WAVEFORM_P_22_BIT";

// Binary 0 for 22 bit data, 1 for 16 bit data
const char *scllrfPRCextra::IQBitWidthString = "I_Q_BIT_WIDTH";
// Number of active waveforms, from 0 to 8
const char *scllrfPRCextra::IQNActiveString = "I_Q_N_ACTIVE";
// A buffer holds all active waveforms while remaining the same size.
// NELM is the size of each active waveform, so NELM * N_ACTIVE = total bufffer size
const char *scllrfPRCextra::IQ16BitNELMString = "I_Q_16BIT_NELM";
const char *scllrfPRCextra::IQ22BitNELMString = "I_Q_22BIT_NELM";

// Circle buffer I/Q data
const char *scllrfPRCextra::Circ0BufChanEnableString = "CIRC_0_BUF_CHAN_ENABLE";
const char *scllrfPRCextra::Circ1BufChanEnableString = "CIRC_1_BUF_CHAN_ENABLE";
const char *scllrfPRCextra::Circ0NActiveString = "CIRC_0_N_ACTIVE";
const char *scllrfPRCextra::Circ1NActiveString = "CIRC_1_N_ACTIVE";
const char *scllrfPRCextra::CircIQBuf0IString = "CIRC_IQ_BUF_0_I";
const char *scllrfPRCextra::CircIQBuf0QString = "CIRC_IQ_BUF_0_Q";
const char *scllrfPRCextra::CircIQBuf0AString = "CIRC_IQ_BUF_0_A";
const char *scllrfPRCextra::CircIQBuf0PString = "CIRC_IQ_BUF_0_P";
const char *scllrfPRCextra::CircIQBuf1IString = "CIRC_IQ_BUF_1_I";
const char *scllrfPRCextra::CircIQBuf1QString = "CIRC_IQ_BUF_1_Q";
const char *scllrfPRCextra::CircIQBuf1AString = "CIRC_IQ_BUF_1_A";
const char *scllrfPRCextra::CircIQBuf1PString = "CIRC_IQ_BUF_1_P";
const char *scllrfPRCextra::CircIQFaultBuf0IString = "CIRC_IQ_FAULT_BUF_0_I";
const char *scllrfPRCextra::CircIQFaultBuf0QString = "CIRC_IQ_FAULT_BUF_0_Q";
const char *scllrfPRCextra::CircIQFaultBuf0AString = "CIRC_IQ_FAULT_BUF_0_A";
const char *scllrfPRCextra::CircIQFaultBuf0PString = "CIRC_IQ_FAULT_BUF_0_P";
const char *scllrfPRCextra::CircIQFaultBuf1IString = "CIRC_IQ_FAULT_BUF_1_I";
const char *scllrfPRCextra::CircIQFaultBuf1QString = "CIRC_IQ_FAULT_BUF_1_Q";
const char *scllrfPRCextra::CircIQFaultBuf1AString = "CIRC_IQ_FAULT_BUF_1_A";
const char *scllrfPRCextra::CircIQFaultBuf1PString = "CIRC_IQ_FAULT_BUF_1_P";

const char *scllrfPRCextra::Shell0CircleCountRString = "SHELL_0_CIRCLE_COUNT_R";
const char *scllrfPRCextra::Shell0CircleStatRString = "SHELL_0_CIRCLE_STAT_R";
const char *scllrfPRCextra::Shell0MinsRString = "SHELL_0_MINS_R";
const char *scllrfPRCextra::Shell0MaxsRString = "SHELL_0_MAXS_R";
const char *scllrfPRCextra::Shell0TagNowRString = "SHELL_0_TAG_NOW_R";
const char *scllrfPRCextra::Shell0TagOldRString = "SHELL_0_TAG_OLD_R";
const char *scllrfPRCextra::Shell0TimeStampHighRString = "SHELL_0_TIME_STAMP_HIGH_R";
const char *scllrfPRCextra::Shell0TimeStampLowRString = "SHELL_0_TIME_STAMP_LOW_R";
const char* scllrfPRCextra::Shell0TimeStepString = "SHELL_0_TIME_STEP";

const char *scllrfPRCextra::Shell1CircleCountRString = "SHELL_1_CIRCLE_COUNT_R";
const char *scllrfPRCextra::Shell1CircleStatRString = "SHELL_1_CIRCLE_STAT_R";
const char *scllrfPRCextra::Shell1MinsRString = "SHELL_1_MINS_R";
const char *scllrfPRCextra::Shell1MaxsRString = "SHELL_1_MAXS_R";
const char *scllrfPRCextra::Shell1TagNowRString = "SHELL_1_TAG_NOW_R";
const char *scllrfPRCextra::Shell1TagOldRString = "SHELL_1_TAG_OLD_R";
const char *scllrfPRCextra::Shell1TimeStampHighRString = "SHELL_1_TIME_STAMP_HIGH_R";
const char *scllrfPRCextra::Shell1TimeStampLowRString = "SHELL_1_TIME_STAMP_LOW_R";
const char* scllrfPRCextra::Shell1TimeStepString = "SHELL_1_TIME_STEP";


// Constants used in llrf_close_loop.py
//    cic_base_period = 33  # default parameter in llrf_dsp.v
//    Tstep = 14./1320e6
//    in_level_0 = 5000
const unsigned CircleWave::CIC_PERIOD = 33;
const unsigned CircleWave::SHIFT_BASE = 4;
//const float CircleWave::CLK_FREQ = 499.64*11/12/2*1000000; // Du's value
const float CircleWave::CLK_FREQ = 1320e6/14; // LCLS-II value from app.py

const unsigned CircleWave::SLOW_OFFSET = 17; // register address offset from start of slow buffer to the data we care about
const unsigned scllrfPRCextra::circleBufRegCount = sizeof(bufShell0CircleData)/sizeof(*bufShell0CircleData);


//const unsigned CircleWave::circleBufRegCount = scllrfPRCextra::circleBufRegCount;
//const unsigned CircleWave::maxWavesCount = 12; // max channels, max number of waveforms interlaced in waveform buffer
const unsigned CircleWave::reqBufSegmentCount = (circleBufRegCount + maxRegPerMsg -1)/maxRegPerMsg; // # of UDP requests, divide and round up, ~48
const unsigned CircleWave::reqMsgSize = circleBufRegCount + reqBufSegmentCount; // All register addresses plus nonce space
const unsigned CircleWave::slowDataBuffRegCount = 128; // 128 registers
const unsigned CircleWave::slowDataBuffSize = slowDataBuffRegCount + nonceSize; // 128 registers and the nonce

CircleWave::CircleWave(scllrfPRCextra *pDriver, unsigned int waveAddr, unsigned int slowAddr, int *rawParamIndex,
		int *iParamIndex, int *qParamIndex, int *aParamIndex, int *pParamIndex,
		int *iFaultParamIndex, int *qFaultParamIndex, int *aFaultParamIndex, int *pFaultParamIndex, int *slowDataParamIndex,
		int *circleCountParamIndex, int *circleStatParamIndex, int *minsParamIndex, int *maxsParamIndex, int *tagNowParamIndex,
		int *tagOldParamIndex, int *timeStampHighParamIndex, int *timeStampLowParamIndex,
		epicsInt32 *readBuffer, FpgaReg *requestMsg, epicsUInt8 *slowData, FpgaReg *reqSlowDataMsg) :
		nChan_(0), chanKeep_(0), waveReadback_(readBuffer), pDriver_(pDriver), pRequestMsg_(requestMsg),
		readInProgress_(false), regStartAddr_((uint32_t) waveAddr), regEndAddr_((uint32_t) waveAddr + circleBufRegCount -1),
		iParamIndex_(iParamIndex), qParamIndex_(qParamIndex), aParamIndex_(aParamIndex), pParamIndex_(pParamIndex),
		iFaultParamIndex_(iFaultParamIndex), qFaultParamIndex_(qFaultParamIndex), aFaultParamIndex_(aFaultParamIndex),
		pFaultParamIndex_(pFaultParamIndex), rawParamIndex_(rawParamIndex), slowDataParamIndex_(slowDataParamIndex),
		circleCountParamIndex_(circleCountParamIndex), circleStatParamIndex_(circleStatParamIndex),
		minsParamIndex_(minsParamIndex), maxsParamIndex_(maxsParamIndex), tagNowParamIndex_(tagNowParamIndex),
		tagOldParamIndex_(tagOldParamIndex), timeStampHighParamIndex_(timeStampHighParamIndex),
		timeStampLowParamIndex_(timeStampLowParamIndex), faultAddr_(0), fault_(0), wrap_(0), tagMismatch_(0),
		lastCount_(0), newCount_(0), tag_(5), timeStamp_(0), slowData_(slowData), pReqSlowDataMsg_(reqSlowDataMsg), slowAddr_(slowAddr), gain_(0)
{
	unsigned int i;
	for (i = 0; i < maxWavesCount; i++)
	{
		std::fill(pIQBuf_[i], pIQBuf_[i] + circleBufRegCount, 0);
	}
	for (i = 0; i < maxWavesCount / 2; i++)
	{
		std::fill(pABuf_[i], pABuf_[i] + circleBufRegCount, 0);
		std::fill(pPBuf_[i], pPBuf_[i] + circleBufRegCount, 0);
	}
}

/** Constructor for the scllrfPRC class.
 * Calls constructor for the asynPortDriver base class.
 * \param[in] portName The name of the asyn port driver to be created.
 * \param[in] path The path to the peripherial as built by the builder api
 * \param[in] nelms The number of elements of this device (max addr)
 * \paarm[in] nEntries The number of asyn params to be created for each device
 *
 * */
scllrfPRCextra::scllrfPRCextra(const char *drvPortName, const char *netPortName)
: scllrfPRCDriver(drvPortName, netPortName, maxChannel, NUM_SCLLRFPRCEXTRA_PARAMS),
	newCircIQBufAvailable_(0), newCircIQBufRead_ (0),
	shell0CircBuf_(this, Shell0CircleDataRAdr, Shell0SlowDataRAdr, &p_Shell0CircleDataWav,
			&p_CircIQBuf0I, &p_CircIQBuf0Q, &p_CircIQBuf0A, &p_CircIQBuf0P, &p_CircIQFaultBuf0I,
			&p_CircIQFaultBuf0Q, &p_CircIQFaultBuf0A, &p_CircIQFaultBuf0P, &p_Shell0SlowDataR, &p_Shell0CircleCountR,
			&p_Shell0CircleStatR, &p_Shell0MinsR, &p_Shell0MaxsR, &p_Shell0TagNowR, &p_Shell0TagOldR,
			&p_Shell0TimeStampHighR, &p_Shell0TimeStampLowR, bufShell0CircleData, reqShell0CircleData,
			(epicsUInt8 *)bufShell0SlowData, reqShell0SlowData),
	shell1CircBuf_(this, Shell1CircleDataRAdr, Shell1SlowDataRAdr, &p_Shell1CircleDataWav,
			&p_CircIQBuf1I, &p_CircIQBuf1Q, &p_CircIQBuf1A, &p_CircIQBuf1P, &p_CircIQFaultBuf1I,
			&p_CircIQFaultBuf1Q, &p_CircIQFaultBuf1A, &p_CircIQFaultBuf1P, &p_Shell1SlowDataR, &p_Shell1CircleCountR,
			&p_Shell1CircleStatR, &p_Shell1MinsR, &p_Shell1MaxsR, &p_Shell1TagNowR, &p_Shell1TagOldR,
			&p_Shell1TimeStampHighR, &p_Shell1TimeStampLowR, bufShell1CircleData, reqShell1CircleData,
			(epicsUInt8 *)bufShell1SlowData, reqShell1SlowData)

{
	FpgaReg adHocMessage;
	bool waveIsReady;

	fillWaveRequestMsg(reqShell0CircleData, sizeof(reqShell0CircleData) / sizeof(*reqShell0CircleData), Shell0CircleDataRAdr);
	fillWaveRequestMsg(reqShell1CircleData, sizeof(reqShell1CircleData) / sizeof(*reqShell1CircleData), Shell1CircleDataRAdr);

	// Also get "slow data registers" every time
	fillWaveRequestMsg(reqShell0SlowData, sizeof(reqShell0SlowData) / sizeof(*reqShell0SlowData), Shell0SlowDataRAdr);
	fillWaveRequestMsg(reqShell1SlowData, sizeof(reqShell1SlowData) / sizeof(*reqShell1SlowData), Shell1SlowDataRAdr);

    createParam(IfFreqString, asynParamFloat64, &p_IF);

    createParam(WaveformI16BitString, asynParamInt16Array, &p_WaveformI16Bit);
    createParam(WaveformQ16BitString, asynParamInt16Array, &p_WaveformQ16Bit);
    createParam(WaveformI22BitString, asynParamInt32Array, &p_WaveformI22Bit);
    createParam(WaveformQ22BitString, asynParamInt32Array, &p_WaveformQ22Bit);

    createParam(WaveformA16BitString, asynParamFloat32Array, &p_WaveformA16Bit);
    createParam(WaveformP16BitString, asynParamFloat32Array, &p_WaveformP16Bit);
    createParam(WaveformA22BitString, asynParamFloat32Array, &p_WaveformA22Bit);
    createParam(WaveformP22BitString, asynParamFloat32Array, &p_WaveformP22Bit);

    createParam(IQNActiveString, asynParamInt32, &p_IQNActive);
    createParam(IQBitWidthString, asynParamInt32, &p_IQBitWidth);
    createParam(IQ16BitNELMString, asynParamInt32, &p_IQ16BitNELM);
    createParam(IQ22BitNELMString, asynParamInt32, &p_IQ22BitNELM);

    // Circle Buffer waveforms

    createParam(Circ0BufChanEnableString, asynParamUInt32Digital, &p_Circ0BufChanEnable);
    createParam(Circ1BufChanEnableString, asynParamUInt32Digital, &p_Circ1BufChanEnable);
    createParam(Circ0NActiveString, asynParamInt32, &p_Circ0NActive);
    createParam(Circ1NActiveString, asynParamInt32, &p_Circ1NActive);
    createParam(CircIQBuf0IString, asynParamInt32Array, &p_CircIQBuf0I);
    createParam(CircIQBuf0QString, asynParamInt32Array, &p_CircIQBuf0Q);
    createParam(CircIQBuf0AString, asynParamFloat32Array, &p_CircIQBuf0A);
    createParam(CircIQBuf0PString, asynParamFloat32Array, &p_CircIQBuf0P);
    createParam(CircIQBuf1IString, asynParamInt32Array, &p_CircIQBuf1I);
    createParam(CircIQBuf1QString, asynParamInt32Array, &p_CircIQBuf1Q);
    createParam(CircIQBuf1AString, asynParamFloat32Array, &p_CircIQBuf1A);
    createParam(CircIQBuf1PString, asynParamFloat32Array, &p_CircIQBuf1P);
    createParam(CircIQFaultBuf0IString, asynParamInt32Array, &p_CircIQFaultBuf0I);
    createParam(CircIQFaultBuf0QString, asynParamInt32Array, &p_CircIQFaultBuf0Q);
    createParam(CircIQFaultBuf0AString, asynParamFloat32Array, &p_CircIQFaultBuf0A);
    createParam(CircIQFaultBuf0PString, asynParamFloat32Array, &p_CircIQFaultBuf0P);
    createParam(CircIQFaultBuf1IString, asynParamInt32Array, &p_CircIQFaultBuf1I);
    createParam(CircIQFaultBuf1QString, asynParamInt32Array, &p_CircIQFaultBuf1Q);
    createParam(CircIQFaultBuf1AString, asynParamFloat32Array, &p_CircIQFaultBuf1A);
    createParam(CircIQFaultBuf1PString, asynParamFloat32Array, &p_CircIQFaultBuf1P);

    createParam(Shell0CircleCountRString, asynParamInt32, &p_Shell0CircleCountR);
    createParam(Shell0CircleStatRString, asynParamInt32, &p_Shell0CircleStatR);
    createParam(Shell0MinsRString, asynParamInt32, &p_Shell0MinsR);
    createParam(Shell0MaxsRString, asynParamInt32, &p_Shell0MaxsR);
    createParam(Shell0TagNowRString, asynParamInt32, &p_Shell0TagNowR);
    createParam(Shell0TagOldRString, asynParamInt32, &p_Shell0TagOldR);
    createParam(Shell0TimeStampHighRString, asynParamInt32, &p_Shell0TimeStampHighR);
    createParam(Shell0TimeStampLowRString, asynParamInt32, &p_Shell0TimeStampLowR);
    // What will happen if we leave the param as a 32 bit array, even though PV is 8 bit array?
    createParam(Shell0TimeStepString, asynParamFloat64, &p_Shell0TimeStep);

    createParam(Shell1CircleCountRString, asynParamInt32, &p_Shell1CircleCountR);
    createParam(Shell1CircleStatRString, asynParamInt32, &p_Shell1CircleStatR);
    createParam(Shell1MinsRString, asynParamInt32, &p_Shell1MinsR);
    createParam(Shell1MaxsRString, asynParamInt32, &p_Shell1MaxsR);
    createParam(Shell1TagNowRString, asynParamInt32, &p_Shell1TagNowR);
    createParam(Shell1TagOldRString, asynParamInt32, &p_Shell1TagOldR);
    createParam(Shell1TimeStampHighRString, asynParamInt32, &p_Shell1TimeStampHighR);
    createParam(Shell1TimeStampLowRString, asynParamInt32, &p_Shell1TimeStampLowR);
    // What will happen if we leave the param as a 32 bit array, even though PV is 8 bit array?
    createParam(Shell1TimeStepString, asynParamFloat64, &p_Shell1TimeStep);

    // Start with a sensible X axis for circle buffer waveforms
    adHocMessage.addr = Shell0DspWaveSampPerRAdr|flagReadMask;
    adHocMessage.data = 1;
    processRegReadback(&adHocMessage, waveIsReady);
    adHocMessage.addr = Shell1DspWaveSampPerRAdr|flagReadMask;
    processRegReadback(&adHocMessage, waveIsReady);

    // For testing, call this function after adding the FPGA response data copied from Wireshark
//    testCannedResponse();

    epicsThreadSleep(defaultPollPeriod);
    std::cout << __PRETTY_FUNCTION__ << " created " << NUM_SCLLRFPRCEXTRA_PARAMS << " parameters." << std::endl;

	reqWaveEventId_ = epicsEventMustCreate(epicsEventEmpty);
	startTraceIQWaveformRequester();

	startCircIQBufRequester();

    epicsThreadSleep(defaultPollPeriod);
    wakeupPoller();
    wakeupReader();

    // Message size is the number of read registers, plus 1 nonce for every 175 read registers
    unsigned int FirmwareRegMsgSize_ = 33;
	// A canned request to read all registers
    FpgaReg* pFirmwareRegMsg_ = new FpgaReg[FirmwareRegMsgSize_]
	{
		{ 0, 0 },
		{ (flagReadMask | MagicRAdr), blankData },
		{ (flagReadMask | DspFlavorRAdr), blankData },
		{ (flagReadMask | BuildYearRAdr), blankData },
		{ (flagReadMask | BuildMonthRAdr), blankData },
		{ (flagReadMask | BuildDayRAdr), blankData },
		{ (flagReadMask | BuildHourRAdr), blankData },
		{ (flagReadMask | BuildMinuteRAdr), blankData },
		{ (flagReadMask | CodeIsCleanRAdr), blankData },
		{ (flagReadMask | ToolRevRAdr), blankData },
		{ (flagReadMask | UserRAdr), blankData },
		{ (flagReadMask | BoardTypeRAdr), blankData },
		{ (flagReadMask | VersionRAdr), blankData },
		{ (flagReadMask | GitSha1ARAdr), blankData },
		{ (flagReadMask | GitSha1BRAdr), blankData },
		{ (flagReadMask | GitSha1CRAdr), blankData },
		{ (flagReadMask | GitSha1DRAdr), blankData },
		{ (flagReadMask | GitSha1ERAdr), blankData },
		{ (flagReadMask | GitSha1FRAdr), blankData },
		{ (flagReadMask | GitSha1GRAdr), blankData },
		{ (flagReadMask | GitSha1HRAdr), blankData },
		{ (flagReadMask | GitSha1IRAdr), blankData },
		{ (flagReadMask | GitSha1JRAdr), blankData },
		{ (flagReadMask | GitSha1KRAdr), blankData },
		{ (flagReadMask | GitSha1LRAdr), blankData },
		{ (flagReadMask | GitSha1MRAdr), blankData },
		{ (flagReadMask | GitSha1NRAdr), blankData },
		{ (flagReadMask | GitSha1ORAdr), blankData },
		{ (flagReadMask | GitSha1PRAdr), blankData },
		{ (flagReadMask | GitSha1QRAdr), blankData },
		{ (flagReadMask | GitSha1RRAdr), blankData },
		{ (flagReadMask | GitSha1SRAdr), blankData },
		{ (flagReadMask | GitSha1TRAdr), blankData },
	};

	htonFpgaRegArray(pFirmwareRegMsg_, FirmwareRegMsgSize_);
	_singleMsgQ.send(&pFirmwareRegMsg_[1], (FirmwareRegMsgSize_-1)*sizeof( FpgaReg ));


}

scllrfPRCextra::~scllrfPRCextra()
{
	isShuttingDown_ = true;
	epicsThreadSleep(0.1); // Allow threads to run and exit
	epicsEventSignal(reqWaveEventId_);
	wakeupPoller();
	wakeupReader();
	epicsThreadSleep(0.1); // Allow threads to run and exit
	wakeupPoller(); // call this twice in case the poller was never set to run
	wakeupReader();
	epicsThreadSleep(0.1); // Allow threads to run and exit
	wakeupReader();
	pasynOctetSyncIO->disconnect(pOctetAsynUser_);
	pasynCommonSyncIO->disconnectDevice(pCommonAsynUser_);
	pasynCommonSyncIO->disconnect(pCommonAsynUser_);
}

// To test how the code handles responses from the FPGA, compose a simulated response here.
void scllrfPRCextra::testCannedResponse()
{
	// set up fake chassis response in this file. It can be quite long.
	// Note that data can be copied from Wireshark. Next time, note the
	// regex that translates to the right format.

	bool dummy; // For the waveform flag

	pasynTrace->setTraceMask((pasynUserSelf), 0xb);
	pasynTrace->setTraceMask(pOctetAsynUser_, 0xb);

//#include "PRCcannedSlowDataResponseTest.cpp"
//#include "PRCcannedCircleBuffResponseTest.cpp"
		std::cout << "<- " <<__PRETTY_FUNCTION__ << endl;
}

asynStatus scllrfPRCextra::writeUInt32Digital(asynUser *pasynUser, epicsUInt32 value, epicsUInt32 mask)
{
asynPrint(pasynUser, ASYN_TRACEIO_DRIVER, "--> %s: value: %d, mask: %x\n", __PRETTY_FUNCTION__, value, mask);
	int function = pasynUser->reason;
	asynStatus status = asynSuccess;
    const char *paramName;
    FpgaReg regSendBuf[5]; // LBL reports problems when smaller requests are sent
    std::fill( regSendBuf, regSendBuf + sizeof( regSendBuf )/sizeof( *regSendBuf), (FpgaReg)  {flagReadMask,blankData} );

    /* Fetch the parameter string name for possible use in debugging */
    getParamName(function, &paramName);
    asynPrint(pasynUser, ASYN_TRACEIO_DRIVER, "%s: function=%d, %s\n",
			__PRETTY_FUNCTION__, function, paramName);

    // For settings that change the waveform scale,
    // increment tag so inconsistent data is dropped.
    // Numbering convention, to keep consistent with beg0.py:
   	//#   0  reserved for never used
   	//#   1  reserved for parameter update in progress
   	//#   2  reserved for process stopped
   	//#   3  unused
   	//#  4-11 rotated through [well, 4-123 here, slight change from beg0.py]
   	//# I use 4 bits here, even though the hardware is capable of 8
       	// TODO: if this works as expected, add other settings that change waveform scale

    if (function == p_Circ0BufChanEnable) // Enable I/Q pairs
    {
        /* Set the parameter in the parameter library. */
        status = (asynStatus) setUIntDigitalParam(0, function, value, mask);

        // Send a message to the FPGA to: set tag to 1 "updating", enable/disable two
        // channels (I/Q pair), set tag to next value in series
		regSendBuf[0].addr = (uint32_t) Shell0DspTagWAdr;
		regSendBuf[0].data = (int32_t) 1;
		// Don't bother reading the tag back at this point, it gets changed
		// and read back later in this message
		regSendBuf[1].addr = (uint32_t) Shell0DspChanKeepWAdr;
    	// Enable register has I and Q as their own bits, so set pairs of bits
		regSendBuf[1].data = InterleaveEnableBits(value, value);
		regSendBuf[2].addr = (uint32_t) Shell0DspChanKeepWAdr | flagReadMask;
		// regSendBuf[3] is a read request, so leave "blankData" there.
		regSendBuf[3].addr = (uint32_t) Shell0DspTagWAdr;
		regSendBuf[3].data = (int32_t) shell0CircBuf_.nextTag();
		regSendBuf[4].addr = (uint32_t) Shell0DspTagWAdr | flagReadMask;
		// regSendBuf[5] is a read request, so leave "blankData" there.

        status = (asynStatus) setUIntDigitalParam(0, p_Shell0DspChanKeepW, (epicsUInt32) regSendBuf[1].data, mask);

		htonFpgaRegArray(regSendBuf, sizeof( regSendBuf )/sizeof( *regSendBuf));
		_singleMsgQ.send(regSendBuf, sizeof( regSendBuf ));
    }
    else
    if (function == p_Circ1BufChanEnable) // Enable I/Q pairs
    {
        /* Set the parameter in the parameter library. */
        status = (asynStatus) setUIntDigitalParam(0, function, value, mask);

        // Send a message to the FPGA to: set tag to 1 "updating", enable/disable two
        // channels (I/Q pair), set tag to next value in series
		regSendBuf[0].addr = (uint32_t) Shell1DspTagWAdr;
		regSendBuf[0].data = (int32_t) 1;
		// Don't bother reading the tag back at this point, it gets changed
		// and read back later in this message
		regSendBuf[1].addr = (uint32_t) Shell1DspChanKeepWAdr;
    	// Enable register has I and Q as their own bits, so set pairs of bits
		regSendBuf[1].data = InterleaveEnableBits(value, value);
		regSendBuf[2].addr = (uint32_t) Shell1DspChanKeepWAdr | flagReadMask;
		// regSendBuf[3] is a read request, so leave "blankData" there.
		regSendBuf[3].addr = (uint32_t) Shell1DspTagWAdr;
		regSendBuf[3].data = (int32_t) shell1CircBuf_.nextTag();
		regSendBuf[4].addr = (uint32_t) Shell1DspTagWAdr | flagReadMask;
		// regSendBuf[5] is a read request, so leave "blankData" there.

        status = (asynStatus) setUIntDigitalParam(0, p_Shell1DspChanKeepW, (epicsUInt32) regSendBuf[1].data, mask);

		htonFpgaRegArray(regSendBuf, sizeof( regSendBuf )/sizeof( *regSendBuf));
		_singleMsgQ.send(regSendBuf, sizeof( regSendBuf ));
    }
    else
    {
    	scllrfPRCDriver::writeUInt32Digital(pasynUser, value, mask);
    }
    return status;
}


/** Called when asyn clients call pasynInt32->write().
 * \param[in] pasynUser pasynUser structure that encodes the reason and address.
 * \param[in] value Pointer to the value to read. */
asynStatus scllrfPRCextra::writeInt32(asynUser *pasynUser, epicsInt32 value)
{
	int function = pasynUser->reason;
	asynStatus status = asynSuccess;
    const char *paramName;

    /* Fetch the parameter string name for possible use in debugging */
    getParamName(function, &paramName);
    asynPrint(pasynUser, ASYN_TRACEIO_DRIVER, "--> %s: function=%d, %s, set to %d\n",
			__PRETTY_FUNCTION__, function, paramName, value);

    if (function == p_IQBitWidth)
    {
    	wavBitWidth_ = (scllrfPRCextra::traceIQWavBitWidth) value;
        /* Set the parameter in the parameter library. */
        status = (asynStatus) setIntegerParam(function, value);
    }
    else // For settings that change the waveform scale,
    	 // increment tag so inconsistent data is dropped.
    	// Numbering convention, to keep consistent with beg0.py:
	//#   0  reserved for never used
	//#   1  reserved for parameter update in progress
	//#   2  reserved for process stopped
	//#   3  unused
	//#  4-11 rotated through [well, 4-123 here, slight change from beg0.py]
	//# I use 4 bits here, even though the hardware is capable of 8
    	// TODO: if this works as expected, add other settings that change waveform scale
    if (function == p_Shell0DspWaveSampPerW)
    {
    	pasynUser->reason = p_Shell0DspTagW;
    	status = scllrfPRCDriver::writeInt32(pasynUser, 1); // See beg0.py for tag convention

    	pasynUser->reason = p_Shell0DspWaveSampPerW;
    	status = scllrfPRCDriver::writeInt32(pasynUser, value);

    	pasynUser->reason = p_Shell0DspTagW;
    	value = shell0CircBuf_.nextTag();
    	status = scllrfPRCDriver::writeInt32(pasynUser, value);
    }
    else
    if (function == p_Shell1DspWaveSampPerW)
    {
    	pasynUser->reason = p_Shell1DspTagW;
    	status = scllrfPRCDriver::writeInt32(pasynUser, 1); // See beg1.py for tag convention

    	pasynUser->reason = p_Shell1DspWaveSampPerW; // Back to putting the passed value in the register
    	status = scllrfPRCDriver::writeInt32(pasynUser, value);

    	pasynUser->reason = p_Shell1DspTagW; // Increment tag
    	value = shell1CircBuf_.nextTag();
    	status = scllrfPRCDriver::writeInt32(pasynUser, value);
    }
//    else
//    if (function == p_TagNowW)
//    {
//    	status = scllrfPRCDriver::writeInt32(pasynUser, value);
//
//    	status = scllrfPRCDriver::writeInt32(pasynUser, value);
//    }
    else
    {
    	status = scllrfPRCDriver::writeInt32(pasynUser, value);
    }

    if (status)
        epicsSnprintf(pasynUser->errorMessage, pasynUser->errorMessageSize,
                  "%s: status=%d, function=%d, name=%s, value=%d",
				  __PRETTY_FUNCTION__, status, function, paramName, value);
    else
        asynPrint(pasynUser, ASYN_TRACEIO_DRIVER,
              "<-- %s: function=%d, name=%s, value=%d\n",
			  __PRETTY_FUNCTION__, function, paramName, value);
    return status;
}


static void waveformRequesterC(void *drvPvt)
{
	//printf("%s: starting\n", __PRETTY_FUNCTION__);
	scllrfPRCextra *pscllrfDriver = (scllrfPRCextra*)drvPvt;
	pscllrfDriver->traceIQWaveformRequester();
	//printf("%s: exiting\n", __PRETTY_FUNCTION__);
}

/** Starts the poller thread.
 ** Derived classes will typically call this at near the end of their constructor.
 ** Derived classes can typically use the base class implementation of the poller thread,
 ** but are free to re-implement it if necessary.
 ** \param[in] pollPeriod The time between polls. */
asynStatus scllrfPRCextra::startTraceIQWaveformRequester()
{
	epicsThreadCreate("waveformRequester",
			epicsThreadPriorityMedium,
			epicsThreadGetStackSize(epicsThreadStackMedium),
			(EPICSTHREADFUNC)waveformRequesterC, (void *)this);
	return asynSuccess;
}

// When a new value for npt_ (number of points in each waveform) is calculated,
// run this to compose new waveform request messages with the new size.
void scllrfPRCextra::fillTraceIQWavReqMsg()
{
	int i, segmentNum, segmentOffset;
	unsigned int addr=0, segStartAddr = traceIQWavesStart;
	FpgaReg reqWaveMsg[traceIQWaveSegmentCount][traceIQWaveSegmentSize];

	for(i = 0; i<4; i++)
	{
		segmentNum = 0;
		segmentOffset = 1; // Start data past the nonce
		reqWaveMsg[segmentNum][0] = {0,0};
//		//printf("\n%s filling waveform request %d: [%u][%u]={0x%x,0x%x}", __PRETTY_FUNCTION__, i, segmentNum, 0,
//				addr, reqWaveMsg[segmentNum][0].data);
		for (addr = segStartAddr; addr < segStartAddr+npt_; addr++, segmentOffset++)
		{
			assert(addr <= traceIQWavesEnd);
			reqWaveMsg[segmentNum][segmentOffset].addr = (uint32_t) (addr | flagReadMask);
			reqWaveMsg[segmentNum][segmentOffset].data = blankData + addr;
//			//printf(", [%u][%u]={0x%x,0x%x}", segmentNum, segmentOffset,
//					addr, reqWaveMsg[segmentNum][segmentOffset].data);

			// If there's more to send than will fit in the max message size, break
			// it up into chunks and send each chunk individually
			if(segmentOffset == maxMsgSize/sizeof(FpgaReg)-1)
			{
				segmentNum++;
				reqWaveMsg[segmentNum][0] = {0,0};
//				//printf(" %lu bytes in this segment.\n", (segmentOffset +1) * sizeof (FpgaReg));
				segmentOffset = 0; // will be incremented to 1 at the top of the loop
//				//printf("\nfilling waveform request %d: [%u][%u]={0x0,0x0}", i, segmentNum, segmentOffset);
			}
		}
//		//printf(" %lu of %lu bytes filled in this segment.\n",
//				(segmentOffset +1) * sizeof (FpgaReg), waveSegmentSize * sizeof (FpgaReg));

		// Each segment has unused elements at the end. Safest to convert whole thing.
		////printf("\n%s calling htonFpgaRegArray for waveform %u, %u registers\n", __PRETTY_FUNCTION__, i, waveSegmentCount * waveSegmentSize );

		htonFpgaRegArray(reqWaveMsg[0], traceIQWaveSegmentCount * traceIQWaveSegmentSize);

		switch (i)
		{
		case 0:
			std::copy(&reqWaveMsg[0][0], &reqWaveMsg[0][0]+traceIQWaveSegmentCount * traceIQWaveSegmentSize,
					&pReqIQ16bAMsg_[0][0]); // Canned message to request 16 bit I/Q data, first npt_ points
			break;
		case 1:
			std::copy(&reqWaveMsg[0][0], &reqWaveMsg[0][0]+traceIQWaveSegmentCount * traceIQWaveSegmentSize,
					&pReqIQ16bBMsg_[0][0]); // Canned message to request 16 bit I/Q data, last npt_ points
			break;
		case 2:
			std::copy(&reqWaveMsg[0][0], &reqWaveMsg[0][0]+traceIQWaveSegmentCount * traceIQWaveSegmentSize,
					&pReqI22bMsg_[0][0]); // Canned message to request 22 bit I data
			break;
		case 3:
			std::copy(&reqWaveMsg[0][0], &reqWaveMsg[0][0]+traceIQWaveSegmentCount * traceIQWaveSegmentSize,
					&pReqQ22bMsg_[0][0]); // Canned message to request 22 bit Q data
			break;
		}
//		//printf("Filled up %d of %d segments, last one with %d points\n",
//				segmentNum, waveSegmentCount, segmentOffset);
//		//printf("Setting start address of next waveform segment to 0x%x\n", addr);
		segStartAddr = addr;
	}
}


void scllrfPRCextra::reqTraceIQWWaveform(FpgaReg (*readWaveformsMsg)[traceIQWaveSegmentSize])
{
	int regsLeftToSend = npt_;
	uint i;

//	//printf(" --> %s\n", __PRETTY_FUNCTION__);
//	//printf("%s waveSegmentSize = %u, waveSegmentCount = %u, regsLeftToSend = %d\n",
//			__PRETTY_FUNCTION__, waveSegmentSize, waveSegmentCount, regsLeftToSend);
//	//printf("%s waveBufferRegCount = %u, waveBuffSize = %u, waveSegmentCount = %d\n",
//			__PRETTY_FUNCTION__, waveBufferRegCount, waveBuffSize, waveSegmentCount);
	for (i=0; i<traceIQWaveSegmentCount; ++i)
	{
		if(regsLeftToSend > (int) (maxMsgSize/sizeof(FpgaReg)))
		{
			sendRegRequest(&readWaveformsMsg[i][0], maxMsgSize/sizeof(FpgaReg));
			regsLeftToSend -= maxMsgSize/sizeof(FpgaReg) - 1;
//			//printf("%s sent segment %u, regsLeftToSend = %d\n", __PRETTY_FUNCTION__, i, regsLeftToSend);
		}
		else
		{
			sendRegRequest(&readWaveformsMsg[i][0], regsLeftToSend + 1);
//			//printf("%s sent segment %u, last %d registers\n", __PRETTY_FUNCTION__, i, regsLeftToSend);
			break;
		}
	}
//	//printf(" <-- %s\n", __PRETTY_FUNCTION__);
}

void scllrfPRCextra::traceIQWaveformRequester()
{
	FpgaReg traceAck[5] =
	{
			{0,0},
			{TraceResetWeWAdr,1},
			{BufTrigWAdr,0},
			{BufTrigWAdr,1},
			{BufTrigWAdr,0}
	};
	////printf("\n%s calling htonFpgaRegArray for %u registers of traceAck\n", __PRETTY_FUNCTION__, 5 );
    htonFpgaRegArray(traceAck, sizeof(traceAck)/sizeof(FpgaReg));
    //htonFpgaRegArray(traceAck, 5);
    sendRegRequest(traceAck, sizeof(traceAck)/sizeof(FpgaReg));

	// Main polling loop
	while (1)
	{
		epicsEventWait(reqWaveEventId_);

		if (isShuttingDown_)
		{
			break;
		}

		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: signaled by reqWaveEventId_\n", __PRETTY_FUNCTION__);

		// avoid divide by 0 errors when waveforms are inactive
		if (nchan_ <=0 || npt_ <=0)
		{
			epicsThreadSleep(pollPeriod_);
		}
		else {
			/* We got an event, rather than a timeout.
			 **/
			switch (wavBitWidth_)
			{
			case read16bit:
				reqTraceIQWWaveform(pReqIQ16bAMsg_);
				reqTraceIQWWaveform(pReqIQ16bBMsg_);
				break;
			case read22bit:
				reqTraceIQWWaveform(pReqI22bMsg_);
				reqTraceIQWWaveform(pReqQ22bMsg_);
				break;
			default:
				//printf("%s: impossible bit width\n", __PRETTY_FUNCTION__);
				break;
			}

			newWaveRead_ = newWaveAvailable_; // Indicate that we got the signal
			sendRegRequest(traceAck, sizeof(traceAck)/sizeof(FpgaReg));
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
					"%s: done sending waveform request\n", __PRETTY_FUNCTION__);
		}
	}
	//	//printf("%s: exiting\n", __PRETTY_FUNCTION__);
}

// parse register data, write to array PV
asynStatus scllrfPRCextra::processTraceIQWaveReadback(const FpgaReg *pFromFpga)
{
	// avoid divide by 0 errors when waveforms are inactive
	if (nchan_ <=0)
	{
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
			"%s can't process waveform data with 0 active channels\n", __PRETTY_FUNCTION__);
		return asynError;
	}
	if (npt_ <=0)
	{
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
			"%s waveform length set to %u but array index is %u\n",
				__PRETTY_FUNCTION__, (unsigned int) npt_, pFromFpga->addr);
		return asynError;
	}

	unsigned int bufferOffset = (pFromFpga->addr & addrMask) - traceIQWavesStart;
	// additional base offsets
	//   0 * npt  16-bit I and Q
	//   1 * npt  16-bit I and Q
	//   2 * npt  22-bit I
	//   3 * npt  22-bit Q
	unsigned int bufferNumber = bufferOffset / npt_; // of the 4 buffers above, which range are we in?
	unsigned int bufferBase = npt_ * bufferNumber; // in bufferNumber, base address offset
	unsigned int waveOffset = (bufferOffset - bufferBase);
	unsigned int waveNumber = waveOffset % nchan_;
	unsigned int waveIndex = waveOffset / nchan_;
	unsigned int i;

//	asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
//			"%s bufferOffset = %u, npt_ = %zu, waveNumber = %u waveIndex =%u\n", __PRETTY_FUNCTION__, bufferOffset, npt_, waveNumber, waveIndex);

	switch (bufferNumber)
	{
	case 0: //TODO: verify the packing of the bits for 16 bit data
		pWave16bitI_[waveNumber][waveIndex] = (epicsInt16) pFromFpga->data;
		pWave16bitQ_[waveNumber][waveIndex] = (epicsInt16) (pFromFpga->data >> 16);
		// Amplitude = qrt(I^2+Q^2)

		// phase = arctan(Q/I)

		break;

	case 1:
		waveIndex += npt_; // continued from addresses in "case 0"
		pWave16bitI_[waveNumber][waveIndex] = (epicsInt16) pFromFpga->data;
		pWave16bitQ_[waveNumber][waveIndex] = (epicsInt16) (pFromFpga->data >> 16);


		// phase = arctan(Q/I)

		if (waveOffset +1 == npt_) // if this is the last point of the waveform
		{
			setIntegerParam(p_IQ16BitNELM, npt_ * 2/nchan_);
			for (i=0; i<maxTraceIQWavesCount; ++i)
			{
				if(i<nchan_)
				{
					doCallbacksInt16Array(pWave16bitI_[i], 2*npt_/nchan_, p_WaveformI16Bit, i);
					doCallbacksInt16Array(pWave16bitQ_[i], 2*npt_/nchan_, p_WaveformQ16Bit, i);
					doCallbacksFloat32Array(pWave16bitA_[i], 2*npt_/nchan_, p_WaveformA16Bit, i);
					doCallbacksFloat32Array(pWave16bitP_[i], 2*npt_/nchan_, p_WaveformP16Bit, i);
				} else { // clear inactive channels
					doCallbacksInt16Array(pWave16bitI_[i], 0, p_WaveformI16Bit, i);
					doCallbacksInt16Array(pWave16bitQ_[i], 0, p_WaveformQ16Bit, i);
					doCallbacksFloat32Array(pWave16bitA_[i], 0, p_WaveformA16Bit, i);
					doCallbacksFloat32Array(pWave16bitP_[i], 0, p_WaveformP16Bit, i);
				}
				std::fill( pWave16bitI_[i], pWave16bitI_[i] + sizeof( pWave16bitI_[i] )/sizeof( *pWave16bitI_[i]), 0 );
				std::fill( pWave16bitQ_[i], pWave16bitQ_[i] + sizeof( pWave16bitQ_[i] )/sizeof( *pWave16bitQ_[i]), 0 );
				std::fill( pWave16bitA_[i], pWave16bitA_[i] + sizeof( pWave16bitA_[i] )/sizeof( *pWave16bitA_[i]), 0 );
				std::fill( pWave16bitP_[i], pWave16bitP_[i] + sizeof( pWave16bitP_[i] )/sizeof( *pWave16bitP_[i]), 0 );
			}
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
					"%s: got last waveform datapoint. Publishing.\n", __PRETTY_FUNCTION__);
		}
		break;

	case 2:
		pWave22bitI_[waveNumber][waveIndex] =
                     ((epicsInt32) pFromFpga->data) >> 10;
		break;

	case 3:
		pWave22bitQ_[waveNumber][waveIndex] =
                     ((epicsInt32) pFromFpga->data) >> 10;


		// phase = arctan(Q/I)

		if (waveOffset +1 == npt_) // if this is the last point of the waveform
		{
			setIntegerParam(p_IQ22BitNELM, npt_/nchan_);
			for (i=0; i<maxTraceIQWavesCount; ++i)
			{
				if(i<nchan_) // update both I and Q here, so they stay in sync
				{
					doCallbacksInt32Array(pWave22bitI_[i], npt_/nchan_, p_WaveformI22Bit, i);
					doCallbacksInt32Array(pWave22bitQ_[i], npt_/nchan_, p_WaveformQ22Bit, i);
					doCallbacksFloat32Array(pWave22bitA_[i], npt_/nchan_, p_WaveformA22Bit, i);
					doCallbacksFloat32Array(pWave22bitP_[i], npt_/nchan_, p_WaveformP22Bit, i);
				} else { // clear inactive channels
					doCallbacksInt32Array(pWave22bitI_[i], 0, p_WaveformI22Bit, i);
					doCallbacksInt32Array(pWave22bitQ_[i], 0, p_WaveformQ22Bit, i);
					doCallbacksFloat32Array(pWave22bitA_[i], 0, p_WaveformA22Bit, i);
					doCallbacksFloat32Array(pWave22bitP_[i], 0, p_WaveformP22Bit, i);
				}
				std::fill( pWave22bitI_[i], pWave22bitI_[i] + sizeof( pWave22bitI_[i] )/sizeof( *pWave22bitI_[i]), 0 );
				std::fill( pWave22bitQ_[i], pWave22bitQ_[i] + sizeof( pWave22bitQ_[i] )/sizeof( *pWave22bitQ_[i]), 0 );
				std::fill( pWave22bitA_[i], pWave22bitA_[i] + sizeof( pWave22bitA_[i] )/sizeof( *pWave22bitA_[i]), 0 );
				std::fill( pWave22bitP_[i], pWave22bitP_[i] + sizeof( pWave22bitP_[i] )/sizeof( *pWave22bitP_[i]), 0 );
			}
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
					"%s: got last waveform datapoint. Publishing.\n", __PRETTY_FUNCTION__);
		}
		break;

	}

//	//printf("<-- %s\n", __PRETTY_FUNCTION__);
	return asynSuccess;
}

static void circIQBufRequesterC(void *drvPvt)
{
	//printf("%s: starting\n", __PRETTY_FUNCTION__);
	scllrfPRCextra *pscllrfDriver = (scllrfPRCextra*)drvPvt;
	pscllrfDriver->circIQBufRequester();
	//printf("%s: exiting\n", __PRETTY_FUNCTION__);
}

/** Starts the poller thread.
 ** Derived classes will typically call this at near the end of their constructor.
 ** Derived classes can typically use the base class implementation of the poller thread,
 ** but are free to re-implement it if necessary.
 ** \param[in] pollPeriod The time between polls. */
asynStatus scllrfPRCextra::startCircIQBufRequester()
{
	epicsThreadCreate("waveformRequester",
			epicsThreadPriorityMedium,
			epicsThreadGetStackSize(epicsThreadStackMedium),
			(EPICSTHREADFUNC)circIQBufRequesterC, (void *)this);
	return asynSuccess;
}

void CircleWave::ReqCircIQBuf()
{
	// Slow buffer request is packed into one UDP packet, so this is safe.
	pDriver_->sendRegRequest(pReqSlowDataMsg_, slowDataBuffSize);

	pDriver_->sendBigBuffer(pRequestMsg_, reqMsgSize);
}

void scllrfPRCextra::circIQBufRequester()
{
	epicsUInt32 readyBits;

	FpgaReg circ0Ack[] =
	{
			{0,0},
			{CircleBufFlipWAdr,1},
			{CircleBufFlipWAdr,0},
			{CircleBufFlipWAdr,0},
			{CircleBufFlipRAdr | flagReadMask,blankData},
			{flagReadMask,blankData},
			{LlrfCircleReadyRAdr | flagReadMask,blankData},
	};
	////printf("\n%s calling htonFpgaRegArray for %u registers of circAck\n", __PRETTY_FUNCTION__, 5 );
    htonFpgaRegArray(circ0Ack, sizeof(circ0Ack)/sizeof(FpgaReg));

	FpgaReg circ1Ack[] =
	{
			{0,0},
			{CircleBufFlipWAdr,2},
			{CircleBufFlipWAdr,0},
			{CircleBufFlipWAdr,0},
			{CircleBufFlipRAdr | flagReadMask,blankData},
			{flagReadMask,blankData},
			{LlrfCircleReadyRAdr | flagReadMask,blankData},
	};
	////printf("\n%s calling htonFpgaRegArray for %u registers of circAck\n", __PRETTY_FUNCTION__, 5 );
    htonFpgaRegArray(circ1Ack, sizeof(circ1Ack)/sizeof(FpgaReg));

	// Main polling loop
	while (1)
	{
		newCircIQBufRead_ = newCircIQBufAvailable_; // Indicate that we got the previous signal
		reqCircIQBufEvent_.wait();
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
					"%s: got data ready flag\n", __PRETTY_FUNCTION__);

		if (isShuttingDown_)
		{
			break;
		}

		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: signaled by reqWaveEventId_\n", __PRETTY_FUNCTION__);
		getUIntDigitalParam(p_LlrfCircleReadyR,
					&readyBits, LlrfCircleReadyMask);
		// Don't request data if no active channels
		if (shell0CircBuf_.nChan_ <=0 || ((readyBits & 0x1) == 0))
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
						"%s: shell0CircBuf_.nChan_=%d\n", __PRETTY_FUNCTION__, shell0CircBuf_.nChan_);
			epicsThreadSleep(pollPeriod_);
		}
		else
		{
			/* We got an event, rather than a timeout.
			 **/
			shell0CircBuf_.ReqCircIQBuf();

			sendRegRequest(circ0Ack, sizeof(circ0Ack)/sizeof(FpgaReg));
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
					"%s: done sending waveform request\n", __PRETTY_FUNCTION__);

		}
		if (shell1CircBuf_.nChan_ <=0  || ((readyBits & 0x2) == 0))
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
						"%s: shell1CircBuf_.nChan_=%d\n", __PRETTY_FUNCTION__, shell1CircBuf_.nChan_);
			epicsThreadSleep(pollPeriod_);
		}
		else
		{
			/* We got an event, rather than a timeout.
			 **/
			shell1CircBuf_.ReqCircIQBuf();

			sendRegRequest(circ1Ack, sizeof(circ1Ack)/sizeof(FpgaReg));
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
					"%s: done sending waveform request\n", __PRETTY_FUNCTION__);

		}
	}
}

/*
def calc_xscale(self):
    """
    Calculate monitor channel gain by combining LO, CIC and data
    truncations. Called after time scale change.
    Returns register for ccfilter.v, total gain and xscale
    """
    cic_r = self.wave_samp_per * self.cic_period
    self.time_step_mon = cic_r / self.clk_freq
    cic_bit_growth = 2 * np.log2(cic_r)
    cic_snr_bit_growth = .5 * np.log2(cic_r / 2)
    total_bit_growth = (np.log2(self.lo_dds_gain) + cic_bit_growth)

    full_shift = np.floor(total_bit_growth - cic_snr_bit_growth)
    wave_shift = int(max(0, (full_shift - self.shift_base)/2))
    self.cic_gain = 2**(total_bit_growth - (2*wave_shift + self.shift_base) + 1)
*/

int CircleWave::CalcWaveScale(int32_t wave_samp_per)
{
    unsigned int cic_r;
    float cic_bit_growth;
    float cic_snr_bit_growth;
    float total_bit_growth;
    unsigned int full_shift;
    unsigned int wave_shift;
    float cic_gain;

    cic_r =  wave_samp_per *CIC_PERIOD;
    cic_bit_growth = 2 * log2(cic_r);
    cic_snr_bit_growth = .5 * log2(cic_r / 2);
    total_bit_growth = cic_bit_growth;
//    printf("total_bit_growth: %f\n", total_bit_growth);
    full_shift = (unsigned int)floor(total_bit_growth - cic_snr_bit_growth);
//    printf("full_shift: %d\n", full_shift);
    wave_shift = (full_shift > SHIFT_BASE) ? (unsigned int)((full_shift - SHIFT_BASE)/2) : 0;
//    printf("wave_shift: %d\n", wave_shift);
    cic_gain = pow(2.0, total_bit_growth - (2*wave_shift + SHIFT_BASE) + 1);
//    printf("cic_gain: %f\n", cic_gain);

    gain_ = cic_gain;

    return wave_shift;
}

// This function assumes pFromFpga contains an ordered sequence of slow data
// buffer address-value pairs containing at least elements 17 through 42.
// Normally we request the whole thing in one UDP packet.
//
// byte 0-16: ?
// byte 17: Circle buffer count (number of waveforms digitized) MSB
// byte 18: Circle buffer count (number of waveforms digitized) LSB
// byte 19: bit 7 fault if 0, bit 6 wrap flag, bits 5-0 MSB fault address
// byte 20: LSB of fault address
// byte 21: Ch. 0 min MSB
// byte 22: Ch. 0 min LSB
// byte 23: Ch. 0 max MSB
// byte 24: Ch. 0 max LSB
// byte 25: Ch. 1 min MSB
// byte 26: Ch. 1 min LSB
// byte 27: Ch. 1 max MSB
// byte 28: Ch. 1 max LSB
// byte 29: Ch. 2 min MSB
// byte 30: Ch. 2 min LSB
// byte 31: Ch. 2 max MSB
// byte 32: Ch. 2 max LSB
// byte 33:
// byte 34:
// byte 35: time stamp LSB
// byte 36: time stamp
// byte 37: time stamp
// byte 38: time stamp
// byte 39: time stamp
// byte 40: time stamp
// byte 41: time stamp
// byte 42: time stamp MSB
asynStatus CircleWave::ProcessSlowDataReadback(const FpgaReg *pFromFpga)
{
	unsigned int i=0;
	asynStatus status = asynSuccess;
	unsigned int circleStat, oldCircleStat;
	unsigned int tagNow, tagOld;
	epicsUInt8 *offsetSlowData = (epicsUInt8*) slowData_ + SLOW_OFFSET; // offset for python code parallel

	// Verify that we got values for the expected range of addresses
	if((pFromFpga[0].addr & addrMask) > (slowAddr_ + SLOW_OFFSET))
	{
	asynPrint(pDriver_->pOctetAsynUser_, ASYN_TRACE_ERROR,
		"%s: first data point has register address 0x%x, should be no more than 0x%x\n", __PRETTY_FUNCTION__,
		(pFromFpga[0].addr & addrMask), (slowAddr_ + SLOW_OFFSET));
	}

	// Slow buffer request is packed into one UDP packet, so this is safe.
	// Test for not starting at first point or not including all points

	while ((pFromFpga[i].addr & addrMask) >= slowAddr_ && (pFromFpga[i].addr & addrMask) < slowAddr_ + slowDataBuffRegCount )
	{
		if (i>0 && ((pFromFpga[i].addr & addrMask) < (pFromFpga[i - 1].addr & addrMask)))
		{
			break;
		}
		// Usually we have all points, but just in case use register address
		// to calculate array index, rather than just using i, for our local copy.
		slowData_[(pFromFpga[i].addr & addrMask) - slowAddr_] = (pFromFpga[i].data);
		i++;
	}

	// Verify that we got values for the expected range of addresses
	if(((pFromFpga[i-1].addr & addrMask) & addrMask) < (slowAddr_ + SLOW_OFFSET + 25))
	{
	asynPrint(pDriver_->pOctetAsynUser_, ASYN_TRACE_ERROR,
		"%s: last data point has register address 0x%x, should be at least 0x%x\n", __PRETTY_FUNCTION__,
		(pFromFpga[i-1].addr & addrMask), (slowAddr_ + SLOW_OFFSET + 25));
	}

	pDriver_->doCallbacksInt8Array((epicsInt8 *)slowData_, slowDataBuffRegCount, *slowDataParamIndex_, 0);

	tagNow = offsetSlowData[16];
	tagOld = offsetSlowData[17];
	pDriver_->setIntegerParam(*tagNowParamIndex_, tagNow);
	pDriver_->setIntegerParam(*tagOldParamIndex_, tagOld);

	if(tagNow != tagOld)
	{
		printf("Parameters changed mid-data, skip this waveform. Old tag = %u, new = %u\n", tagOld, tagNow);
		tagMismatch_ = true;
		return status;
	}
	else
	{
		tagMismatch_ = false;
		printf("Parameters didn't change mid-data, don't skip this waveform. Old tag = %u, new = %u\n", tagOld, tagNow);
	}

	pDriver_->setIntegerParam(*circleCountParamIndex_, (int) ((((unsigned int) offsetSlowData[0])<<8) + (unsigned int) offsetSlowData[1]));
	pDriver_->getIntegerParam(*circleCountParamIndex_, (int*) &newCount_);
	if(newCount_ == lastCount_ + 1)
	{
		printf("Last waveform #%x, new one #%x, we're keeping up\n", lastCount_, newCount_);
	}
	else
	{
		printf("Not keeping up with waveform, missed %u.\n",
				newCount_ - lastCount_ -1);
	}
	lastCount_ = newCount_;

	pDriver_->getIntegerParam(*circleStatParamIndex_, (int *) &oldCircleStat);
	circleStat = (offsetSlowData[2]<<8)+ offsetSlowData[3];
	pDriver_->setIntegerParam(*circleStatParamIndex_, circleStat);
	cout << std::hex << "CircleStat was " << circleStat << ", now: " << (unsigned int) (offsetSlowData[2]<<8)+ (unsigned int) offsetSlowData[3] << endl;
	fault_ = !((circleStat >> 15)) & 1;
	wrap_ = ((circleStat >> 14)) & 1;
	faultAddr_ = circleStat & ((1<< 14) - 1);
	cout << "fault: " << fault_ << ", wrap: " << wrap_ << ", faultAddr: " << faultAddr_ << endl;

	for(i=4; i<16; i+=4)
	{
		mins_[(i-4)/4] = ((static_cast<int16_t>(offsetSlowData[i]))<<8 | static_cast<int16_t>(offsetSlowData[i+1]));
		maxs_[(i-4)/4] = ((static_cast<int16_t>(offsetSlowData[i+2]))<<8 | static_cast<int16_t>(offsetSlowData[i+3]));
		printf("Scale %d is min: %d, max: %d\n", (i-4)/4, mins_[(i-4)/4], maxs_[(i-4)/4]);
		pDriver_->setIntegerParam((i-4)/4, *minsParamIndex_, mins_[(i-4)/4]);
		pDriver_->setIntegerParam((i-4)/4, *maxsParamIndex_, maxs_[(i-4)/4]);

	}

	// NOTE: The values coming out look like they're in the wrong byte order, but this is how sel_waves.py does it.
	timeStamp_ = 0;
	for(i=0; i<8; i++)
	{
		timeStamp_ = (timeStamp_ << 8) | static_cast<uint64_t>(offsetSlowData[25-i]);
	}

	timeStamp_ >>= 5;

	pDriver_->setIntegerParam(*timeStampHighParamIndex_, (int) (timeStamp_>>32));
	pDriver_->setIntegerParam(*timeStampLowParamIndex_, (int) timeStamp_ & 0xFFFFFFFF);

	/* Do callbacks so higher layers see any changes */
	status = (asynStatus) pDriver_->callParamCallbacks();
	return status;

}

// parse register data, write to array PV
asynStatus CircleWave::ProcessCircIQBufReadback(const FpgaReg *pFromFpga)
{
	unsigned int regOffset = (pFromFpga->addr & addrMask) - (regStartAddr_ & addrMask);
	unsigned int bufNumber = nChan_>0? regOffset % nChan_ : 0;
	unsigned int bufIndex = nChan_>0? regOffset / nChan_ : 0;
	unsigned int rel_chan_ix = 0;
	unsigned int num_of_chans = 0;
	unsigned int abs_chan_ix = 0;
	unsigned int nPoints = CircleWave::circleBufRegCount/nChan_;
	unsigned int nFaultPoints = nPoints;
	unsigned int i;

	waveReadback_[regOffset] = pFromFpga->data;
	// avoid divide by 0 errors when waveforms are inactive
	if (nChan_ <=0)
	{
		if(regOffset == 0)
		{
		asynPrint(pDriver_->pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s can't process waveform data with 0 active channels, chan=%d\n",
				__PRETTY_FUNCTION__, nChan_);
		}

		return asynError;
	}
	if( tagMismatch_ ) // Settings changed mid-waveform, so drop it.
	{
		return asynSuccess;
		asynPrint(pDriver_->pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s settings changed mid-waveform read. Drop this one.\n",
				__PRETTY_FUNCTION__);
	}

	if (fault_)
	{
		if( wrap_) // use the regular data buffer size, but shift & wrap the data
		{
			bufIndex = (bufIndex + faultAddr_) % (CircleWave::circleBufRegCount / nChan_);
			pIQFaultBuf_[bufNumber][bufIndex] = (epicsInt16) pFromFpga->data;
		}
		else // fault data is the data from the previous waveform plus new data up to faultAddr_
		{
			pIQFaultBuf_[bufNumber][bufIndex+nPoints] = (epicsInt16) pFromFpga->data;
			nFaultPoints = nPoints + faultAddr_;
		}
	}
	else
	{
		pIQFaultBuf_[bufNumber][bufIndex] = (epicsInt16) pFromFpga->data;
	}


	// Even number addresses are not necessarily I, odd are Q

	pIQBuf_[bufNumber][bufIndex] = (epicsInt16) pFromFpga->data;
//cout << "regOffset is " << regOffset << ", waiting for " << (regEndAddr_ - regStartAddr_) << endl;
	if (regOffset == (regEndAddr_ - regStartAddr_)) // if this is the last point of the buffer
	{
		asynPrint(pDriver_->pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: got last waveform datapoint. Publishing.\n", __PRETTY_FUNCTION__);

		pDriver_->doCallbacksInt32Array(waveReadback_, CircleWave::circleBufRegCount, *rawParamIndex_, 0);
		bitset<maxWavesCount> bitset_chan_keep (chanKeep_);

		for (rel_chan_ix=0; rel_chan_ix<nChan_; ++rel_chan_ix)
		{
			num_of_chans = 0;
			abs_chan_ix = 0;
//			cout << __PRETTY_FUNCTION__ << " with " << bitset_chan_keep.to_string() << "\n";
            for (abs_chan_ix=bitset_chan_keep.size(); num_of_chans<=rel_chan_ix;num_of_chans += bitset_chan_keep.test(abs_chan_ix))
            {
                //num_of_chans = bitset_chan_keep.test(abs_chan_ix) ? ++num_of_chans : num_of_chans;
                --abs_chan_ix;
//                cout << abs_chan_ix;
            }
            //--abs_chan_ix;
//			cout << "relative index:" << rel_chan_ix << " total: " << num_of_chans << " abs index:" << abs_chan_ix << "\n";

			if(abs_chan_ix%2 == 0) // if this is an I channel
			{
				asynPrint(pDriver_->pOctetAsynUser_, ASYN_TRACEIO_DRIVER, "%s publishing Q waveform %d, from relative channel %d\n",
						__PRETTY_FUNCTION__ , abs_chan_ix/2, rel_chan_ix);

				pDriver_->doCallbacksInt32Array(pIQBuf_[rel_chan_ix], nPoints, *qParamIndex_, abs_chan_ix/2);
				if (fault_)
				{
					pDriver_->doCallbacksInt32Array(pIQFaultBuf_[rel_chan_ix], nFaultPoints, *qFaultParamIndex_, abs_chan_ix/2);
				}
//				cout << "bitset for " << abs_chan_ix << ": " << bitset_chan_keep.test(abs_chan_ix);
//				cout << ", bitset for " << abs_chan_ix-1 << ": " << bitset_chan_keep.test(abs_chan_ix+1) << endl;
				if(bitset_chan_keep.test(abs_chan_ix+1)) // if the corresponding Q is also active
				{
//					cout << "calculating A/P for shell " << shellNum << endl;
					for (i=0; i<nPoints; i++)
					{
						try
						{
							pABuf_[abs_chan_ix/2][i] = pAFaultBuf_[abs_chan_ix/2][i] = (epicsFloat32) hypot(pIQBuf_[rel_chan_ix][i], pIQBuf_[rel_chan_ix-1][i])/gain_;
							pPBuf_[abs_chan_ix/2][i] = pPFaultBuf_[abs_chan_ix/2][i] = (epicsFloat32) (atan2(pIQBuf_[rel_chan_ix-1][i], pIQBuf_[rel_chan_ix][i]));
							cout << "relative waveform " << rel_chan_ix << ", physical channel " << abs_chan_ix/2 << ", I = " << pIQBuf_[rel_chan_ix-1][i] << ", Q = " << pIQBuf_[rel_chan_ix][i]<< ", A = " << pABuf_[abs_chan_ix/2][i] << ", P = " << pPBuf_[abs_chan_ix/2][i] << endl;
						}
						catch (std::exception& e)
						{
							printf("pIQBufI_[%u][%u] = %d, ", rel_chan_ix, i, pIQBuf_[rel_chan_ix][i]);
							printf("pIQBufQ_[%u][%u] = %d, ", rel_chan_ix-1, i, pIQBuf_[rel_chan_ix-1][i]);
							std::cerr << "exception caught: " << e.what() << endl;
						}
					}

					asynPrint(pDriver_->pOctetAsynUser_, ASYN_TRACEIO_DRIVER, "%s publishing amplitude and phase waveforms %d, from relative channels %d/%d\n",
							__PRETTY_FUNCTION__ , abs_chan_ix/2, rel_chan_ix-1, rel_chan_ix);
					pDriver_->doCallbacksFloat32Array(pABuf_[abs_chan_ix/2], nPoints, *aParamIndex_, abs_chan_ix/2);
					pDriver_->doCallbacksFloat32Array(pPBuf_[abs_chan_ix/2], nPoints, *pParamIndex_, abs_chan_ix/2);
					std::fill( pABuf_[abs_chan_ix/2],
							pABuf_[abs_chan_ix/2] + sizeof( pABuf_[abs_chan_ix/2] )/sizeof( *pABuf_[abs_chan_ix/2]), 0 );
					std::fill( pPBuf_[abs_chan_ix/2],
							pPBuf_[abs_chan_ix/2] + sizeof( pPBuf_[abs_chan_ix/2] )/sizeof( *pPBuf_[abs_chan_ix/2]), 0 );

					if (fault_)
					{
						if( not wrap_)
						{
							for (i=nPoints; i<nFaultPoints; i++)
							{
								try
								{
									pAFaultBuf_[abs_chan_ix/2][i] = (epicsFloat32) hypot(pIQFaultBuf_[rel_chan_ix][i], pIQFaultBuf_[rel_chan_ix-1][i])/gain_;
									pPFaultBuf_[abs_chan_ix/2][i] = (epicsFloat32) (atan2(pIQFaultBuf_[rel_chan_ix-1][i], pIQFaultBuf_[rel_chan_ix][i]));
								}
								catch (std::exception& e)
								{
									printf("pIQFaultBufI_[%u][%u] = %d, ", rel_chan_ix, i, pIQFaultBuf_[rel_chan_ix][i]);
									printf("pIQFaultBufQ_[%u][%u] = %d, ", rel_chan_ix-1, i, pIQFaultBuf_[rel_chan_ix-1][i]);
									std::cerr << "exception caught: " << e.what() << endl;
								}
							}
						}
						pDriver_->doCallbacksFloat32Array(pAFaultBuf_[abs_chan_ix/2], nFaultPoints, *aFaultParamIndex_, abs_chan_ix/2);
						pDriver_->doCallbacksFloat32Array(pPFaultBuf_[abs_chan_ix/2], nFaultPoints, *pFaultParamIndex_, abs_chan_ix/2);
					}
				}
				else // This is an I waveform, but the corresponding Q isn't active, so clear A and P
				{
					std::fill( pABuf_[abs_chan_ix/2],
							pABuf_[abs_chan_ix/2] + sizeof( pABuf_[abs_chan_ix/2] )/sizeof( *pABuf_[abs_chan_ix/2]), 0 );
					std::fill( pPBuf_[abs_chan_ix/2],
							pPBuf_[abs_chan_ix/2] + sizeof( pPBuf_[abs_chan_ix/2] )/sizeof( *pPBuf_[abs_chan_ix/2]), 0 );
					pDriver_->doCallbacksFloat32Array(pABuf_[abs_chan_ix/2], 1, *aParamIndex_, abs_chan_ix/2);
					pDriver_->doCallbacksFloat32Array(pPBuf_[abs_chan_ix/2], 1, *pParamIndex_, abs_chan_ix/2);
				}

			}
			else
			{
				asynPrint(pDriver_->pOctetAsynUser_, ASYN_TRACEIO_DRIVER, "%s publishing I waveform %d, from relative channel %d\n",
						__PRETTY_FUNCTION__ , abs_chan_ix/2, rel_chan_ix);
//				cout << "publishing I waveform " << abs_chan_ix/2 << ", from relative channel" << rel_chan_ix << endl;
				pDriver_->doCallbacksInt32Array(pIQBuf_[rel_chan_ix], nPoints, *iParamIndex_, abs_chan_ix/2);
				if (fault_)
				{
					pDriver_->doCallbacksInt32Array(pIQFaultBuf_[rel_chan_ix], nFaultPoints, *iFaultParamIndex_, abs_chan_ix/2);
				}
			}

			// TODO: fill with 0 after publishing, change size of unused channels to 0
//			std::fill( pCircIQBuf1I_[i], pCircIQBuf1I_[i] + sizeof( pCircIQBuf1I_[i] )/sizeof( *pCircIQBuf1I_[i]), 1 );
//			std::fill( pCircIQBuf1Q_[i], pCircIQBuf1Q_[i] + sizeof( pCircIQBuf1Q_[i] )/sizeof( *pCircIQBuf1Q_[i]), 1 );
//			std::fill( pCircIQBuf1A_[i], pCircIQBuf1A_[i] + sizeof( pCircIQBuf1A_[i] )/sizeof( *pCircIQBuf1A_[i]), 1 );
//			std::fill( pCircIQBuf1P_[i], pCircIQBuf1P_[i] + sizeof( pCircIQBuf1P_[i] )/sizeof( *pCircIQBuf1P_[i]), 1 );
		}
	}

	return asynSuccess;
}

/**  Extract register address and data from the received message and set the appropriate
 * asyn parameter.
 * Some registers have a "new waveform data ready" flag. If they have this and it is set,
 * set weveIsReady to true.
 * Note: This function should not set waveIsReady to false. That is done by a loop in the
 * calling function.
* \param[in] pFromFpga Data returned from the FPGA for a single register
* \param[in] waveIsReady A flag that gets set to true if the appropriate bit was set by the FPGA
*/
asynStatus scllrfPRCextra::processRegReadback(const FpgaReg *pFromFpga, bool &waveIsReady)
{
	asynStatus status = asynSuccess;
	assert(pFromFpga->addr&flagReadMask); // This function is only for read registers
	epicsInt32 tmpData;

	/* Map address to parameter, set the parameter in the parameter library. */
	switch (pFromFpga->addr)
    {
    case ModuloRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_ModuloR,
				(pFromFpga->data & ModuloMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				ModuloRString,
				(unsigned ) pFromFpga->data & ModuloMask);
		iFrequency = ADCfrequency * ((phaseStepH + (phaseStepL/(4096-phaseModulo))));

	break;

    case PhaseStepHRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_PhaseStepHR,
				(pFromFpga->data & PhaseStepHMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				PhaseStepHRString,
				(unsigned ) pFromFpga->data & PhaseStepHMask);
		iFrequency = ADCfrequency * ((phaseStepH + (phaseStepL/(4096-phaseModulo))));
	break;

    case PhaseStepLRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_PhaseStepLR,
				(pFromFpga->data & PhaseStepLMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				PhaseStepLRString,
				(unsigned ) pFromFpga->data & PhaseStepLMask);
		iFrequency = ADCfrequency * ((phaseStepH + (phaseStepL/(4096-phaseModulo))));
	break;

    case TraceStatus1RAdr|flagReadMask:
		status = (asynStatus) setIntegerParam(p_TraceStatus1R,
				(pFromFpga->data & TraceStatus1Mask));
		if (pFromFpga->data & waveIsReadyMask)
		{
			waveIsReady = true;
		}
		// Calculate number of points per waveform, and update request
		// waveform messages if it has changed.
		if(npt_ != (size_t) (1 << ((pFromFpga->data & nptMask)>> 24)))
		{
			npt_ = 1 << ((pFromFpga->data & nptMask)>> 24);

			if(npt_ > (traceIQWaveRegCount/4)) // protect against register saying more points than buffer space
			{
				npt_ = traceIQWaveRegCount/4;
			}
			fillTraceIQWavReqMsg();
		}
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				TraceStatus1RString,
				(unsigned ) pFromFpga->data & TraceStatus1Mask);
	break;

    case TraceKeepRAdr|flagReadMask:
		tmpData = pFromFpga->data & TraceKeepMask;

		status = (asynStatus) setUIntDigitalParam(p_TraceKeepR,
				(pFromFpga->data & TraceKeepMask) , TraceKeepMask);
		// Keep read and write consistent for this one
		status = (asynStatus) setUIntDigitalParam(p_TraceKeepW,
				(pFromFpga->data & TraceKeepMask) , TraceKeepMask);
		// Count the number of bits set
		for (nchan_ = 0; tmpData; nchan_++)
		{
		  tmpData &= tmpData - 1; // clear the least significant bit set
		}
		setIntegerParam(p_IQNActive, nchan_);
//	    printf("%s TraceKeepRAdr says %d active channels\n",__PRETTY_FUNCTION__,nchan_);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				TraceKeepRString,
				(unsigned ) pFromFpga->data & TraceKeepMask);
	break;

    case LlrfCircleReadyRAdr|flagReadMask:
	status = (asynStatus) setUIntDigitalParam(p_LlrfCircleReadyR,
			(pFromFpga->data & LlrfCircleReadyMask) , LlrfCircleReadyMask);
		// if flags are set for any active channels,
		if ( (pFromFpga->data & 0x3) &&
					// and there isn't a pending waveform read, and there is at least one active channel
					(newCircIQBufAvailable_ == newCircIQBufRead_) && (shell0CircBuf_.nChan_+shell1CircBuf_.nChan_ > 0))
		{
			// Set the message counter with a "new waveform" notification
			// to the message counter value for the message we just received
			newCircIQBufAvailable_ = lastResponseCount_;

			reqCircIQBufEvent_.signal();
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,"%s: new waveform data available, signaling the waveform requester\n",
					__PRETTY_FUNCTION__);
		}
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				LlrfCircleReadyRString,
				(unsigned ) pFromFpga->data & LlrfCircleReadyMask);
	break;

    case Shell0DspWaveSampPerRAdr|flagReadMask:
	epicsInt32 last_wave_samp_per;
	unsigned int wave_shift;
	epicsFloat64 wave_time_step;
	// Protect against read errors or whatever else could cause implausible readbacks
	tmpData = (pFromFpga->data & Shell0DspWaveSampPerMask) >= 1? (pFromFpga->data & Shell0DspWaveSampPerMask): 1;

	getIntegerParam(p_Shell0DspWaveSampPerR, &last_wave_samp_per);
	status = (asynStatus) setIntegerParam(p_Shell0DspWaveSampPerR,
			(pFromFpga->data & Shell0DspWaveSampPerMask) );
	if (last_wave_samp_per != pFromFpga->data)
	{
		// Update waveform scale and Time Step
		printf("new_wave_samp_per: %d\n", pFromFpga->data);
		wave_shift = shell0CircBuf_.CalcWaveScale(tmpData);
		wave_time_step = tmpData * CircleWave::CIC_PERIOD / CircleWave::CLK_FREQ;

		pasynUserSelf->reason = p_Shell0DspWaveShiftW;
		writeInt32(pasynUserSelf, wave_shift & Shell0DspWaveShiftMask);

		setDoubleParam(p_Shell0TimeStep, wave_time_step);
		printf("wave_time_step: %e\n", wave_time_step);
	}
	asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
			"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
			Shell0DspWaveSampPerRString,
			(unsigned ) pFromFpga->data & Shell0DspWaveSampPerMask);
	break;

    case Shell1DspWaveSampPerRAdr|flagReadMask:
	// Protect against read errors or whatever else could cause implausible readbacks
	tmpData = (pFromFpga->data & Shell1DspWaveSampPerMask) >= 1? (pFromFpga->data & Shell1DspWaveSampPerMask): 1;

	getIntegerParam(p_Shell1DspWaveSampPerR, &last_wave_samp_per);
	status = (asynStatus) setIntegerParam(p_Shell1DspWaveSampPerR,
			(pFromFpga->data & Shell1DspWaveSampPerMask) );
	if (last_wave_samp_per != pFromFpga->data)
	{
		// Update waveform scale and Time Step
		printf("new_wave_samp_per: %d\n", pFromFpga->data);
        wave_shift = shell1CircBuf_.CalcWaveScale(tmpData);
        wave_time_step = tmpData * CircleWave::CIC_PERIOD / CircleWave::CLK_FREQ;

        pasynUserSelf->reason = p_Shell1DspWaveShiftW;
		writeInt32(pasynUserSelf, wave_shift & Shell1DspWaveShiftMask);

        setDoubleParam(p_Shell1TimeStep, wave_time_step);
        printf("wave_time_step: %e\n", wave_time_step);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=1x%x\n", __PRETTY_FUNCTION__,
				Shell1DspWaveSampPerRString,
				(unsigned ) pFromFpga->data & Shell1DspWaveSampPerMask);
    }
	break;

    case Shell0DspChanKeepRAdr|flagReadMask:
		tmpData = pFromFpga->data & Shell0DspChanKeepMask;
		status = (asynStatus) setUIntDigitalParam(p_Shell0DspChanKeepR,
				(pFromFpga->data & Shell0DspChanKeepMask) , Shell0DspChanKeepMask);
		// Keep read and write consistent for this one.
		status = (asynStatus) setUIntDigitalParam(p_Shell0DspChanKeepW,
				(pFromFpga->data & Shell0DspChanKeepMask) , Shell0DspChanKeepMask);

		shell0CircBuf_.chanKeep_ = tmpData;
		status = (asynStatus) setUIntDigitalParam(p_Circ0BufChanEnable,
				DeInterleaveBits(shell0CircBuf_.chanKeep_), Shell0DspChanKeepMask);

		// Count the number of bits set
		for (shell0CircBuf_.nChan_ = 0; tmpData; shell0CircBuf_.nChan_++)
		{
		  tmpData &= tmpData - 1; // clear the least significant bit set
		}
		setIntegerParam(p_Circ0NActive, shell0CircBuf_.nChan_);
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell0DspChanKeepRString,
				(unsigned ) pFromFpga->data & Shell0DspChanKeepMask);
	break;

    case Shell1DspChanKeepRAdr|flagReadMask:
		tmpData = pFromFpga->data & Shell1DspChanKeepMask;
		status = (asynStatus) setUIntDigitalParam(p_Shell1DspChanKeepR,
				(pFromFpga->data & Shell1DspChanKeepMask), Shell1DspChanKeepMask);
		// Keep read and write consistent for this one.
		status = (asynStatus) setUIntDigitalParam(p_Shell1DspChanKeepW,
				(pFromFpga->data & Shell1DspChanKeepMask), Shell1DspChanKeepMask);

		shell1CircBuf_.chanKeep_ = tmpData;
		status = (asynStatus) setUIntDigitalParam(p_Circ1BufChanEnable,
				DeInterleaveBits(shell1CircBuf_.chanKeep_), Shell1DspChanKeepMask);

	// Count the number of bits set
	for (shell1CircBuf_.nChan_ = 0; tmpData; shell1CircBuf_.nChan_++)
	{
		tmpData &= tmpData - 1; // clear the least significant bit set
	}
	setIntegerParam(p_Circ1NActive, shell1CircBuf_.nChan_);
	asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
			"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
			Shell1DspChanKeepRString,
			(unsigned ) pFromFpga->data & Shell1DspChanKeepMask);
	break;

    case Shell0SlowDataRAdr |flagReadMask:
	status = shell0CircBuf_.ProcessSlowDataReadback(pFromFpga);
	break;

    case Shell1SlowDataRAdr |flagReadMask:
	status = shell1CircBuf_.ProcessSlowDataReadback(pFromFpga);
	break;

    case MagicRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_MagicR,
				(pFromFpga->data & MagicMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				MagicRString,
				(unsigned int) (pFromFpga->data & MagicMask));
	break;

    case DspFlavorRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_DspFlavorR,
				(pFromFpga->data & DspFlavorMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				DspFlavorRString,
				(unsigned int) (pFromFpga->data & DspFlavorMask));
	break;

    case BuildYearRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_BuildYearR,
				(pFromFpga->data & BuildYearMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				BuildYearRString,
				(unsigned int) (pFromFpga->data & BuildYearMask));
	break;

    case BuildMonthRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_BuildMonthR,
				(pFromFpga->data & BuildMonthMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				BuildMonthRString,
				(unsigned int) (pFromFpga->data & BuildMonthMask));
	break;

    case BuildDayRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_BuildDayR,
				(pFromFpga->data & BuildDayMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				BuildDayRString,
				(unsigned int) (pFromFpga->data & BuildDayMask));
	break;

    case BuildHourRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_BuildHourR,
				(pFromFpga->data & BuildHourMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				BuildHourRString,
				(unsigned int) (pFromFpga->data & BuildHourMask));
	break;

    case BuildMinuteRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_BuildMinuteR,
				(pFromFpga->data & BuildMinuteMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				BuildMinuteRString,
				(unsigned int) (pFromFpga->data & BuildMinuteMask));
	break;

    case CodeIsCleanRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_CodeIsCleanR,
				(pFromFpga->data & CodeIsCleanMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				CodeIsCleanRString,
				(unsigned int) (pFromFpga->data & CodeIsCleanMask));
	break;

    case ToolRevRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_ToolRevR,
				(pFromFpga->data & ToolRevMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				ToolRevRString,
				(unsigned int) (pFromFpga->data & ToolRevMask));
	break;

    case UserRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_UserR,
				(pFromFpga->data & UserMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				UserRString,
				(unsigned int) (pFromFpga->data & UserMask));
	break;

    case BoardTypeRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_BoardTypeR,
				(pFromFpga->data & BoardTypeMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				BoardTypeRString,
				(unsigned int) (pFromFpga->data & BoardTypeMask));
	break;

    case VersionRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_VersionR,
				(pFromFpga->data & VersionMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				VersionRString,
				(unsigned int) (pFromFpga->data & VersionMask));
	break;

    case GitSha1ARAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_GitSha1AR,
				(pFromFpga->data & GitSha1AMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				GitSha1ARString,
				(unsigned int) (pFromFpga->data & GitSha1AMask));
	break;

    case GitSha1BRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_GitSha1BR,
				(pFromFpga->data & GitSha1BMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				GitSha1BRString,
				(unsigned int) (pFromFpga->data & GitSha1BMask));
	break;

    case GitSha1CRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_GitSha1CR,
				(pFromFpga->data & GitSha1CMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				GitSha1CRString,
				(unsigned int) (pFromFpga->data & GitSha1CMask));
	break;

    case GitSha1DRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_GitSha1DR,
				(pFromFpga->data & GitSha1DMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				GitSha1DRString,
				(unsigned int) (pFromFpga->data & GitSha1DMask));
	break;

    case GitSha1ERAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_GitSha1ER,
				(pFromFpga->data & GitSha1EMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				GitSha1ERString,
				(unsigned int) (pFromFpga->data & GitSha1EMask));
	break;

    case GitSha1FRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_GitSha1FR,
				(pFromFpga->data & GitSha1FMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				GitSha1FRString,
				(unsigned int) (pFromFpga->data & GitSha1FMask));
	break;

    case GitSha1GRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_GitSha1GR,
				(pFromFpga->data & GitSha1GMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				GitSha1GRString,
				(unsigned int) (pFromFpga->data & GitSha1GMask));
	break;

    case GitSha1HRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_GitSha1HR,
				(pFromFpga->data & GitSha1HMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				GitSha1HRString,
				(unsigned int) (pFromFpga->data & GitSha1HMask));
	break;

    case GitSha1IRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_GitSha1IR,
				(pFromFpga->data & GitSha1IMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				GitSha1IRString,
				(unsigned int) (pFromFpga->data & GitSha1IMask));
	break;

    case GitSha1JRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_GitSha1JR,
				(pFromFpga->data & GitSha1JMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				GitSha1JRString,
				(unsigned int) (pFromFpga->data & GitSha1JMask));
	break;

    case GitSha1KRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_GitSha1KR,
				(pFromFpga->data & GitSha1KMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				GitSha1KRString,
				(unsigned int) (pFromFpga->data & GitSha1KMask));
	break;

    case GitSha1LRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_GitSha1LR,
				(pFromFpga->data & GitSha1LMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				GitSha1LRString,
				(unsigned int) (pFromFpga->data & GitSha1LMask));
	break;

    case GitSha1MRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_GitSha1MR,
				(pFromFpga->data & GitSha1MMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				GitSha1MRString,
				(unsigned int) (pFromFpga->data & GitSha1MMask));
	break;

    case GitSha1NRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_GitSha1NR,
				(pFromFpga->data & GitSha1NMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				GitSha1NRString,
				(unsigned int) (pFromFpga->data & GitSha1NMask));
	break;

    case GitSha1ORAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_GitSha1OR,
				(pFromFpga->data & GitSha1OMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				GitSha1ORString,
				(unsigned int) (pFromFpga->data & GitSha1OMask));
	break;

    case GitSha1PRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_GitSha1PR,
				(pFromFpga->data & GitSha1PMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				GitSha1PRString,
				(unsigned int) (pFromFpga->data & GitSha1PMask));
	break;

    case GitSha1QRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_GitSha1QR,
				(pFromFpga->data & GitSha1QMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				GitSha1QRString,
				(unsigned int) (pFromFpga->data & GitSha1QMask));
	break;

    case GitSha1RRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_GitSha1RR,
				(pFromFpga->data & GitSha1RMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				GitSha1RRString,
				(unsigned int) (pFromFpga->data & GitSha1RMask));
	break;

    case GitSha1SRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_GitSha1SR,
				(pFromFpga->data & GitSha1SMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				GitSha1SRString,
				(unsigned int) (pFromFpga->data & GitSha1SMask));
	break;

    case GitSha1TRAdr|flagReadMask:

		status = (asynStatus) setIntegerParam(p_GitSha1TR,
				(pFromFpga->data & GitSha1TMask) );
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: readback for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				GitSha1TRString,
				(unsigned int) (pFromFpga->data & GitSha1TMask));
		catGitSHA1();
		break;

	default:
		if( traceIQWavesStart <= (pFromFpga->addr & addrMask) && (pFromFpga->addr & addrMask) <= traceIQWavesEnd )
		{
			////printf("%s waveform address 0x%x, value %d\n", __PRETTY_FUNCTION__, (pFromFpga->addr & addrMask), pFromFpga->data);
			processTraceIQWaveReadback(pFromFpga);
		}
		else
		if( Shell0CircleDataRAdr <= (pFromFpga->addr & addrMask) && (pFromFpga->addr & addrMask) <= shell0CircBuf_.GetEndAddr() )
		{
			printf("%s waveform addres 0x%x, value %d\n", __PRETTY_FUNCTION__, (pFromFpga->addr & addrMask), pFromFpga->data);
			shell0CircBuf_.ProcessCircIQBufReadback(pFromFpga);
		}
		else
		if( Shell1CircleDataRAdr <= (pFromFpga->addr & addrMask) && (pFromFpga->addr & addrMask) <= shell1CircBuf_.GetEndAddr() )
		{
//			printf("%s waveform addres 0x%x, value %d\n", __PRETTY_FUNCTION__, (pFromFpga->addr & addrMask), pFromFpga->data);
			shell1CircBuf_.ProcessCircIQBufReadback(pFromFpga);
		}
		else
		if(Shell0SlowDataRAdr + 1 <= (pFromFpga->addr & addrMask) && (pFromFpga->addr & addrMask) <= Shell0SlowDataRAdr + CircleWave::slowDataBuffRegCount - 1)
		{
			// Ignore this, it's handled in the slow data case statement
		}
		else
		if(Shell1SlowDataRAdr + 1 <= (pFromFpga->addr & addrMask) && (pFromFpga->addr & addrMask) <= Shell1SlowDataRAdr + CircleWave::slowDataBuffRegCount - 1)
		{
			// Ignore this, it's handled in the slow data case statement
		}
		else
		{
                       // //printf("%s passing processing of register 0c%x to parent class\n", __PRETTY_FUNCTION__, (pFromFpga->addr & addrMask));
			status = scllrfPRCDriver::processRegReadback(pFromFpga, waveIsReady);
		}
		break;
    }

    return status;
}

/**  Extract register address and data from the received message and set the appropriate
 * asyn parameter.
 * Some registers have a "new waveform data ready" flag. If they have this and it is set,
 * set weveIsReady to true.
 * Note: This function should not set waveIsReady to false. That is done by a loop in the
 * calling function.
* \param[in] pFromFpga Data returned from the FPGA for a single register
* \param[in] waveIsReady A flag that gets set to true if the appropriate bit was set by the FPGA
*/
asynStatus scllrfPRCextra::processRegWriteResponse(const FpgaReg *pFromFpga)
{
	asynStatus status = asynSuccess;
	epicsInt32 valueSet[maxMsgSize/sizeof(FpgaReg)]; // Put the value sent to the FPGA here for comparison
	epicsUInt32 uValueSet[maxMsgSize/sizeof(FpgaReg)];
//	epicsUInt32 uValueSet;
	epicsInt32 tmpData;
	epicsInt32 errorCount;
//  variables that may be useful for checking array data
//	asynUser *pAsynArrayUser;
//	unsigned int i;
	assert(!(pFromFpga->addr&flagReadMask)); // This function is only for read registers

	/* Map address to parameter, set the parameter in the parameter library. */
	switch (pFromFpga->addr)
    {
    case ModuloWAdr:
		status = (asynStatus) getIntegerParam(p_ModuloW, valueSet );
		if( (int32_t)(valueSet[0] & ModuloMask) == (pFromFpga->data & ModuloMask))
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: echo for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				ModuloWString, (unsigned ) pFromFpga->data & ModuloMask);
			iFrequency = ADCfrequency * ((phaseStepH + (phaseStepL/(4096-phaseModulo))));
		}
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				ModuloWString, valueSet[0] & ModuloMask, (unsigned ) pFromFpga->data & ModuloMask);
			status = asynError;
			setParamStatus(p_ModuloW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case PhaseStepHWAdr:
		status = (asynStatus) getIntegerParam(p_PhaseStepHW, valueSet );
		if( (int32_t)(valueSet[0] & PhaseStepHMask) == (pFromFpga->data & PhaseStepHMask))
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: echo for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				PhaseStepHWString, (unsigned ) pFromFpga->data & PhaseStepHMask);
			iFrequency = ADCfrequency * ((phaseStepH + (phaseStepL/(4096-phaseModulo))));
		}
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				PhaseStepHWString, valueSet[0] & PhaseStepHMask, (unsigned ) pFromFpga->data & PhaseStepHMask);
			status = asynError;
			setParamStatus(p_PhaseStepHW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case PhaseStepLWAdr:
		status = (asynStatus) getIntegerParam(p_PhaseStepLW, valueSet );
		if( (int32_t)(valueSet[0] & PhaseStepLMask) == (pFromFpga->data & PhaseStepLMask))
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: echo for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				PhaseStepLWString, (unsigned ) pFromFpga->data & PhaseStepLMask);
			iFrequency = ADCfrequency * ((phaseStepH + (phaseStepL/(4096-phaseModulo))));
		}
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				PhaseStepLWString, valueSet[0] & PhaseStepLMask, (unsigned ) pFromFpga->data & PhaseStepLMask);
			status = asynError;
			setParamStatus(p_PhaseStepLW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case BufTrigWAdr:
		status = (asynStatus) getUIntDigitalParam(p_BufTrigW, uValueSet , BufTrigMask);
		if( (uValueSet[0] & BufTrigMask) == (pFromFpga->data & BufTrigMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: echo for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				BufTrigWString, (unsigned ) pFromFpga->data & BufTrigMask);
		else
		{
			// We don't care, since this is typically part of a canned sequence of writes
		}

		break;
    case TraceKeepWAdr:
		status = (asynStatus) getIntegerParam(p_TraceKeepW, valueSet);
		if( (valueSet[0] & TraceKeepMask) == (pFromFpga->data & TraceKeepMask))
		{		// Count the number of bits set
			tmpData = (pFromFpga->data & TraceKeepMask);
			for (nchan_ = 0; tmpData; nchan_++)
			{
			  tmpData &= tmpData - 1; // clear the least significant bit set
			}
			setIntegerParam(p_IQNActive, nchan_);
		    printf("%s TraceKeepWAdr says %d active channels\n",__PRETTY_FUNCTION__,nchan_);

			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: echo for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				TraceKeepWString, (unsigned ) pFromFpga->data & TraceKeepMask);
		}
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				TraceKeepWString, valueSet[0] & TraceKeepMask, (unsigned ) pFromFpga->data & TraceKeepMask);
			status = asynError;
			setParamStatus(p_TraceKeepW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;
    case TraceResetWeWAdr:
		status = (asynStatus) getUIntDigitalParam(p_TraceResetWeW, uValueSet , TraceResetWeMask);
		if( (uValueSet[0] & TraceResetWeMask) == (pFromFpga->data & TraceResetWeMask))
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: echo for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				TraceResetWeWString, (unsigned ) pFromFpga->data & TraceResetWeMask);
		else
		{
			// We don't care, since there are typically several writes to this per message: 0, 1, 0
		}

		break;
    case CircleBufFlipWAdr:
    	// This register is written by waveform request, outside EPICS.
    	// Don't worry about asyn parameter values.
		asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: echo for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				CircleBufFlipWString, (unsigned ) pFromFpga->data & CircleBufFlipMask);

		break;

    case Shell0DspChanKeepWAdr:
		status = (asynStatus) getUIntDigitalParam(p_Shell0DspChanKeepW, uValueSet , Shell0DspChanKeepMask);

		if( (uValueSet[0] & Shell0DspChanKeepMask) == (pFromFpga->data & Shell0DspChanKeepMask))
		{
			// Count the number of bits set
			tmpData = (pFromFpga->data & Shell0DspChanKeepMask);
			for (shell0CircBuf_.nChan_ = 0; tmpData; shell0CircBuf_.nChan_++)
			{
			  tmpData &= tmpData - 1; // clear the least significant bit set
			}
			setIntegerParam(p_Circ0NActive, shell0CircBuf_.nChan_);

			printf("%s Shell0DspChanKeepWAdr says %d active channels\n",__PRETTY_FUNCTION__,shell0CircBuf_.nChan_);
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: echo for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell0DspChanKeepWString, (unsigned ) pFromFpga->data & Shell0DspChanKeepMask);
		}
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Shell0DspChanKeepWString, uValueSet[0] & Shell0DspChanKeepMask, (unsigned ) pFromFpga->data & Shell0DspChanKeepMask);
			status = asynError;
			setParamStatus(p_Shell0DspChanKeepW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;

    case Shell1DspChanKeepWAdr:
		status = (asynStatus) getUIntDigitalParam(p_Shell1DspChanKeepW, uValueSet , Shell1DspChanKeepMask);
		if( (uValueSet[0] & Shell1DspChanKeepMask) == (pFromFpga->data & Shell1DspChanKeepMask))
		{
			// Count the number of bits set
			tmpData = (pFromFpga->data & Shell1DspChanKeepMask);
			for (shell1CircBuf_.nChan_ = 0; tmpData; shell1CircBuf_.nChan_++)
			{
			  tmpData &= tmpData - 1; // clear the least significant bit set
			}
			setIntegerParam(p_Circ1NActive, shell1CircBuf_.nChan_);
			printf("%s Shell1DspChanKeepWAdr says %d active channels\n",__PRETTY_FUNCTION__,shell1CircBuf_.nChan_);
			asynPrint(pOctetAsynUser_, ASYN_TRACEIO_DRIVER,
				"%s: echo for address=%s, value=0x%x\n", __PRETTY_FUNCTION__,
				Shell1DspChanKeepWString, (unsigned ) pFromFpga->data & Shell1DspChanKeepMask);
		}
		else
		{
			asynPrint(pOctetAsynUser_, ASYN_TRACE_ERROR,
				"%s: value sent to %s, value=0x%x, doesn't match echoed value=0x%x\n", __PRETTY_FUNCTION__,
				Shell1DspChanKeepWString, uValueSet[0] & Shell1DspChanKeepMask, (unsigned ) pFromFpga->data & Shell1DspChanKeepMask);
			status = asynError;
			setParamStatus(p_Shell1DspChanKeepW, status);
			getIntegerParam(p_CommErrorCount, &errorCount);
			setIntegerParam(p_CommErrorCount, ++errorCount);
		}

		break;

	default:
// TODO: Add checking for arrays. Until then, we'll hit "default" for array values, so not really an error. GWB 8-23-2016
//		getIntegerParam(p_CommErrorCount, &errorCount);
//		setIntegerParam(p_CommErrorCount, errorCount + 1);
		status = scllrfPRCDriver::processRegWriteResponse(pFromFpga);

		break;
    }

	// TODO: handle arrays

    return status;
}



extern "C" {

/* Configuration routine.  Called directly, or from the iocsh function below */

/** EPICS iocsh callable function to call constructor for the scllrfPRC class.
 * \param[in] portName The name of the asyn port driver to be created.
 * \param[in] netPortName The name of the asynIPport this will use to communicate */
int scllrfPRCextraConfigure(const char *drvPortName, const char *netPortName)
{
	new scllrfPRCextra(drvPortName, netPortName);
	return asynSuccess;
}


/* EPICS iocsh shell commands */

static const iocshArg initArg0 = { "drvPortName",iocshArgString};
static const iocshArg initArg1 = { "IP port name",iocshArgString};
static const iocshArg * const initArgs[] = {&initArg0,
		&initArg1};

static const iocshFuncDef initFuncDef = {"scllrfPRCextraConfigure",2,initArgs};
static void initCallFunc(const iocshArgBuf *args)
{
	scllrfPRCextraConfigure(args[0].sval, args[1].sval);
}

void scllrfPRCextraRegister(void)
{
	iocshRegister(&initFuncDef,initCallFunc);
}

epicsExportRegistrar(scllrfPRCextraRegister);

}




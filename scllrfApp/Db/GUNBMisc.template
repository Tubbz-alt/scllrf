#! Generated by VisualDCT v2.6
#! DBDSTART
#! DBDEND

# Macros:
# P - Prefix matching what the register
#Make PVs for pulse width in ms, pulse frequency in Hz, and duty cycle in %, so that they calculate each other. Leave raw register values in raw counts.

# Bit width of pulse parameters might change, but the math is easy and won't change.
# ADC counts are a multiple of IF, which is 1320MHz/14 or 1320000kHz/14

# User interface PV in us
record(ao, "$(P)REP_PERIOD")
{
	field( DESC, "Pulsed mode pulse period")
	field( LOPR, "0")
	field( DRVL, "0")
	field( EGU, "ms")
	field( FLNK, "$(P)REP_PERIOD_U_TO_R")
	field( PREC, "5")
}
# Using a calcout instead of ao because ao misbehaved with SDIS loop breaking
record(calcout, "$(P)REP_PERIOD_U_TO_R")
{
	field( DESC, "Convert EGU to raw register value")
	field( INPA, "$(P)REP_PERIOD PP")
# 1/IF, or 14/1320 MHz. 1320000 is kHz, to go with ms, round to multiples of 132*2
	field( CALC, "FLOOR(0.5+(A*1320000/14)/132)")
	field( EGU, "ms")
	field( LOPR, "0")
	field( OUT, "$(P)$(CHASSIS)REP_PERIOD_W PP MS")
	field( PREC, "5")
}

record( ao, "$(P)$(CHASSIS)REP_PERIOD_W"){
	field( FLNK, "$(P)REP_PERIOD_Sync")
	field( EGU, "IF counts")
}

record( calcout, "$(P)REP_PERIOD_Sync"){
	field( INPA,  "$(P)$(CHASSIS)REP_PERIOD_W PP MS")
#	field( OMSL, "closed_loop")
	field( OUT,  "$(P)REP_PERIOD PP MS")
	field( SDIS, "$(P)REP_PERIOD_U_TO_R.PACT")
	field( DISV, "1")
	field( EGU, "ms")
# time in us is 1320MHz/14, 1 IF cycle per ADC count
	field( CALC, "A*132*14/1320000")
	field(FLNK, "$(P)REP_P_TO_F")
	field( PREC, "5")
####xxxx iS THIS CAUSING A WRITE OF 0 ON STARTUP?	field( PINI, "YES")
}

record(calcout, "$(P)REP_P_TO_F")
{
	field(INPA, "$(P)REP_PERIOD")
	field(CALC, "1000/A")
	field(OUT, "$(P)REP_FREQUENCY PP MS")
	field( SDIS, "$(P)REP_F_TO_P.PACT")
	field( DISV, "1")
	field( PREC, "5")
	field( EGU, "Hz")
}

record(calcout, "$(P)REP_F_TO_P")
{
	field(INPA, "$(P)REP_FREQUENCY")
	field(CALC, "1000/A")
	field(OUT, "$(P)REP_PERIOD PP MS")
	field( SDIS, "$(P)REP_P_TO_F.PACT")
	field( DISV, "1")
	field( PREC, "5")
	field( EGU, "ms")
}

record(ao, "$(P)REP_FREQUENCY")
{
# Max is 1320 MHz /14
	field( HOPR, "94285714.286")
	field( DRVH, "94285714.286")
	field( EGU, "Hz")
	field(FLNK, "$(P)REP_F_TO_P")
	field( PREC, "5")
}

# User interface PV in ms
record(ao, "$(P)PULSE_LENGTH")
{
	field( LOPR, "0")
	field( DRVL, "0")
	field( EGU, "ms")
	field( FLNK, "$(P)PULSE_LENGTH_U_TO_R")
	field( PREC, "5")
}


record(calcout, "$(P)PULSE_LENGTH_U_TO_R")
{
# ASLO is 1/IF, or 14/1320 MHz
	field( INPA, "$(P)PULSE_LENGTH PP")
	field( CALC, "FLOOR(0.5+(A*1320000/14)/132)")
	field(EGU, "ms")
	field( LOPR, "0")
	field( OUT, "$(P)$(CHASSIS)PULSE_LENGTH_W PP MS")
	field( PREC, "5")
}

record( ao, "$(P)$(CHASSIS)PULSE_LENGTH_W"){
	field( FLNK, "$(P)PULSE_LENGTH_Sync")
	field(EGU, "s")
}

record( calcout, "$(P)PULSE_LENGTH_Sync"){
	field( INPA,  "$(P)$(CHASSIS)PULSE_LENGTH_W PP MS")
	field( OUT,  "$(P)PULSE_LENGTH PP MS")
	field( SDIS, "$(P)PULSE_LENGTH_U_TO_R.PACT")
	field( DISV, "1")
	field( EGU, "ms")
# time in us is 1320MHz/14, 1 IF cycle per ADC count
	field( CALC, "A*132*14/1320000")
	field(FLNK, "$(P)REP_P_TO_F")
	field( PREC, "5")
####xxxx iS THIS CAUSING A WRITE OF 0 ON STARTUP?	field( PINI, "YES")
}

# When ramping duty cycle, increase the frequency, not the pulse length
record( ao, "$(P)DUTY_CYCLE")
{
	field( LOPR, "0")
	field( DRVL, "0")
	field( HOPR, "100")
	field( DRVH, "100")
	field( EGU, "%")
	field( FLNK, "$(P)DUTY_CYCLE_Sync_Out PP")
	field( PREC, "5")
}

record( calcout, "$(P)DUTY_CYCLE_Sync_Out")
{
	field( INPA, "$(P)DUTY_CYCLE")
	field( INPB, "$(P)PULSE_LENGTH")
	field( OCAL, "A==0?0:B/(A/100)")
	field( DOPT, "Use OCAL")
	field( OUT, "$(P)REP_PERIOD PP")
	# Only output when neither length nor period are updating
	field( INPC, "$(P)PULSE_LENGTH.PACT")
	field( INPD, "$(P)REP_PERIOD.PACT")
	field( CALC, "C|D")
	field( OOPT, "When Zero")
	field( SDIS, "$(P)DUTY_CYCLE_Sync_In.PACT")
	field( DISV, "1")
	field( EGU, "%")
#	field( FLNK, "$(P)REP_PERIOD")
	field( PREC, "5")
}

record( calcout, "$(P)DUTY_CYCLE_Sync_In")
{
	field( INPA, "$(P)REP_PERIOD CP")
	field( INPB, "$(P)PULSE_LENGTH CP MS")
	field( CALC, "A==0?0:B>=A?100:100*B/A")
	field( OOPT, "On Change")
	field( OUT, "$(P)DUTY_CYCLE PP MS")
	field( SDIS, "$(P)DUTY_CYCLE_Sync_Out.PACT")
	field( DISV, "1")
	field( EGU, "%")
	field( PREC, "5")
}

record( calcout, "$(P)DETUNE_MODE_CALC")
{
	field( INPA, "$(P)REP_PERIOD CP MS")
	field( INPB, "$(P)PULSE_LENGTH CP MS")
	# The number of ms between pulses that marks the transition from pulsed
	# to CW. Determined by observation, and where pulse mode calculation
	# results are as bad as CW mode calculations.
	field( INPC, "0.04")
	field( CALC, "A-B > C")
	field( OUT, "$(P)DETUNE_MODE PP MS")
	info( autosaveFields, "INPC")
}

record( bi, "$(P)DETUNE_MODE")
{
	field( ONAM, "Pulse")
	field(ZNAM, "CW")
}

record( calcout, "$(P)PULSE_MODE_CALC")
{
	field( INPA, "$(P)DUTY_CYCLE CP MS")
	field( CALC, "A < 100")
	field( OUT, "$(P)PULSE_MODE PP MS")
	info( autosaveFields, "INPC")
}

record( bi, "$(P)PULSE_MODE")
{
	field( ONAM, "Pulse")
	field(ZNAM, "CW")
}

record( calc, "$(P)SMOOTHED_BW")
{
	field( INPA, "$(P)CAV1:DECAY_BW CP MS")
	field( INPB, "$(P)CAV2:DECAY_BW CP MS")
	field( INPC, "0.9") # Smoothing factor
	field( INPD, "$(P)ACTIVE_PROBE")
	field( CALC, "C*VAL+(1-C)*(D=1?A:B)")
	field( SDIS, "$(P)DETUNE_MODE")
	field( DISV, "0") # stop updating this when not pulsing
	field(EGU, "Hz")
	info( autosaveFields, "VAL")
}

# On the user side, setpoints are amplitude/phase.
# On the FPGA side, they're I/Q
record( ao, "$(P)ADES"){
	field( DESC, "RF Amplitude Setpoint")
	field( OUT,  "$(P)SET_PLOOP_AP_TO_IQ PP")
	field( PREC, "5")
	field( HOPR, "0x7FFF")
	field( LOPR, "0")
	field(EGU, "MV")
	info( autosaveFields, "DRVH DRVL HIGH HIHI LOW")
}

record( ao, "$(P)AMAX")
{
	field(DESC, "Limit on requested output")
	field(EGU, "MV")
	info( autosaveFields, "VAL")

}
record(dfanout, "$(P)AMAX_SYNC") {
	field(OUTA, "$(P)ADES.HOPR")
	field(OUTB, "$(P)ADES.DRVH")
	field(OUTA, "$(P)AOPEN.HOPR")
	field(OUTB, "$(P)AOPEN.DRVH")
	field(DOL, "$(P)AMAX")
	field(OMSL, "closed_loop")
	field(EGU, "MV")
}

record( ao, "$(P)PDES"){
	field( DESC, "RF Phase Setpoint")
	field( OUT,  "$(P)SET_PLOOP_AP_TO_IQ PP")
	field( PREC, "5")
	field( HOPR, "180")
	field( LOPR, "-180")
	field(EGU, "degrees")
	info( autosaveFields, "DRVH DRVL HIGH HIHI LOW LOLO")
}

record( fanout,  "$(P)SET_PLOOP_AP_TO_IQ")
{
	field(LNK1, "$(P)SET_PLOOP_AP_TO_I PP")
	field(LNK2, "$(P)SET_PLOOP_AP_TO_Q PP")
}

record( calcout, "$(P)SET_PLOOP_AP_TO_I")
{
	field( INPA, "$(P)ADES")
	field( INPB, "$(P)PDES")
	field( INPC, "$(SCALEP)SCALE")
	field( INPD, "$(SCALEP)GOLD")
	field( CALC, "A*COS((B-D)*D2R)/C")
	field( OUT, "$(P)$(CHASSIS)SET_PLOOP_RE_W PP")
	field( OOPT, "On Change")
	field(EGU, "MV")
}

record( calcout, "$(P)SET_PLOOP_AP_TO_Q")
{
	field( INPA, "$(P)ADES")
	field( INPB, "$(P)PDES")
	field( INPC, "$(SCALEP)SCALE")
	field( INPD, "$(SCALEP)GOLD")
	field( CALC, "A*SIN((B-D)*D2R)/C")
	field( OUT, "$(P)$(CHASSIS)SET_PLOOP_IM_W PP")
	field( OOPT, "On Change")
	field(EGU, "MV")
}

record( ao, "$(P)PH_DELAY")
{
	field( DESC, "Initial phase on loop close")
	field( EGU, "degrees")
	field( HOPR, "360.0" )
	field( LOPR, "0" )
	field( FLNK, "$(P)PH_DELAY_Sync_Out")
	info( autosaveFields, "VAL")
}

record( calcout, "$(P)PH_DELAY_Sync_Out")
{
	field( DESC, "Initial phase on loop close")
	field( INPA, "$(P)PH_DELAY")
	field( INPB, "$(P)$(CHASSIS)PHDELAY_W.HOPR")
	field( CALC, "A*B/360")
	field( OUT, "$(P)$(CHASSIS)PHDELAY_W PP")
	field( OOPT, "On Change")
	field( SDIS, "$(P)PH_DELAY_Sync_In.PACT")
	field( DISV, "1")
}

record( ao, "$(P)$(CHASSIS)PHDELAY_W")
{
	field( FLNK, "$(P)PH_DELAY_Sync_In")
}

record( calcout, "$(P)PH_DELAY_Sync_In")
{
	field( DESC, "Initial phase on loop close")
	field( INPA, "$(P)$(CHASSIS)PHDELAY_W")
	field( INPB, "$(P)$(CHASSIS)PHDELAY_W.HOPR")
	field( CALC, "A*360/B")
	field( OUT, "$(P)PH_DELAY PP")
	field( OOPT, "On Change")
	field( SDIS, "$(P)PH_DELAY.PACT")
	field( DISV, "1")
}

# Above is closed loop settings. Below are open loop, in A/D units

record( ao, "$(P)AOPEN"){
	field( DESC, "RF Amplitude Setpoint")
	field( OUT,  "$(P)SOURCE_AP_TO_IQ PP")
	field( PREC, "5")
	field( LOPR, "0")
	field(EGU, "MV")
	info( autosaveFields, "DRVH DRVL HIHI HIGH LOW LOLO HOPR LOPR")
}

record( calc, "$(P)AOPEN_RAW" )
{
	field( DESC, "Open loop output in DAC counts")
	field( INPA, "$(P)$(CHASSIS)SOURCE_RE_W CP")
	field( INPB, "$(P)$(CHASSIS)SOURCE_IM_W CP")
	field(CALC, "SQRT(A^2+B^2)")
}

record( ao, "$(P)POPEN"){
	field( DESC, "RF Phase Setpoint")
	field(EGU, "degrees")
	field( OUT,  "$(P)SOURCE_AP_TO_IQ PP")
	field( PREC, "5")
	field( HOPR, "360")
	field( LOPR, "-360")
	info( autosaveFields, "DRVH DRVL HIHI HIGH LOW LOLO HOPR LOPR")
}

record( calc, "$(P)POPEN_RAW" )
{
	field( DESC, "Phase of raw DAC values")
	field( INPA, "$(P)$(CHASSIS)SOURCE_RE_W CP")
	field( INPB, "$(P)$(CHASSIS)SOURCE_IM_W CP")
	field(CALC, "ATAN2(B,A)*R2D")
	field(EGU, "degrees")
}

# Set DAC scale so AOPEN matches a measured amplitude.
# Keep this passive, so it is only applied when a button is pushed.
record( calc, "$(P)AOPEN_SCALE_CALC" ) {
	field( INPA, "$(P)AOPEN_RAW")
	field( INPB, "$(P)CAV1:AMEAN CP MS") # Use this waveform mean to scale AOPEN
	field( INPC, "$(P)CAV2:AMEAN CP MS") # Use this waveform mean to scale AOPEN
	field( INPD, "$(P)ACTIVE_PROBE")
	field( INPE, "0.95") # Equivalent of SMOO field in ai records
	field( CALC, "(1-E)*A/(D=1?B:C) + (ISNAN(VAL)?0:VAL)*E")
	info( autosaveFields, "VAL")
}
record(ao, "$(P)USE_AOPEN_SCALE_CALC")
{ # To allow manual scale to be entered, only process this when
# the "PROC" field is written. It's a suggestion, not a feedback loop.
	field( DOL,  "$(P)AOPEN_SCALE_CALC NPP MS")
	field( OMSL, "closed_loop")
	field( OUT,  "$(P)AOPEN_SCALE PP MS")
}
record( ao, "$(P)AOPEN_SCALE" ) {
	field( FLNK, "$(P)AOPEN_MAX_CALC" )
	field( VAL, "1")
	info( autosaveFields, "VAL")
}

record( calcout, "$(P)AOPEN_MAX_CALC" ) {
	field( INPA, "$(P)$(CHASSIS)SOURCE_RE_W.HOPR") # Use register max
	field( INPB, "$(P)AOPEN_SCALE")
	field( CALC, "A/B")
	field( OUT, "$(P)SET_AOPEN_LIMITS PP" )
	field( PINI, "YES")
	info( autosaveFields, "VAL")
}
record( dfanout, "$(P)SET_AOPEN_LIMITS") {

	field( OUTA, "$(P)AOPEN.DRVH" )
	field( OUTB, "$(P)AOPEN.HOPR" )
}

# Offset DAC phase so POPEN matches measured cavity phase.
# Keep this passive, so it is only applied when a button is pushed.
record( calc, "$(P)POPEN_SCALE_CALC" ) {
	field( INPA, "$(P)POPEN_RAW NPP MS")
	field( INPB, "$(P)PACT CP MS") # Use this waveform mean to scale POPEN
	field( INPC, "0.95") # Equivalent of SMOO field in ai records
	field( CALC, "(1-C)*(A-B) + C*(ISNAN(VAL)?0:VAL)")
	info( autosaveFields, "VAL")
}
record(ao, "$(P)USE_POPEN_SCALE_CALC")
{ # To allow manual scale to be entered, only process this when
# the "PROC" field is written. It's a suggestion, not a feedback loop.
	field( DOL,  "$(P)POPEN_SCALE_CALC NPP MS")
	field( OMSL, "closed_loop")
	field( OUT,  "$(P)POPEN_SCALE PP MS")
}
record( ao, "$(P)POPEN_SCALE" ) {
	field( VAL, "0")
	info( autosaveFields, "VAL")
}

# writing to open loop setpoints during closed loop
# has no effect, so don't bother to disable
record( fanout,  "$(P)SOURCE_AP_TO_IQ")
{
	field(LNK1, "$(P)SOURCE_AP_TO_I PP")
	field(LNK2, "$(P)SOURCE_AP_TO_Q PP")
}

record( calcout, "$(P)SOURCE_AP_TO_I")
{
	field( INPA, "$(P)AOPEN")
	field( INPB, "$(P)POPEN")
	field( INPC, "$(P)AOPEN_SCALE" )
	field( INPD, "$(P)POPEN_SCALE" )
	field( CALC, "A*C*COS((B-D)*D2R)")
	field( OUT, "$(P)$(CHASSIS)SOURCE_RE_W PP")
}

record( calcout, "$(P)SOURCE_AP_TO_Q")
{
	field( INPA, "$(P)AOPEN")
	field( INPB, "$(P)POPEN")
	field( INPC, "$(P)AOPEN_SCALE" )
	field( INPD, "$(P)POPEN_SCALE" )
	field( CALC, "A*C*SIN((B-D)*D2R)")
	field( OUT, "$(P)$(CHASSIS)SOURCE_IM_W PP")
}

record( ao, "$(P)SOURCE_RE_Sync"){
# This should be processed right before opening I/Q loop
	field( SDIS, "$(P)$(CHASSIS)CLOSE_LOOP_W")
	field( DISV, "0")
	field( DOL,  "$(P)$(CHASSIS)VOUTXFALL_R NPP MS")
	field( OMSL, "closed_loop")
	field( OUT,  "$(P)SOURCE_IQ_TO_AP PP MS")
}

record( ao, "$(P)SOURCE_IM_Sync"){
# This should be processed right before opening I/Q loop
	field( DOL,  "$(P)$(CHASSIS)VOUTYFALL_R NPP MS")
	field( OMSL, "closed_loop")
	field( OUT,  "$(P)SOURCE_IQ_TO_AP PP MS")
}

record( fanout,  "$(P)SOURCE_IQ_TO_AP")
{
	field(LNK1, "$(P)SOURCE_IQ_TO_A PP MS")
	field(LNK2, "$(P)SOURCE_IQ_TO_P PP MS")
}

record( calcout, "$(P)SOURCE_IQ_TO_A")
{
	field( INPA, "$(P)$(CHASSIS)VOUTXFALL_R NPP MS")
	field( INPB, "$(P)$(CHASSIS)VOUTYFALL_R NPP MS")
	field( INPC, "$(P)AOPEN_SCALE" )
	field(CALC, "SQRT(A^2+B^2)/C")
	field( OUT, "$(P)AOPEN PP")
	field( OOPT, "On Change")
}

record( calcout, "$(P)SOURCE_IQ_TO_P")
{
	field( INPA, "$(P)$(CHASSIS)VOUTXFALL_R NPP MS")
	field( INPB, "$(P)$(CHASSIS)VOUTYFALL_R NPP MS")
	field( INPD, "$(P)POPEN_SCALE" )
	field(CALC, "ATAN2(A,B)*R2D+D")
	field( OUT, "$(P)POPEN PP")
	field( OOPT, "On Change")
}

record( ao, "$(P)$(CHASSIS)THRESH_INIT_W")
{
	info( autosaveFields, "VAL")
}
record( ao, "$(P)$(CHASSIS)THRESH_NOISE_W")
{
	info( autosaveFields, "VAL")
}
record( ao, "$(P)$(CHASSIS)DECAY_COEF_W")
{
	info( autosaveFields, "VAL")
}
record( acalcout, "$(P)REV:AWF_LIMIT")
{
	field( INPA, "$(P)$(CHASSIS)THRESH_INIT_W CP MS")
	field( INPB, "$(P)$(CHASSIS)DECAY_COEF_W CP MS")
	field( INPC, "$(P)$(CHASSIS)THRESH_NOISE_W CP MS")
	field( INAA, "$(P)$(CHASSIS)DECAY_X_AXIS NPP MS")
	field( CALC, "A/EXP(B*AA)+C")
	field( NELM, "256")
	field( NUSE, "256")

}

# Dummy waveforms, because sometime they make the x-y graph wiget happy
record(waveform, "$(P)NULL:ITWF") {
	field(DESC, "Dummy phase Waveform")
	field(NELM, "0")
	field(FTVL, "FLOAT")
}
record(waveform, "$(P)NULL:QTWF") {
	field(DESC, "Dummy phase Waveform")
	field(NELM, "0")
	field(FTVL, "FLOAT")
}
record(waveform, "$(P)NULL:AWF") {
	field(DESC, "Dummy phase Waveform")
	field(NELM, "0")
	field(FTVL, "FLOAT")
}
record(waveform, "$(P)NULL:PWF") {
	field(DESC, "Dummy phase Waveform")
	field(NELM, "0")
	field(FTVL, "FLOAT")
}

record(mbbo, "$(P)WF_TIME_PER_POINT") {
field(OUT, "$(P)WAVE_SAMP_PER_FAN PP")
field(ZRVL, "1")
field(ONVL, "2")
field(TWVL, "4")
field(THVL, "8")
field(FRVL, "16")
field(FVVL, "32")
field(SXVL, "64")
field(SVVL, "128")
field(EIVL, "255")
field(ZRST, "1.4 us")
field(ONST, "2.8 us")
field(TWST, "5.6 us")
field(THST, "11.2 us")
field(FRST, "22.4 us")
field(FVST, "44.8 us")
field(SXST, "89.6 us")
field(SVST, "179.2 us")
field(EIST, "0.357 ms")
field(DTYP, "Raw Soft Channel")
}

record(dfanout, "$(P)WAVE_SAMP_PER_FAN")
{
	field(OUTA, "$(P)PRC:WAVE_SAMP_PER_W PP")
	field(OUTB, "$(P)RFS1:WAVE_SAMP_PER_W PP")
	field(OUTC, "$(P)RFS2:WAVE_SAMP_PER_W PP")
	field(DOL, "$(P)WF_TIME_PER_POINT.RVAL")
	field(OMSL, "closed_loop")
}

record( dfanout, "$(P)LIMIT_TRIP_RESET") {

	field( OUTA, "$(P)PRC:RESET_INLK_1_W PP" )
	field( OUTB, "$(P)RFS1:RESET_INLK_1_W PP" )
	field( OUTC, "$(P)RFS2:RESET_INLK_1_W PP" )
}


record( bo, "$(P)RF_GO")
{
	field(FLNK, "$(P)RF_GO_3CH PP")
	field(HIGH, 1)
}

record( dfanout, "$(P)RF_GO_3CH")
{
	field(OMSL, "closed_loop")
	field(DOL, "$(P)RF_GO")
	field(OUTA, "$(P)PRC:RF_GO_W PP")
	field(OUTB, "$(P)RFS1:RF_GO_W PP")
	field(OUTC, "$(P)RFS2:RF_GO_W PP")
}
#record(calc, "$(P)IFDES2MODULO")
#{
#field(INPA, "$(P)IFDES")
#field(CALC, "

#! Further lines contain data used by VisualDCT
#! View(1074,190,1.6)
#! Record("$(P)TRACE_DATA_N_ACTIVE",980,27,0,0,"$(P)TRACE_DATA_N_ACTIVE")
#! Record("$(P)CIRC_1_N_ACTIVE",1220,27,0,0,"$(P)CIRC_1_N_ACTIVE")
#! Record("$(P)IFACT",1460,27,0,0,"$(P)IFACT")
#! Record("$(P)IFDES",1700,10,0,0,"$(P)IFDES")
#! Record("$(P)TRACE_DATA_CIRCLE_COUNT_R",1940,27,0,0,"$(P)TRACE_DATA_CIRCLE_COUNT_R")
#! Record("$(P)TRACE_DATA_CIRCLE_STAT_R",2180,27,0,0,"$(P)TRACE_DATA_CIRCLE_STAT_R")
#! Record("$(P)TRACE_DATA_TAG_NOW_R",2420,27,0,0,"$(P)TRACE_DATA_TAG_NOW_R")
#! Record("$(P)TRACE_DATA_TAG_OLD_R",2660,27,0,0,"$(P)TRACE_DATA_TAG_OLD_R")
#! Record("$(P)TRACE_DATA_MIN0_R",2900,27,0,0,"$(P)TRACE_DATA_MIN0_R")
#! Record("$(P)TRACE_DATA_MIN1_R",3140,27,0,0,"$(P)TRACE_DATA_MIN1_R")
#! Record("$(P)TRACE_DATA_MIN2_R",3380,27,0,0,"$(P)TRACE_DATA_MIN2_R")
#! Record("$(P)TRACE_DATA_MAX0_R",3620,27,0,0,"$(P)TRACE_DATA_MAX0_R")
#! Record("$(P)TRACE_DATA_MAX1_R",3860,27,0,0,"$(P)TRACE_DATA_MAX1_R")
#! Record("$(P)TRACE_DATA_MAX2_R",4100,27,0,0,"$(P)TRACE_DATA_MAX2_R")
#! Record("$(P)TRACE_DATA_TIME_STAMP_HIGH_R",4340,27,0,0,"$(P)TRACE_DATA_TIME_STAMP_HIGH_R")
#! Record("$(P)TRACE_DATA_TIME_STAMP_LOW_R",4580,27,0,0,"$(P)TRACE_DATA_TIME_STAMP_LOW_R")
#! Record("$(P)TRACE_DATA_SLOW_DATA_R",20,374,0,0,"$(P)TRACE_DATA_SLOW_DATA_R")
#! Record("$(P)TRACE_DATA_TIME_STEP",260,379,0,0,"$(P)TRACE_DATA_TIME_STEP")
#! Field("$(P)TRACE_DATA_TIME_STEP.VAL",16777215,0,"$(P)TRACE_DATA_TIME_STEP.VAL")
#! Record("$(P)TRACE_DATA_CALCX",500,377,0,0,"$(P)TRACE_DATA_CALCX")
#! Field("$(P)TRACE_DATA_CALCX.INPA",16777215,0,"$(P)TRACE_DATA_CALCX.INPA")
#! Link("$(P)TRACE_DATA_CALCX.INPA","$(P)TRACE_DATA_TIME_STEP.VAL")
#! Field("$(P)TRACE_DATA_CALCX.OUT",16777215,1,"$(P)TRACE_DATA_CALCX.OUT")
#! Link("$(P)TRACE_DATA_CALCX.OUT","$(P)TRACE_DATA_X_AXIS.VAL")
#! Record("$(P)TRACE_DATA_X_AXIS",740,385,0,0,"$(P)TRACE_DATA_X_AXIS")
#! Field("$(P)TRACE_DATA_X_AXIS.VAL",16777215,1,"$(P)TRACE_DATA_X_AXIS.VAL")
#! Record("$(P)TRACE_DATA_UPDATE_PLOT",980,370,0,0,"$(P)TRACE_DATA_UPDATE_PLOT")
#! Record("$(P)TRACE_UPDATE_PLOT",500,735,0,0,"$(P)TRACE_UPDATE_PLOT")
#! Field("$(P)TRACE_UPDATE_PLOT.DOL",16777215,1,"$(P)TRACE_UPDATE_PLOT.DOL")

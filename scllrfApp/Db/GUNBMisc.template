#! Generated by VisualDCT v2.6
#! DBDSTART
#! DBDEND

# Macros:
# P - Prefix matching what the register
#Make PVs for pulse width in ms, pulse frequency in Hz, and duty cycle in %, so that they calculate each other. Leave raw register values in raw counts.

# Bit width of pulse parameters might change, but the math is easy and won't change.
# ADC counts are a multiple of IF, which is 1320MHz/14 or 1320000kHz/14

# User interface PV in us
record(ao, "$(P)REP_PERIOD")
{
	field( DESC, "Pulsed mode pulse period")
	field( LOPR, "0")
	field( DRVL, "0")
	field( EGU, "ms")
	field( FLNK, "$(P)REP_PERIOD_U_TO_R")
	field( PREC, "7")
}
# Using a calcout instead of ao because ao misbehaved with SDIS loop breaking
record(calcout, "$(P)REP_PERIOD_U_TO_R")
{
	field( DESC, "Convert EGU to raw register value")
	field( INPA, "$(P)REP_PERIOD PP")
# 1/IF, or 14/1320 MHz. 1320000 is kHz, to go with ms, round to multiples of 132*2
	field( CALC, "FLOOR(0.5+(A*1320000/14)/132)")
	field( EGU, "ms")
	field( LOPR, "0")
	field( OUT, "$(P)REP_PERIOD_W PP MS")
	field( PREC, "7")
}

record( ao, "$(P)REP_PERIOD_W"){
	field( FLNK, "$(P)REP_PERIOD_Sync")
	field( EGU, "IF counts")
}

record( calcout, "$(P)REP_PERIOD_Sync"){
	field( INPA,  "$(P)REP_PERIOD_W PP MS")
#	field( OMSL, "closed_loop")
	field( OUT,  "$(P)REP_PERIOD PP MS")
	field( SDIS, "$(P)REP_PERIOD_U_TO_R.PACT")
	field( DISV, "1")
	field( EGU, "ms")
# time in us is 1320MHz/14, 1 IF cycle per ADC count
	field( CALC, "A*132*14/1320000")
	field(FLNK, "$(P)REP_P_TO_F")
	field( PREC, "7")
}

record(calcout, "$(P)REP_P_TO_F")
{
	field(INPA, "$(P)REP_PERIOD")
	field(CALC, "1000/A")
	field(OUT, "$(P)REP_FREQUENCY PP")
	field( SDIS, "$(P)REP_F_TO_P.PACT")
	field( DISV, "1")
	field( PREC, "7")
}

record(calcout, "$(P)REP_F_TO_P")
{
	field(INPA, "$(P)REP_FREQUENCY")
	field(CALC, "1000/A")
	field(OUT, "$(P)REP_PERIOD PP")
	field( SDIS, "$(P)REP_P_TO_F.PACT")
	field( DISV, "1")
	field( PREC, "7")
}

record(ao, "$(P)REP_FREQUENCY")
{
# Max is 1320 MHz /14
	field( HOPR, "94285714.286")
	field( DRVH, "94285714.286")
	field( EGU, "Hz")
	field(FLNK, "$(P)REP_F_TO_P")
	field( PREC, "7")
}

# User interface PV in us
record(ao, "$(P)PULSE_LENGTH")
{
	field( LOPR, "0")
	field( DRVL, "0")
	field( EGU, "us")
	field( FLNK, "$(P)PULSE_LENGTH_U_TO_R")
	field( PREC, "7")
}


record(calcout, "$(P)PULSE_LENGTH_U_TO_R")
{
# ASLO is 1/IF, or 14/1320 MHz
	field( INPA, "$(P)PULSE_LENGTH PP")
	field( CALC, "FLOOR(0.5+(A*1320000/14)/132)")
	field(EGU, "ms")
	field( LOPR, "0")
	field( OUT, "$(P)PULSE_LENGTH_W PP MS")
	field( PREC, "7")
}

record( ao, "$(P)PULSE_LENGTH_W"){
	field( FLNK, "$(P)PULSE_LENGTH_Sync")
}

record( calcout, "$(P)PULSE_LENGTH_Sync"){
	field( INPA,  "$(P)PULSE_LENGTH_W PP MS")
	field( OUT,  "$(P)PULSE_LENGTH PP MS")
	field( SDIS, "$(P)PULSE_LENGTH_U_TO_R.PACT")
	field( DISV, "1")
	field( EGU, "ms")
# time in us is 1320MHz/14, 1 IF cycle per ADC count
	field( CALC, "A*132*14/1320000")
	field(FLNK, "$(P)REP_P_TO_F")
	field( PREC, "7")
}

# When ramping duty cycle, increase the frequency, not the pulse length
record( ao, "$(P)DUTY_CYCLE")
{
	field( LOPR, "0")
	field( DRVL, "0")
	field( HOPR, "100")
	field( DRVH, "100")
	field( EGU, "%")
	field( FLNK, "$(P)DUTY_CYCLE_Sync_Out PP")
	field( PREC, "7")
}

record( calcout, "$(P)DUTY_CYCLE_Sync_Out")
{
	field( INPA, "$(P)DUTY_CYCLE")
	field( INPB, "$(P)PULSE_LENGTH")
	field( OCAL, "A==0?0:B/(A/100)")
	field( DOPT, "Use OCAL")
	field( OUT, "$(P)REP_PERIOD PP")
	# Only output when neither length nor period are updating
	field( INPC, "$(P)PULSE_LENGTH.PACT")
	field( INPD, "$(P)REP_PERIOD.PACT")
	field( CALC, "C|D")
	field( OOPT, "When Zero")
	field( SDIS, "$(P)DUTY_CYCLE_Sync_In.PACT")
	field( DISV, "1")
	field( EGU, "%")
#	field( FLNK, "$(P)REP_PERIOD")
	field( PREC, "7")
}

record( calcout, "$(P)DUTY_CYCLE_Sync_In")
{
	field( INPA, "$(P)REP_PERIOD CP")
	field( INPB, "$(P)PULSE_LENGTH CP")
	field( CALC, "A==0?0:B>A?100:100*B/A")
	field( OOPT, "On Change")
	field( OUT, "$(P)DUTY_CYCLE PP")
	field( SDIS, "$(P)DUTY_CYCLE_Sync_Out.PACT")
	field( DISV, "1")
	field( EGU, "%")
	field( PREC, "7")
}


# On the user side, setpoints are amplitude/phase.
# On the FPGA side, they're I/Q
record( ao, "$(P)ADES"){
	field( DESC, "RF Amplitude Setpoint")
	field( OUT,  "$(P)SET_PLOOP_AP_TO_IQ PP")
	field( PREC, "3")
	field( HOPR, "0x7FFF")
	field( LOPR, "0")
}

record( ao, "$(P)PDES"){
	field( DESC, "RF Phase Setpoint")
	field( OUT,  "$(P)SET_PLOOP_AP_TO_IQ PP")
	field( PREC, "3")
	field( HOPR, "180")
	field( LOPR, "-180")
}

record( fanout,  "$(P)SET_PLOOP_AP_TO_IQ")
{
	field(LNK1, "$(P)SET_PLOOP_AP_TO_I PP")
	field(LNK2, "$(P)SET_PLOOP_AP_TO_Q PP")
}

record( calcout, "$(P)SET_PLOOP_AP_TO_I")
{
	field( INPA, "$(P)ADES")
	field( INPB, "$(P)PDES")
	field( INPC, "$(SCALEPV)")
	field( CALC, "A*COS(B*D2R)/C")
	field( OUT, "$(P)SET_PLOOP_RE_W PP")
	field( OOPT, "On Change")
}

record( calcout, "$(P)SET_PLOOP_AP_TO_Q")
{
	field( INPA, "$(P)ADES")
	field( INPB, "$(P)PDES")
	field( INPC, "$(SCALEPV)")
	field( CALC, "A*SIN(B*D2R)/C")
	field( OUT, "$(P)SET_PLOOP_IM_W PP")
	field( OOPT, "On Change")
}

record( ao, "$(P)PH_DELAY")
{
	field( DESC, "Initial phase on loop close")
	field( EGU, "degrees")
	field( HOPR, "360.0" )
	field( LOPR, "0" )
	field( FLNK, "$(P)PH_DELAY_Sync_Out")
}

record( calcout, "$(P)PH_DELAY_Sync_Out")
{
	field( DESC, "Initial phase on loop close")
	field( INPA, "$(P)PH_DELAY")
	field( INPB, "$(P)PHDELAY_W.HOPR")
	field( CALC, "A*B/360")
	field( OUT, "$(P)PHDELAY_W PP")
	field( OOPT, "On Change")
	field( SDIS, "$(P)PH_DELAY_Sync_In.PACT")
	field( DISV, "1")
}

record( ao, "$(P)PHDELAY_W")
{
	field( FLNK, "$(P)PH_DELAY_Sync_In")
}

record( calcout, "$(P)PH_DELAY_Sync_In")
{
	field( DESC, "Initial phase on loop close")
	field( INPA, "$(P)PHDELAY_W")
	field( INPB, "$(P)PHDELAY_W.HOPR")
	field( CALC, "A*360/B")
	field( OUT, "$(P)PH_DELAY PP")
	field( OOPT, "On Change")
	field( SDIS, "$(P)PH_DELAY.PACT")
	field( DISV, "1")
}

# Above is closed loop settings. Below are open loop, in A/D units

record( ao, "$(P)AOPEN"){
	field( DESC, "RF Amplitude Setpoint")
	field( OUT,  "$(P)SOURCE_AP_TO_IQ PP")
	field( PREC, "3")
	field( HOPR, "0x7FFF")
	field( LOPR, "0")
}

record( ao, "$(P)POPEN"){
	field( DESC, "RF Phase Setpoint")
	field( OUT,  "$(P)SOURCE_AP_TO_IQ PP")
	field( PREC, "3")
	field( HOPR, "360")
	field( LOPR, "-360")
}

# Set DAC scale so AOPEN matches a measured amplitude.
# Keep this passive, so it is only applied when a button is pushed.
record( calcout, "$(P)SCALE_AOPEN" ) {
	field( INPA, "$(P)CAV1:AMEAN") # Use this waveform mean to scale AOUT
	field( INPB, "$(P)AOPEN")
	field( INPC, "$(P)AOPEN.ASLO")
	field( CALC, "C*A/B")
	field( OUT, "$(P)AOPEN.ASLO")
}

# writing to open loop setpoints during closed loop
# has no effect, so don't bother to disable
record( fanout,  "$(P)SOURCE_AP_TO_IQ")
{
	field(LNK1, "$(P)SOURCE_AP_TO_I PP")
	field(LNK2, "$(P)SOURCE_AP_TO_Q PP")
}

record( calcout, "$(P)SOURCE_AP_TO_I")
{
	field( INPA, "$(P)AOPEN")
	field( INPB, "$(P)POPEN")
	field( CALC, "A*COS(B*D2R)")
	field( OUT, "$(P)SOURCE_RE_W PP")
}

record( calcout, "$(P)SOURCE_AP_TO_Q")
{
	field( INPA, "$(P)AOPEN")
	field( INPB, "$(P)POPEN")
	field( CALC, "A*SIN(B*D2R)")
	field( OUT, "$(P)SOURCE_IM_W PP")
}

record( ai, "$(P)VOUTXFALL_R"){
	field( FLNK, "$(P)SOURCE_RE_Sync")
}

record( ao, "$(P)SOURCE_RE_Sync"){
# This should be inactive when loop is closed
	field( SDIS, "$(P)CLOSE_LOOP_W")
	field( DISV, "0")
	field( DOL,  "$(P)VOUTXFALL_R PP")
	field( OMSL, "closed_loop")
	field( OUT,  "$(P)SOURCE_IQ_TO_AP PP")
}

record( ai, "$(P)VOUTYFALL_R"){
	field( FLNK, "$(P)SOURCE_IM_Sync")
}
record( ao, "$(P)SOURCE_IM_Sync"){
# This should be inactive when loop is OPEN
	field( SDIS, "$(P)CLOSE_LOOP_W")
	field( DISV, "0")
	field( DOL,  "$(P)VOUTYFALL_R PP")
	field( OMSL, "closed_loop")
	field( OUT,  "$(P)SOURCE_IQ_TO_AP PP")
}

record( fanout,  "$(P)SOURCE_IQ_TO_AP")
{
	field(LNK1, "$(P)SOURCE_IQ_TO_A PP")
	field(LNK2, "$(P)SOURCE_IQ_TO_P PP")
}

record( calcout, "$(P)SOURCE_IQ_TO_A")
{
	field( INPA, "$(P)VOUTXFALL_R")
	field( INPB, "$(P)VOUTYFALL_R")
	field(CALC, "(SQRT(A^2+B^2))")
	field( OUT, "$(P)AOPEN PP")
	field( OOPT, "On Change")
}

record( calcout, "$(P)SOURCE_IQ_TO_P")
{
	field( INPA, "$(P)VOUTXFALL_R")
	field( INPB, "$(P)VOUTYFALL_R")
	field(CALC, "(ATAN2(B,A))")
	field( OUT, "$(P)POPEN PP")
	field( OOPT, "On Change")
}

# SSA drive balancing. raw 19898 = 100% amplitude.
# Adjust phase and amplitude so RF is in phase and output is equal.
record(ao, "$(P)DRV1_ADJ_A")
{
	field(EGU, "%")
	field(HOPR, "100")
	field(LOPR, "0")
	field(VAL, "100")
}

record(ao, "$(P)DRV1_ADJ_P")
{
	field(EGU, "degrees")
	field(HOPR, "180")
	field(LOPR, "-180")
}
record( fanout,  "$(P)RFSUPLO1_AP_TO_IQ")
{
	field(LNK1, "$(P)RFSUPLO1_AP_TO_I PP")
	field(LNK2, "$(P)RFSUPLO1_AP_TO_Q PP")
}

record( calcout, "$(P)RFSUPLO1_AP_TO_I")
{
	field( INPA, "$(P)DRV1_ADJ_A")
	field( INPB, "$(P)DRV1_ADJ_P")
	field( CALC, "A*COS(B*D2R)*19898/100")
	field( OUT, "$(P)RFSUPLOX1_W PP")
}

record( calcout, "$(P)RFSUPLO1_AP_TO_Q")
{
	field( INPA, "$(P)DRV1_ADJ_A")
	field( INPB, "$(P)DRV1_ADJ_P")
	field( CALC, "A*SIN(B*D2R)*19898/100")
	field( OUT, "$(P)RFSUPLOY1_W PP")
}


record(ao, "$(P)DRV2_ADJ_A")
{
	field(EGU, "%")
	field(HOPR, "100")
	field(LOPR, "0")
}

record(ao, "$(P)DRV2_ADJ_P")
{
	field(EGU, "degrees")
	field(HOPR, "180")
	field(LOPR, "-180")
}
record( fanout,  "$(P)RFSUPLO2_AP_TO_IQ")
{
	field(LNK1, "$(P)RFSUPLO2_AP_TO_I PP")
	field(LNK2, "$(P)RFSUPLO2_AP_TO_Q PP")
}

record( calcout, "$(P)RFSUPLO2_AP_TO_I")
{
	field( INPA, "$(P)DRV2_ADJ_A")
	field( INPB, "$(P)DRV2_ADJ_P")
	field( CALC, "A*COS(B*D2R)*19898/100")
	field( OUT, "$(P)RFSUPLOX2_W PP")
}

record( calcout, "$(P)RFSUPLO2_AP_TO_Q")
{
	field( INPA, "$(P)DRV2_ADJ_A")
	field( INPB, "$(P)DRV2_ADJ_P")
	field( CALC, "A*SIN(B*D2R)*19898/100")
	field( OUT, "$(P)RFSUPLOY2_W PP")
}

#record(calc, "$(P)IFDES2MODULO")
#{
#field(INPA, "$(P)IFDES")
#field(CALC, "
#
#! Further lines contain data used by VisualDCT
#! View(1074,190,1.6)
#! Record("$(P)TRACE_DATA_N_ACTIVE",980,27,0,0,"$(P)TRACE_DATA_N_ACTIVE")
#! Record("$(P)CIRC_1_N_ACTIVE",1220,27,0,0,"$(P)CIRC_1_N_ACTIVE")
#! Record("$(P)IFACT",1460,27,0,0,"$(P)IFACT")
#! Record("$(P)IFDES",1700,10,0,0,"$(P)IFDES")
#! Record("$(P)TRACE_DATA_CIRCLE_COUNT_R",1940,27,0,0,"$(P)TRACE_DATA_CIRCLE_COUNT_R")
#! Record("$(P)TRACE_DATA_CIRCLE_STAT_R",2180,27,0,0,"$(P)TRACE_DATA_CIRCLE_STAT_R")
#! Record("$(P)TRACE_DATA_TAG_NOW_R",2420,27,0,0,"$(P)TRACE_DATA_TAG_NOW_R")
#! Record("$(P)TRACE_DATA_TAG_OLD_R",2660,27,0,0,"$(P)TRACE_DATA_TAG_OLD_R")
#! Record("$(P)TRACE_DATA_MIN0_R",2900,27,0,0,"$(P)TRACE_DATA_MIN0_R")
#! Record("$(P)TRACE_DATA_MIN1_R",3140,27,0,0,"$(P)TRACE_DATA_MIN1_R")
#! Record("$(P)TRACE_DATA_MIN2_R",3380,27,0,0,"$(P)TRACE_DATA_MIN2_R")
#! Record("$(P)TRACE_DATA_MAX0_R",3620,27,0,0,"$(P)TRACE_DATA_MAX0_R")
#! Record("$(P)TRACE_DATA_MAX1_R",3860,27,0,0,"$(P)TRACE_DATA_MAX1_R")
#! Record("$(P)TRACE_DATA_MAX2_R",4100,27,0,0,"$(P)TRACE_DATA_MAX2_R")
#! Record("$(P)TRACE_DATA_TIME_STAMP_HIGH_R",4340,27,0,0,"$(P)TRACE_DATA_TIME_STAMP_HIGH_R")
#! Record("$(P)TRACE_DATA_TIME_STAMP_LOW_R",4580,27,0,0,"$(P)TRACE_DATA_TIME_STAMP_LOW_R")
#! Record("$(P)TRACE_DATA_SLOW_DATA_R",20,374,0,0,"$(P)TRACE_DATA_SLOW_DATA_R")
#! Record("$(P)TRACE_DATA_TIME_STEP",260,379,0,0,"$(P)TRACE_DATA_TIME_STEP")
#! Field("$(P)TRACE_DATA_TIME_STEP.VAL",16777215,0,"$(P)TRACE_DATA_TIME_STEP.VAL")
#! Record("$(P)TRACE_DATA_CALCX",500,377,0,0,"$(P)TRACE_DATA_CALCX")
#! Field("$(P)TRACE_DATA_CALCX.INPA",16777215,0,"$(P)TRACE_DATA_CALCX.INPA")
#! Link("$(P)TRACE_DATA_CALCX.INPA","$(P)TRACE_DATA_TIME_STEP.VAL")
#! Field("$(P)TRACE_DATA_CALCX.OUT",16777215,1,"$(P)TRACE_DATA_CALCX.OUT")
#! Link("$(P)TRACE_DATA_CALCX.OUT","$(P)TRACE_DATA_X_AXIS.VAL")
#! Record("$(P)TRACE_DATA_X_AXIS",740,385,0,0,"$(P)TRACE_DATA_X_AXIS")
#! Field("$(P)TRACE_DATA_X_AXIS.VAL",16777215,1,"$(P)TRACE_DATA_X_AXIS.VAL")
#! Record("$(P)TRACE_DATA_UPDATE_PLOT",980,370,0,0,"$(P)TRACE_DATA_UPDATE_PLOT")
#! Record("$(P)TRACE_UPDATE_PLOT",500,735,0,0,"$(P)TRACE_UPDATE_PLOT")
#! Field("$(P)TRACE_UPDATE_PLOT.DOL",16777215,1,"$(P)TRACE_UPDATE_PLOT.DOL")
